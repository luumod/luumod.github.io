<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/01/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo<i class="fa fa-external-link-alt"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation<i class="fa fa-external-link-alt"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting<i class="fa fa-external-link-alt"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub<i class="fa fa-external-link-alt"></i></span>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
  </entry>
  <entry>
    <title>二叉树练习（基础 1）</title>
    <url>/2023/03/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%83%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="P4715-【深基16-例1】淘汰赛"><a href="#P4715-【深基16-例1】淘汰赛" class="headerlink" title="P4715 【深基16.例1】淘汰赛"></a>P4715 【深基16.例1】淘汰赛</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ3MTU=">P4715 【深基16.例1】淘汰赛<i class="fa fa-external-link-alt"></i></span></p>
<p>根据输入的n便可以得知：<strong>共有 2^n 个节点</strong>。</p>
<p>我们需要求得亚军是谁，那么我们就是要求第二个是谁。</p>
<p>冠军是谁？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 3 1 10 5 9 7</span><br></pre></td></tr></table></figure>
<p>假如把这个序列左右部分<strong>切开</strong>，那么冠军是一定是左边最大，右边最大的最大的那一个。</p>
<p>这样我们就可以看出一个树的结构：</p>
<p>依次比较两个节点的值，<strong>求出两个节点的较大者为他们两个的“父节点”</strong></p>
<p>这样<strong>依次往上</strong>，从<strong>叶子节点到根节点</strong>，最终还剩两个节点，则较小的就是亚军。</p>
<p>注意我们得到的是<strong>节点的值</strong>，但是我们需要得到这个<strong>节点的编号</strong>，因此使用一个节点体记录<strong>每个节点的编号与值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num,val;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">pow</span>(<span class="number">2</span>,n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        cin&gt;&gt;node[i].val;</span><br><span class="line">        node[i].num=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (len!=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (len==<span class="number">2</span>)&#123;<span class="comment">//直到最后还剩两个节点</span></span><br><span class="line">            <span class="keyword">if</span> (node[<span class="number">1</span>].val&gt;=node[<span class="number">2</span>].val)&#123;</span><br><span class="line">                ans=node[<span class="number">2</span>].num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans=node[<span class="number">1</span>].num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=len;i+=<span class="number">2</span>,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (node[i].val&gt;=node[i+<span class="number">1</span>].val)&#123;</span><br><span class="line">                node[j]=node[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                node[j]=node[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P4913-【深基16-例3】二叉树深度"><a href="#P4913-【深基16-例3】二叉树深度" class="headerlink" title="P4913 【深基16.例3】二叉树深度"></a>P4913 【深基16.例3】二叉树深度</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ5MTM=">P4913 【深基16.例3】二叉树深度<i class="fa fa-external-link-alt"></i></span></p>
<p>直接递归遍历这棵二叉树，同时<strong>统计一个cnt</strong>，每进入一次递归，则cnt+1，最后到达null节点，则ans统计这个时候的 cnt的最大值。</p>
<p>还有没有另外的做法？</p>
<blockquote>
<p> 扩展：求深度也可以使用最短路径来求，例如 使用 floyd算法得到 <strong>根节点到每个节点</strong> 的距离，<strong>规定根节点到与之相邻孩子节点的距离是1</strong>，则如果这个 dp[1] [i] 的值是存在的，则统计 1 -&gt; i的距离的最大值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N],ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node[i].l==<span class="number">0</span> &amp;&amp; node[i].r==<span class="number">0</span>)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,cnt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(node[i].l,cnt+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(node[i].r,cnt+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;node[i].l&gt;&gt;node[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1827-中序与前序，求出后序"><a href="#P1827-中序与前序，求出后序" class="headerlink" title="P1827 中序与前序，求出后序"></a>P1827 中序与前序，求出后序</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE4Mjc=">P1827 [USACO3.4] 美国血统 American Heritage<i class="fa fa-external-link-alt"></i></span></p>
<p>前序遍历：<strong>根左右</strong></p>
<p>中序遍历：<strong>左根右</strong></p>
<p>如果得到了 <strong>根节点</strong>，则我们就能推出一个<strong>分治的过程</strong>，根节点的左边是左孩子部分，根节点的右边是右孩子部分，其中每个左右孩子部分又可以得到<strong>根节点</strong>，然后重复这一过程：</p>
<p>这里介绍STL的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span>(root);	<span class="comment">//返回root的位置，返回值是 size_t 的值，从0开始，如果在头部找到，则返回0</span></span><br><span class="line"><span class="built_in">erase</span>(xxx);<span class="comment">//删除某一个位置</span></span><br><span class="line"><span class="built_in">substr</span>(beg,len)<span class="comment">//从beg开始，截取len个元素</span></span><br><span class="line"><span class="built_in">substr</span>(beg);	<span class="comment">//只有一个beg位置，则截取beg到end的后面的所有元素</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(string mid,string pre)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    前序中序 -&gt; 后序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (mid.<span class="built_in">size</span>()==<span class="number">0</span> || pre.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> root=pre.<span class="built_in">front</span>();<span class="comment">//前序遍历的根节点</span></span><br><span class="line">    pre.<span class="built_in">erase</span>(pre.<span class="built_in">begin</span>());<span class="comment">//删除pre的根节点</span></span><br><span class="line">    <span class="keyword">auto</span> root_it=mid.<span class="built_in">find</span>(root);	<span class="comment">//中序遍历寻找此根节点</span></span><br><span class="line">    <span class="comment">//寻找中序遍历的left部分和right部分</span></span><br><span class="line">    string mid_left=mid.<span class="built_in">substr</span>(<span class="number">0</span>,root_it);</span><br><span class="line">    string mid_right=mid.<span class="built_in">substr</span>(root_it+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//寻找前序遍历的left部分和right部分</span></span><br><span class="line">    string pre_left=pre.<span class="built_in">substr</span>(<span class="number">0</span>,root_it);</span><br><span class="line">    string pre_right=pre.<span class="built_in">substr</span>(root_it);</span><br><span class="line">    <span class="comment">//后序：左右根形式输出</span></span><br><span class="line">    <span class="built_in">dfs1</span>(mid_left,pre_left);<span class="comment">//左</span></span><br><span class="line">    <span class="built_in">dfs1</span>(mid_right,pre_right);<span class="comment">//右</span></span><br><span class="line">    cout&lt;&lt;root;<span class="comment">//根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1030-中序与后序，求出前序"><a href="#P1030-中序与后序，求出前序" class="headerlink" title="P1030 中序与后序，求出前序"></a>P1030 中序与后序，求出前序</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwMzA=">P1030 [NOIP2001 普及组] 求先序排列<i class="fa fa-external-link-alt"></i></span></p>
<p>后序遍历：<strong>左右根</strong></p>
<p>中序遍历：<strong>左根右</strong></p>
<p>只要知道了前序遍历或者后序遍历，再加上中序遍历，就可以推出另一种形式。</p>
<p><strong>但是请注意：后序遍历和前序遍历是无法得到一个唯一的中序遍历的。</strong></p>
<p>这里使用STL的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(string mid,string last)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    后序中序 -&gt; 前序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (mid.<span class="built_in">size</span>()==<span class="number">0</span> || last.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> root=last.<span class="built_in">back</span>();<span class="comment">//后序遍历的根节点</span></span><br><span class="line">    last.<span class="built_in">pop_back</span>();      <span class="comment">//删除last的根节点</span></span><br><span class="line">    <span class="keyword">auto</span> root_it=mid.<span class="built_in">find</span>(root);</span><br><span class="line">    <span class="comment">//中序的left部分和right部分</span></span><br><span class="line">    string center_left=mid.<span class="built_in">substr</span>(<span class="number">0</span>,root_it);</span><br><span class="line">    string center_right=mid.<span class="built_in">substr</span>(root_it+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//后序的left部分和right部分</span></span><br><span class="line">    string last_left=last.<span class="built_in">substr</span>(<span class="number">0</span>,root_it);</span><br><span class="line">    string last_right=last.<span class="built_in">substr</span>(root_it);</span><br><span class="line">    <span class="comment">//前序形式输出：根左右</span></span><br><span class="line">    cout&lt;&lt;root;<span class="comment">//根</span></span><br><span class="line">    <span class="built_in">dfs2</span>(center_left,last_left);<span class="comment">//左</span></span><br><span class="line">    <span class="built_in">dfs2</span>(center_right,last_right);<span class="comment">//右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1229-前序和后序，求出所有中序的次数"><a href="#P1229-前序和后序，求出所有中序的次数" class="headerlink" title="P1229 前序和后序，求出所有中序的次数"></a>P1229 前序和后序，求出所有中序的次数</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEyMjk=">P1229 遍历问题<i class="fa fa-external-link-alt"></i></span></p>
<p>前面我们说过：<strong>由前序遍历和后序遍历无法确定一个唯一的中序遍历</strong></p>
<p>这道题就是让我们求中序遍历的所有可能的数量</p>
<p>假如<strong>一个节点A只有一个孩子节点B</strong>，则思考一下：<strong>无论B是A的左孩子还是右孩子，它的前序遍历和后序遍历都是一致的。</strong></p>
<p>因此如果要找到不同的中序遍历的情况，则一定是存在上述的情况。</p>
<p><strong>A的孩子节点B只存在一个，这样就能确定两种情况；</strong></p>
<p><strong>如果A也是它的父亲节点 X 的唯一的孩子，那么A的左右改变又可以确定两种情况，加上A自己的，一共有四种情况。</strong> </p>
<ul>
<li>一颗树存在两个单孩子节点，则这棵树就具有四种中序，即<strong>具有 2^ n个 中序的情况，n表示单孩子节点的个数</strong></li>
</ul>
<p>如何确定一个<strong>单孩子节点</strong>？</p>
<p>前序遍历：ABC</p>
<p>后序遍历：CBA</p>
<p>假设它是一个<strong>一条直线，左斜的形状</strong></p>
<ul>
<li>则A的孩子节点B在前序中呈：AB，在后序中呈：BA</li>
<li>则B的孩子节点C在前序中呈：BC，在后序中呈：CB</li>
</ul>
<p>则仅需判断在<strong>中序遍历中A的后继是B</strong>，如果在<strong>后序遍历中A的前驱是B</strong>，则说明为一个情况，n++</p>
<p>最后 2^n即为中序的所有次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string q,h;</span><br><span class="line">    cin&gt;&gt;q&gt;&gt;h;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;q.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;h.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="comment">//q[i]==h[j] &amp;&amp; q[i+1]==h[j-1] </span></span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;q.<span class="built_in">length</span>() &amp;&amp; j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; q[i]==h[j] &amp;&amp; q[i+<span class="number">1</span>]==h[j<span class="number">-1</span>])&#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(<span class="number">1</span>&lt;&lt;ans);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1364-医院设置"><a href="#P1364-医院设置" class="headerlink" title="P1364 医院设置"></a>P1364 医院设置</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEzNjQ=">P1364 医院设置<i class="fa fa-external-link-alt"></i></span></p>
<p>这道题的是一个典型的求段路径问题。</p>
<p>要使得在一个节点处建立医院，使得其他节点到这个节点的最短路径最小，不就是求最短路径？</p>
<p>每两个节点的距离是1，因此<strong>求出这个最短距离后再乘以节点本身的值然后相加即可</strong></p>
<p>最短路径的求法： floyd算法，dijkstra算法，spfa算法；</p>
<p>这里附上floyd算法：floyd使用三重循环，<strong>求得任何两个点的最短路径</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N],dp[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> b,c;</span><br><span class="line">        cin&gt;&gt;nums[i]&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="comment">//两点之间距离的初始化</span></span><br><span class="line">        dp[i][b]=dp[i][c]=dp[b][i]=dp[c][i]=<span class="number">1</span>;</span><br><span class="line">        dp[b][b]=dp[i][i]=dp[c][c]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算两点之间的最短路径</span></span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="type">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> ones=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//以顶点 i 为起点，到某一点的最小距离和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            ones+=dp[i][j]*nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,ones);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h1 id="P1305-新二叉树"><a href="#P1305-新二叉树" class="headerlink" title="* P1305 新二叉树"></a>* P1305 新二叉树</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEzMDU=">P1305 新二叉树<i class="fa fa-external-link-alt"></i></span></p>
<p>这道题的关键是选择合适的数据结构<strong>来存储这棵树</strong>，输出树的<strong>前序遍历很简单</strong></p>
<p>如果选择<strong>合适的数据结构</strong>？</p>
<ul>
<li>由于树的节点不会有重复的，n&lt;=26，则我们使用ASCII码来表示下标，因为<strong>ASCII码也是唯一</strong>的 ，而且很小，我们可以<strong>借助ASCII码当作数组的下标来轻松访问其相应的左右孩子节点</strong>，使用结构体存储left与right孩子，pair也行。</li>
</ul>
<h2 id="1-Ascii码用作数组的下标"><a href="#1-Ascii码用作数组的下标" class="headerlink" title="1. Ascii码用作数组的下标"></a>1. Ascii码用作数组的下标</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> left,right;</span><br><span class="line">&#125;tree[N];</span><br><span class="line"><span class="type">char</span> cur,root;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">char</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;i;</span><br><span class="line">    <span class="built_in">dfs</span>(tree[i].left);</span><br><span class="line">    <span class="built_in">dfs</span>(tree[i].right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    string in;</span><br><span class="line">    <span class="comment">//便于在dfs时确定root的位置</span></span><br><span class="line">    cin&gt;&gt;root;</span><br><span class="line">    cin&gt;&gt;tree[root].left&gt;&gt;tree[root].right;</span><br><span class="line">    <span class="comment">//正常遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;cur;</span><br><span class="line">        cin&gt;&gt;tree[cur].left&gt;&gt;tree[cur].right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-寻找根节点"><a href="#2-寻找根节点" class="headerlink" title="2. 寻找根节点"></a>2. 寻找根节点</h2><p>方法二：</p>
<ul>
<li>使用一个 <strong>n维3列</strong>的<strong>char数组</strong>来表示这棵树，[0]表示根节点的字符，[1] [2]分别表示左右孩子；我们便可以每次dfs的时候，<strong>直接寻找每一层的所有节点，如果这个节点的父亲为当前的root，则进入此节点的递归。</strong></li>
</ul>
<p>为什么遍历每一层寻找父亲节点等于root的节点就是当前需要dfs的节点？</p>
<ul>
<li>因为是<strong>前序遍历</strong>，<strong>根在前，所有当前层的所有节点都是一个根</strong>，即从根开始dfs</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="type">char</span> arr[<span class="number">50</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">char</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i][<span class="number">0</span>]==root)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(arr[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">dfs</span>(arr[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    string in;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i][<span class="number">0</span>]&gt;&gt;arr[i][<span class="number">1</span>]&gt;&gt;arr[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(arr[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P3884-求二叉树深度，宽度，uv距离"><a href="#P3884-求二叉树深度，宽度，uv距离" class="headerlink" title="* P3884 求二叉树深度，宽度，uv距离"></a>* P3884 求二叉树深度，宽度，uv距离</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4ODQ=">P3884 [JLOI2009]二叉树问题<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>深度如何求？</strong></p>
<ul>
<li>dfs遍历树，然后记录一个cnt，更新最大深度 deep_max？可以，<strong>但是没有必要</strong></li>
</ul>
<p><strong>宽度如何求？</strong></p>
<ul>
<li>使用bfs层序遍历，维护一个queue，然后记录每一层的queue的元素数量（left入，right入），queue存储的就是每一层的元素个数就是宽度，然后不断的循环，直到queue为0，则遍历完成，kuan_max每次取得 queue.size()与它的最大值? <strong>没有必要</strong></li>
</ul>
<p><strong>两个节点之间的距离？</strong></p>
<ul>
<li>最短路径，三种随便选择一个即可，我选择 <strong>floyd</strong></li>
</ul>
<p><strong>如果我们知道了 这个最短距离不就知道了 宽度与深度了吗</strong>，那我们就没有必要写两个算法求了。</p>
<p>深度如何知道？</p>
<ul>
<li>根节点 1 到任意一点的<strong>最短距离的长度的最大值</strong>，就是<strong>深度的最大值</strong>（两个节点之间dis=1）</li>
</ul>
<p>宽度如何知道？</p>
<ul>
<li>根节点到 两个点 i j 的最短距离都是 n，则这 i j 属于同一层，<strong>属于同一层的最短距离一定相同</strong>，记录每一层的最短距离相同的元素的数量即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N],dp[N][N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        dp[a][b]=<span class="number">1</span>; <span class="comment">//父亲到孩子的距离是1</span></span><br><span class="line">        dp[b][a]=<span class="number">2</span>; <span class="comment">//孩子到父亲的距离是2</span></span><br><span class="line">        dp[a][a]=dp[b][b]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> deep=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//深度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        deep=<span class="built_in">max</span>(deep,dp[<span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//宽度</span></span><br><span class="line">    <span class="type">int</span> kuan[N]&#123;&#125;;</span><br><span class="line">    <span class="type">int</span> kuan_dis=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ++kuan[dp[<span class="number">1</span>][i]];<span class="comment">//每一层到根节点的距离都是一样的</span></span><br><span class="line">        kuan_dis=<span class="built_in">max</span>(kuan_dis,kuan[dp[<span class="number">1</span>][i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">    cout&lt;&lt;deep+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;kuan_dis&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//uv之间的距离</span></span><br><span class="line">    cout&lt;&lt;dp[u][v]&lt;&lt;endl; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题训练</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码学习（4）- list</title>
    <url>/2023/03/12/STL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%884%EF%BC%89-%20list/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="1-list的节点"><a href="#1-list的节点" class="headerlink" title="1. list的节点"></a>1. list的节点</h1><p>众所周知list是链表，因此它一定需要一个<strong>节点类型</strong>，以下是SGI STL list的节点类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list的节点类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">listNode</span></span><br><span class="line">&#123;</span><br><span class="line">	listNode&lt;T&gt;* next;</span><br><span class="line">	listNode&lt;T&gt;* prev;</span><br><span class="line">	T	data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="2-list的迭代器"><a href="#2-list的迭代器" class="headerlink" title="2. list的迭代器"></a>2. list的迭代器</h1><p>由于list不像vector一样所有的节点都存储在一块连续的空间中，相反<strong>list的节点存储是不连续的</strong>。</p>
<p>因此list的迭代器应该具有正确的递增，递减，取值，成员取用的操作。</p>
<ol>
<li>递增：正确的找到其next的地址</li>
<li>递减：正确的找到其prev的地址</li>
<li>取值：当前节点的取值</li>
<li>成员取用：当前节点的成员</li>
</ol>
<p>因此list的迭代器必须具有<strong>双向移动</strong>的功能，他必须是一个 <strong>Bidirectional Iterator</strong>，即<strong>双向迭代器</strong>。</p>
<p><strong>list在插入与删除的时候，原迭代器仍然有效，只有被删除或者执行操作的迭代器才有可能失效；而vector由于需要重新配置空间，因此原迭代器全部无效</strong></p>
<p>实现过程：</p>
<ol>
<li><p>定义迭代器基本数据类型：value_type，differece_type，pointer，reference，iterator_category等，同时定义节点类型，并且创建一个<strong>根节点</strong>。</p>
</li>
<li><p>list的构造函数，其中注意<strong>const iterator&amp;参数的构造函数</strong>，我们可能需要执行这样的操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; ls;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">it</span><span class="params">(ls.begin())</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中it的调用的就是list_iterator的此构造函数。</p>
</li>
<li><p>list的迭代器的基本操作：</p>
<ol>
<li>== 与 != 的操作</li>
<li>* 运算获取的是<strong>某个迭代器的data值</strong></li>
<li>-&gt; 运算获取的是<strong>某个迭代器的data值的地址</strong>，这个不怎么常用。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ls.<span class="built_in">begin</span>().<span class="keyword">operator</span>-&gt;()</span><br></pre></td></tr></table></figure>
<ol>
<li>++操作：前置++，直接相加，返回<strong>引用</strong>；后置++，返回的是一个临时的，因此<strong>不能是引用</strong></li>
<li>—操作：前置—，直接相减，返回<strong>引用</strong>；后置—，返回的是一个临时的，因此<strong>不能是引用</strong></li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list的迭代器类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Ref,<span class="keyword">typename</span> Ptr&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list_iterator</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> iterator = list_iterator&lt;T, T&amp;, T*&gt;;<span class="comment">//iterator作为对外接口</span></span><br><span class="line">	<span class="keyword">using</span> self = list_iterator&lt;T, Ref, Ptr&gt;;<span class="comment">//用于返回值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> value_type = T;</span><br><span class="line">	<span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">	<span class="keyword">using</span> pointer = Ptr;</span><br><span class="line">	<span class="keyword">using</span> reference = Ref;</span><br><span class="line">	<span class="keyword">using</span> iterator_category = Bibirectional_Iterator_tag;<span class="comment">//双向</span></span><br><span class="line">	<span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line">	<span class="keyword">using</span> link_type = listNode&lt;T&gt;*;	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	link_type node; <span class="comment">//list节点</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">list_iterator</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">list_iterator</span>(link_type x) :<span class="built_in">node</span>(x) &#123;&#125;</span><br><span class="line">	<span class="built_in">list_iterator</span>(<span class="type">const</span> iterator&amp; x) :<span class="built_in">node</span>(x.node) &#123;&#125;</span><br><span class="line">	~<span class="built_in">list_iterator</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; lhs) &#123;</span><br><span class="line">		<span class="keyword">return</span> lhs.node == node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; lhs) &#123;</span><br><span class="line">		<span class="keyword">return</span> lhs.node != node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//*运算，获取节点的值</span></span><br><span class="line">	reference <span class="keyword">operator</span>*() &#123;</span><br><span class="line">		<span class="keyword">return</span> node-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//-&gt;运算，获取节点的值的地址</span></span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;()<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;(node-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置++</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		node = node-&gt;next;<span class="comment">//前进到下一个</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后置++</span></span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">		<span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</span><br><span class="line">		++* <span class="keyword">this</span>;</span><br><span class="line">		<span class="comment">//返回一个临时temp，因此不能使用引用</span></span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置--</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">		node = node-&gt;prev;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后置--</span></span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">		<span class="keyword">auto</span> temp = *<span class="keyword">this</span>;</span><br><span class="line">		--* <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="3-list的数据结构"><a href="#3-list的数据结构" class="headerlink" title="3. list的数据结构"></a>3. list的数据结构</h1><p>list是一个<strong>双向循环链表</strong>，所以它只需要<strong>一个指针</strong>，便可以遍历整个链表并且回到原来的位置。</p>
<p>为此我们可以设计一个<strong>头节点</strong>为list的起始节点，这个头节点不含任何数据，它只是作为一个空的节点而已，方便我们进行遍历与基本判断操作：</p>
<ol>
<li><p><strong>当我们进行begin()的时候：直接返回 head-&gt;next即可；同理我们的 end()表示的才是 head</strong></p>
</li>
<li><p>调用size() 统计节点的数量，其实就是两个迭代器之间的 距离，这个函数可以自己<strong>遍历</strong>，也可以调用我们之前完成的<strong>distance函数</strong>，这个函数的作用就是 <strong>计算两个迭代器之间的距离，然后根据迭代器的 category会做一些优化</strong></p>
</li>
<li>front表示返回头元素节点数据，因此对 <strong>begin()进行解引用操作</strong>即可。<strong>在begin操作结束后，返回的list的迭代器类型（使用 iterator做别名），然后我们已经在list的迭代器的内部定义了解引用的操作，因此会返回该节点（就是头节点的值）</strong>；end同理，不过要注意end表示一个空节点，<strong>end的上一个才是真正的尾元素</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> list</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> list_node =  listNode&lt;T&gt;;</span><br><span class="line">	<span class="keyword">using</span> data_allocator = simplae_alloc&lt;list_node, Alloc&gt;;<span class="comment">//空间配置器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> link_type = list_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//list的相应型别</span></span><br><span class="line">	<span class="keyword">using</span> value_type = Alloc;</span><br><span class="line">	<span class="keyword">using</span> reference = value_type&amp;;</span><br><span class="line">	<span class="keyword">using</span> const_reference = <span class="type">const</span> value_type&amp;;</span><br><span class="line">	<span class="keyword">using</span> pointer = value_type*;</span><br><span class="line">	<span class="keyword">using</span> const_pointer = <span class="type">const</span> value_type*;</span><br><span class="line">	<span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">	<span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//iterator表示的就是list的迭代器</span></span><br><span class="line">	<span class="keyword">using</span> iterator = list_iterator&lt;value_type, reference, pointer&gt;;</span><br><span class="line">    <span class="comment">//const 迭代器</span></span><br><span class="line">	<span class="keyword">using</span> const_iterator = list_iterator&lt;value_type, const_reference, const_pointer&gt;;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	list_node head;<span class="comment">//私有属性：节点的头节点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> const_iterator <span class="title">cbegin</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head;<span class="comment">//头节点不存储任何数据，它就是end节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> const_iterator <span class="title">cend</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head == head-&gt;next;<span class="comment">//自己和自己连接，则list为空</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> size_type <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (size_type)<span class="built_in">distance</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());<span class="comment">//计算两个迭代器之间的距离</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//引用方式返回</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> reference <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="built_in">begin</span>();<span class="comment">//head-&gt;next-&gt;data</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *(--<span class="built_in">end</span>());<span class="comment">//list没有 - + 重载</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="4-list的构造元素操作"><a href="#4-list的构造元素操作" class="headerlink" title="4. list的构造元素操作"></a>4. list的构造元素操作</h1><h2 id="4-1-list的空间配置操作"><a href="#4-1-list的空间配置操作" class="headerlink" title="4.1 list的空间配置操作"></a>4.1 list的空间配置操作</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> data_allocator = simplae_alloc&lt;list_node, Alloc&gt;;<span class="comment">//空间配置器</span></span><br></pre></td></tr></table></figure>
<p>list使用第二级空间配置器作为其空间配置器。</p>
<p>list是由一个个的节点连接的，因此我们需要有一个函数来<strong>创建一个节点的空间</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">link_type <span class="title">create_node_space</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (link_type)data_allocator::<span class="built_in">allocate</span>();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>对应的销毁某个<strong>节点的空间</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy_node_space</span><span class="params">(link_type pDel)</span> </span>&#123;</span><br><span class="line">		data_allocator::<span class="built_in">deallocate</span>(pDel);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>然后才是创建一个节点对象的行为（<strong>创建空间与构造对象</strong>）：</p>
<p><strong>如果中途构造对象的失败了，则rallback，销毁这个节点的空间</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; val)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//commit or rallback规则</span></span><br><span class="line">		link_type* pNew = <span class="built_in">create_node_space</span>();<span class="comment">//分配空间</span></span><br><span class="line">		_TRY&#123;</span><br><span class="line">			<span class="built_in">construct</span>(&amp;pNew-&gt;data, val);<span class="comment">//构造对象</span></span><br><span class="line">		&#125;</span><br><span class="line">		_CATCH(...)&#123;</span><br><span class="line">			<span class="built_in">destroy_node_space</span>(pNew);<span class="comment">//否则销毁空间</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pNew;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>然后是销毁这个<strong>节点对象</strong>（<strong>析构对象与销毁空间</strong>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type pDel)</span> </span>&#123;</span><br><span class="line">		::<span class="built_in">destroy</span>(&amp;pDel-&gt;data);</span><br><span class="line">		<span class="built_in">destroy_node_space</span>(pDel);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-list的空构造函数"><a href="#4-2-list的空构造函数" class="headerlink" title="4.2 list的空构造函数"></a>4.2 list的空构造函数</h2><p>list 有很多构造函数，其中一个可以让我们<strong>配置</strong>一个空的节点对象：</p>
<p><strong>注意是配置而不是创建，理解其不同：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>() &#123;</span><br><span class="line">		<span class="built_in">empty_initialized</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//头节点的配置：创建一个空的list</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">empty_initialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		head = <span class="built_in">create_node_space</span>();</span><br><span class="line">		head-&gt;next = head;</span><br><span class="line">		head-&gt;prev = head;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>相当于完成了list的<strong>初始化</strong>，只有一个空节点，自己指向自己。</p>
<h2 id="4-3-list的push-back"><a href="#4-3-list的push-back" class="headerlink" title="4.3 list的push_back"></a>4.3 list的push_back</h2><p>list的尾插其实就是完成了往某个位置插入一个元素的操作，<strong>只不过这个位置是 在 end的地方</strong></p>
<p><strong>因此我们首先写一个往某个位置创建节点并且插入的操作即可。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//position位置创建并且插入一个节点，返回插入完成后的新的插入位置</span></span><br><span class="line">	link_type _insert(iterator position, <span class="type">const</span> value_type&amp; value) &#123;</span><br><span class="line">		link_type pNew = <span class="built_in">create_node</span>(value);<span class="comment">//创建节点</span></span><br><span class="line">		<span class="comment">//中间插入</span></span><br><span class="line">		pNew-&gt;next = position.node;</span><br><span class="line">		pNew-&gt;prev = position.node-&gt;prev;</span><br><span class="line">		position.node-&gt;prev-&gt;next = pNew;</span><br><span class="line">		position.node-&gt;prev = pNew;</span><br><span class="line">		<span class="keyword">return</span> pNew;<span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> value_type&amp; value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//其实就是在end的位置插入</span></span><br><span class="line">		_insert(<span class="built_in">end</span>(), value);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>end()不是返回 head头节点吗， 为什么是尾插？ </li>
</ul>
<p>list是循环链表，因此<strong>第一个也就是最后一个</strong>，只要在 <strong>head 的前面就是尾部节点，head节点开始才是头部。</strong></p>
<h1 id="5-list的基本元素操作"><a href="#5-list的基本元素操作" class="headerlink" title="5. list的基本元素操作"></a>5. list的基本元素操作</h1><h2 id="5-1-其他插入与删除"><a href="#5-1-其他插入与删除" class="headerlink" title="5.1 其他插入与删除"></a>5.1 其他插入与删除</h2><p>头插法：push_front 与 push_back类似，从begin()处插入即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value_type&amp; value)</span> </span>&#123;</span><br><span class="line">    _insert(<span class="built_in">begin</span>(), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>erase删除某个位置的节点</strong>：</p>
<p>直接找到其前驱节点与后继节点跳过pDel节点就可以。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除position处的节点，返回删除后的当前位置的节点</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">    link_type pDel = position.node;</span><br><span class="line">    link_type pDelNext = pDel-&gt;next;</span><br><span class="line">    link_type pDelPrev = pDel-&gt;prev;</span><br><span class="line">    pDelPrev-&gt;next = pDelNext;</span><br><span class="line">    pDelNext-&gt;prev = pDelPrev;</span><br><span class="line">    <span class="built_in">destroy_node</span>(pDel);<span class="comment">//销毁pDel节点</span></span><br><span class="line">    <span class="keyword">return</span> pDelNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pop_back与pop_front函数，利用erase，非常简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除尾节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">erase</span>(--<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>清空链表：</strong>clear</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    link_type cur = <span class="built_in">begin</span>().node, temp = <span class="literal">nullptr</span>;</span><br><span class="line">    link_type end = head;<span class="comment">//尾节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur != end) &#123;</span><br><span class="line">        temp = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="built_in">destroy_node</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//恢复空list状态</span></span><br><span class="line">    cur-&gt;next = cur;</span><br><span class="line">    cur-&gt;prev = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-2-remove"><a href="#5-2-remove" class="headerlink" title="5.2 remove"></a>5.2 remove</h2><p>remove的作用是移除所有等于<strong>val</strong>的值的节点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除所有值为value的元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> value_type&amp; value)</span> </span>&#123;</span><br><span class="line">    iterator cur = <span class="built_in">begin</span>(), temp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="built_in">end</span>()) &#123;</span><br><span class="line">        temp = cur.node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cur.node-&gt;data == value) &#123;</span><br><span class="line">            <span class="built_in">erase</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-unique"><a href="#5-3-unique" class="headerlink" title="5.3 unique"></a>5.3 unique</h2><p>unique的作用是移除所有连续且相等data的元素节点，只留下一个。</p>
<p>过程：<strong>next负责前进，first负责保留每个元素的第一个，last表示尾</strong></p>
<ol>
<li>每次next移动到下一个位置，first此时在next的上一个位置，则比较这两个位置的值是否一样</li>
<li>如果一样，则需要<strong>保留first，erase掉next</strong>，所以直接erase(next)，然后还需要检查后面是否还有一样的元素，<strong>因此next=first，回来继续往后++</strong>，重复上面的操作，每次只删除 next 的位置，而不会删除first</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//移除连续且相同元素的节点，只剩下一个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unique</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    iterator first = <span class="built_in">begin</span>(), last = <span class="built_in">end</span>();</span><br><span class="line">    iterator next = first;</span><br><span class="line">    <span class="keyword">while</span> (++next != last) &#123;</span><br><span class="line">        <span class="comment">//first始终指向某个元素的第一个位置</span></span><br><span class="line">        <span class="comment">//变动删除next达到只剩下一个first</span></span><br><span class="line">        <span class="keyword">if</span> (*first == *next) &#123;</span><br><span class="line">            <span class="built_in">erase</span>(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            first = next;<span class="comment">//first往后移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        next = first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-transfrom"><a href="#5-4-transfrom" class="headerlink" title="5.4 transfrom*"></a>5.4 transfrom*</h2><p>transfrom是一个内部函数，用于将 <strong>[first，last)的全部节点转移到position之前</strong>：</p>
<p>其实就是<strong>几个指针的连接</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将[first,last) 的全部元素移动到 position之前</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">(iterator first, iterator last, iterator position)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//[first,end]</span></span><br><span class="line">    <span class="keyword">if</span> (position != last) &#123;</span><br><span class="line">        iterator end = last.node-&gt;prev;<span class="comment">//需要移动的最后一个元素</span></span><br><span class="line">        iterator pos_prev = position.node-&gt;prev;</span><br><span class="line">        iterator first_prev = first.node-&gt;prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//next连接</span></span><br><span class="line">        end.node-&gt;next = position.node;</span><br><span class="line">        first_prev.node-&gt;next = last.node;</span><br><span class="line">        pos_prev.node-&gt;next = first.node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//prev连接</span></span><br><span class="line">        position.node-&gt;prev = last.node-&gt;prev;</span><br><span class="line">        last.node-&gt;prev = first.node-&gt;prev;</span><br><span class="line">        first.node-&gt;prev = pos_prev.node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-5-splice"><a href="#5-5-splice" class="headerlink" title="5.5 splice"></a>5.5 splice</h2><p>基于transfrom我们便可以写出splice，此函数的功能是 将一个范围的迭代器所指的节点连接到position处：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将ls接在position之前，ls必须不同于*this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp; ls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ls.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">transform</span>(ls.<span class="built_in">begin</span>(), ls.<span class="built_in">end</span>(), position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将某一个迭代器接在position之前,position和it属于同一个list</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position,iterator it)</span> </span>&#123;</span><br><span class="line">    iterator it_ = it;</span><br><span class="line">    ++it_;	<span class="comment">//last</span></span><br><span class="line">    <span class="keyword">if</span> (it == position || it_ == position) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">transform</span>(it, it_, position);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将 [first,last)所有元素接在position之前</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, iterator first,iterator last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">        <span class="built_in">transform</span>(first, last, position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：由于在transform中来自不同list的迭代器是把他们连接到新的position，而不是 new出一块内存，因此原始的移动的 [first，last)中的节点会消失，我们通常使用 splice来移动节点，而不是拷贝</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ls.<span class="built_in">splice</span>(cur, temp); <span class="comment">//将整个temp的list都移动到cur的位置，因此temp 会消失！</span></span><br></pre></td></tr></table></figure>
<h2 id="5-6-merge"><a href="#5-6-merge" class="headerlink" title="5.6 merge"></a>5.6 merge</h2><p>将某个链表合并到 <em>this中，两个链表必须是有序的，<em>*二路归并</em></em>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将ls的list合并到*this中，ls会消失，两个list必须有序！</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(list&amp; ls)</span> </span>&#123;</span><br><span class="line">    iterator first1 = <span class="built_in">begin</span>();</span><br><span class="line">    iterator first2 = ls.<span class="built_in">begin</span>();</span><br><span class="line">    iterator end1 = <span class="built_in">end</span>();</span><br><span class="line">    iterator end2 = ls.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//合并到 first</span></span><br><span class="line">    <span class="keyword">while</span> (first1 != end1 &amp;&amp; first2 != end2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*first1 &gt; *first2) &#123;</span><br><span class="line">            iterator temp = first2;</span><br><span class="line">            <span class="built_in">transform</span>(first2, ++temp, first1);</span><br><span class="line">            first2 = temp;<span class="comment">//移动到下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ++first1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//待合并的ls还有，则全部放后面</span></span><br><span class="line">    <span class="keyword">if</span> (first2 != end2) &#123;</span><br><span class="line">        <span class="built_in">transform</span>(first2, end2, end1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-7-reverse"><a href="#5-7-reverse" class="headerlink" title="5.7 reverse"></a>5.7 reverse</h2><p>翻转整个链表：<strong>把每一个元素直接移动到begin()的前面即可。</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//翻转链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果NULL或者只有1个，则不执行</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == head || head-&gt;next-&gt;next == head) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator first = <span class="built_in">begin</span>(),last=<span class="built_in">end</span>();</span><br><span class="line">    ++first;<span class="comment">//跳过head</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = first;</span><br><span class="line">        <span class="built_in">transform</span>(temp,++first, <span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-8-Sort"><a href="#5-8-Sort" class="headerlink" title="5.8 Sort*"></a>5.8 Sort*</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head-&gt;next == head || head-&gt;next-&gt;next == head) <span class="keyword">return</span>;</span><br><span class="line">		list&lt;T, Alloc&gt; carry;<span class="comment">//每一归并层之间合并的 “中转站”</span></span><br><span class="line">		list&lt;T, Alloc&gt; counter[<span class="number">64</span>]; <span class="comment">// counter[i]表示第i层《归并层》</span></span><br><span class="line">		<span class="type">int</span> fill = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!<span class="built_in">empty</span>()) &#123;<span class="comment">//一直输入元素</span></span><br><span class="line">			carry.<span class="built_in">splice</span>(carry.<span class="built_in">begin</span>(), *<span class="keyword">this</span>, <span class="built_in">begin</span>());<span class="comment">//每次carry首先获取新插入的元素</span></span><br><span class="line">			<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			每一层从 0-&gt;i 归并层进行逐一合并</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">while</span> (i &lt; fill &amp;&amp; !counter[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				counter[i].<span class="built_in">merge</span>(carry);		<span class="comment">//首先把carry 合并到 counter[i]层</span></span><br><span class="line">				carry.<span class="built_in">swap</span>(counter[i++]);	<span class="comment">//交由carry临时存储此层归并后的结果</span></span><br><span class="line">			&#125;</span><br><span class="line">			carry.<span class="built_in">swap</span>(counter[i]); <span class="comment">//将当前处理的结果给到 counnter[i] 层</span></span><br><span class="line">			<span class="keyword">if</span> (i == fill) &#123;	<span class="comment">//归并层扩容</span></span><br><span class="line">				++fill;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; fill; ++i) &#123;</span><br><span class="line">			counter[i].<span class="built_in">merge</span>(counter[i - <span class="number">1</span>]); <span class="comment">//层层归并</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(counter[fill - <span class="number">1</span>]);<span class="comment">//最后一层就是答案</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>原数据：14 13 8 7 6 5 2 1 0</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>第一次循环</th>
<th>counter[0]</th>
<th>counter[1]</th>
<th>counter[2]</th>
<th>counter[3]</th>
</tr>
</thead>
<tbody>
<tr>
<td>14</td>
<td>14</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>13</td>
<td></td>
<td>13,14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>8</td>
<td>13,14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
<td>7,8,13,14</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td></td>
<td>7,8,13,14</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>5,6</td>
<td>7,8,13,14</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>5,6</td>
<td>7,8,13,14</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td>1,2,5,6,7,8,13,14</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td>1,2,5,6,7,8,13,14</td>
</tr>
</tbody>
</table>
</div>
<p>最终再归并起来： 0,1,2,5,6,7,8,13,14</p>
<p>有几个关键函数：</p>
<ol>
<li><strong>splice：把某个迭代器移到position的位置处。</strong></li>
<li><strong>merge：合并到*this成为一个有序非递减链表</strong></li>
<li><strong>swap：交换两个list容器的所有节点值。</strong></li>
</ol>
<p>排序过程如下：</p>
<ol>
<li>首先传入 14：splice把14插入到carry，此时fill为0，不进入内层循环。swap把count和counter[0]容器交换，此时 counter[0]：14；carry是空的，fill 递增为 1</li>
<li>传入13：splice把13插入到carry中，此时fill为1，并且counter[0]不为空，进入内层循环，首先couter[0]与carry合并，合并后结果放到counter[0]中，carry变为空。然后把counter[0]与carry交换，之后counter[0]为空，carry：13，14。跳出循环后counter[1]与carry交换，counter[1]：13，14，carry变为空。</li>
<li>….</li>
<li>一直到传入0：splice把0插入到carry中，此时fill为4，由于counter[0]为空，因此不会进入内层循环。counter[0] 与carry交换，counter[0]：0，carry为空。</li>
<li>然后 <em>this的empty触发，跳出大循环，从 i=1开始一直到fill-1 <em>*闭区间</em></em>：<ol>
<li>counter[1]与 counter[0] 合并，结果存入counter[1]</li>
<li>counter[2]与 counter[1] 合并，结果存入counter[2]</li>
<li>counter[3]与 counter[2] 合并，结果存入counter[3]</li>
</ol>
</li>
<li>最后counter[fill-1]  为counter[3]里面存储的节点的值，因此结果为0，1，2，5，6，7，8，13，14</li>
</ol>
<hr>
<p>综上：</p>
<ul>
<li><p>可以看出这基本是一个归并排序，并且这还是个<strong>非递归版本的归并排序</strong>。</p>
</li>
<li><p>list的sort排序利用carry存储<strong>每次新插入的值</strong>或者<strong>当作每次counter[i]与counter[i-1]合并的时候的中转站</strong></p>
</li>
<li><p>counter数组存储<strong>每一层归并的排序结果</strong>，最后<strong>所有的  counter[0] 到counter [fill-1]一起<em>自底向上</em>一路归并过来，最后的 counter[fill-1]存储的就是归并后的整个数组的sort排序结果</strong></p>
</li>
<li><p><strong>按层次归并，层层合并，最后一起合并，这就是list的sort排序思想。</strong></p>
</li>
<li><p>counter的 数组下标表示 counter[0] 这一层只能容纳一个元素；counter[1]可以容纳两个元素；counter[2]可以容纳四个元素；counter[3]可以容纳八个元素；因此counter[i]可以容纳 2^i 个元素。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>STL源码剖析</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码学习（3）- vector</title>
    <url>/2023/03/10/STL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89-%20vector/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="1-vector的迭代器"><a href="#1-vector的迭代器" class="headerlink" title="1. vector的迭代器"></a>1. vector的迭代器</h1><p>vector维护的是一个连续线性空间。所以无论元素的类型是什么，<strong>普通指针</strong>都可以满足条件而作为vector的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> value_type = T;</span><br><span class="line">	<span class="keyword">using</span> iterator = value_type*;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基于此，vector就可以写出这样的操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator	<span class="comment">//int*</span></span><br><span class="line">vector&lt;<span class="type">char</span>&gt;::iterator  <span class="comment">//char*</span></span><br></pre></td></tr></table></figure>
<p>其实就是一个 int的指针  ，或者 char的指针。</p>
<h1 id="2-vector的数据类型"><a href="#2-vector的数据类型" class="headerlink" title="2. vector的数据类型"></a>2. vector的数据类型</h1><p>vector是一个简单的<strong>线性连续空间</strong>。</p>
<p>它以两个迭代器 start 和 finish 分别表示vector的起始元素的地址和终止元素的地址。</p>
<p>并且还具有一个 end_of_storage 表示vector开辟的空间的终止位置。</p>
<p>所以：</p>
<ul>
<li><strong>start - finish 表示的就是我们在连续空间中已经使用的范围。</strong></li>
<li><strong>start - end_of_storage 表示我们的总的空间大小。</strong></li>
<li><strong>finish - end_of_storage 表示我们还未使用过的空间总大小。</strong></li>
</ul>
<p>一个vector的容量一定大于等于其已分配元素的空间大小。</p>
<p>我们便可以得到关于<strong>空间大小</strong>的一系列函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> value_type = T;</span><br><span class="line">	<span class="keyword">using</span> iterator = value_type*;</span><br><span class="line">	<span class="keyword">using</span> pointer = value_type*;</span><br><span class="line">	<span class="keyword">using</span> reference = value_type&amp;;</span><br><span class="line">	<span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line">	<span class="keyword">using</span> difference_trpe = <span class="type">ptrdiff_t</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> size_type <span class="title">size</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;size_type&gt;(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> size_type <span class="title">capacity</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;size_type&gt;(end_of_storage - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line">	<span class="keyword">inline</span>  reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125;<span class="comment">//int a[1]=&#123;5&#125;; a[1]=5;</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;<span class="comment">//返回的是值</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finish;</span><br><span class="line">	iterator end_of_storage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意front和back取得的是 <strong>值</strong>，并且值以引用的方式返回的效率相对较优。</p>
<p>重载的[] 运算符取得是第 [i] 个位置的值，并且也是以<strong>引用</strong>的形式返回。</p>
<p>关于vector的内存配置的原理：</p>
<p><img src="https://tudingtu.cn/i/2023/03/09/nrwlhj.png" alt=""></p>
<h1 id="3-vetor的空间配置器"><a href="#3-vetor的空间配置器" class="headerlink" title="3. vetor的空间配置器"></a>3. vetor的空间配置器</h1><p>SGI STL容器中默认使用的空间配置器说<strong>第二级空间配置器</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//malloc_alloc 为第一级空间配置器</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br><span class="line"><span class="comment">//alloc默认为多线程第二级空间配置器</span></span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc;</span><br></pre></td></tr></table></figure>
<p>可以看到在vector的头部我们具有：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;<span class="comment">//Alloc：第二级空间配置器</span></span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// simple_alloc 空间配置器 -&gt;data_allocator</span></span><br><span class="line">  	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt;  data_allocator;  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以Alloc默认为第二级空间配置器，然后在simple_alloc中输入其<strong>元素类型和配置器属性</strong>，并且用 <strong>data_allocator作为vector的空间配置器别名</strong>。</p>
<p>simple_alloc 我们已经在第一章讲过了，<strong>他是一个封装了一二级配置器调用接口的抽象类</strong></p>
<h1 id="4-vector的构造函数"><a href="#4-vector的构造函数" class="headerlink" title="4. vector的构造函数"></a>4. vector的构造函数</h1><p>vector通过<strong>空间配置器</strong>来构造元素。</p>
<p>其中一个构造函数的方法：<strong>配置n个元素大小的空间，并且初始化为val值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector的其中一个构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="type">const</span> value_type&amp; val) &#123; <span class="built_in">fill_initialize</span>(n, val); &#125;<span class="comment">//n个元素为val值</span></span><br><span class="line"><span class="comment">//填充并且初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="type">const</span> value_type&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    start = <span class="built_in">allocate_and_fill</span>(n, val);<span class="comment">//起始地址</span></span><br><span class="line">    finish = <span class="built_in">begin</span>() + n;<span class="comment">//元素结束地址</span></span><br><span class="line">    end_of_storage = finish;<span class="comment">//总容量结束地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="type">const</span> value_type&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iterator res = data_allocator::<span class="built_in">allocate</span>(n);<span class="comment">//开辟n个元素的空间</span></span><br><span class="line">    <span class="built_in">uninitialized_fill_n</span>(res, n, val);<span class="comment">//res开始填充n个val</span></span><br><span class="line">    <span class="keyword">return</span> res;<span class="comment">//返回此空间的起始地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在vector中 <strong>fill_initialize</strong>用来调整空间的范围；</p>
<hr>
<p><strong>allocate_and_fill</strong> 用来开辟n个元素的空间然后填充进去val值</p>
<p>其中 allocate_and_fill 还要调用：</p>
<ol>
<li><strong>vector空间配置器的allocate 来开辟n个元素的空间。</strong></li>
<li><strong>uninitialized_fill_n 用来往指定空间填充val值</strong></li>
</ol>
<p>allocate_and_fill的函数内部 首先使用vector的空间配置器<strong>data_allocator</strong>(typename)来调用了addlocate，然后再根据，<strong>vector使用第二级空间配置器</strong>，因此转为 <strong>第二级空间配置器的 allocatoe的实现去</strong>。</p>
<p>data_allocator::allocate是在自由链表中取出一块合适的地址空间，因此其<strong>返回值表示分配的这块空间的起始地址</strong>，用res表示。</p>
<p><strong>uninitialized_fill_n</strong>接受第一个迭代器表示<strong>开始的地址</strong>，n个val值，在此函数中 会使用 <strong>__type_traits</strong> 的 类型推导机制，来推导出此迭代器所指元素的类型，并且选择适当的填充方法：</p>
<ol>
<li>_false_type：非POD类型，进行constructor构造</li>
<li>_true_type：POD类型，直接进行内存的操作 fill_n，memcpy，memmove等</li>
</ol>
<p><strong>以res为起点，填充n个地址单元的值为val</strong></p>
<hr>
<p>分配与填充元素成功后，再把此分配空间的起始地址返回，给到start，然后再调整 finish 和end_of_storage。</p>
<hr>
<h1 id="5-vector的销毁与析构"><a href="#5-vector的销毁与析构" class="headerlink" title="5. vector的销毁与析构"></a>5. vector的销毁与析构</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">vector</span>() &#123; </span><br><span class="line">    <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">    <span class="built_in">deallocate</span>();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start) data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage - start);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>析构分成两步：</p>
<ol>
<li><p>首先销毁所有元素，调用<strong>全局的destroy销毁函数</strong>，销毁start到finish的所有已经存在的元素。</p>
</li>
<li><p>然后调用deallocate函数<strong>析构所有对象</strong>。</p>
</li>
</ol>
<p>deallocate的函数实现：</p>
<p>直接对vector的空间配置器调用<strong>deallocate</strong> 即可，<strong>它接受一个start，表示析构的空间的开始地址，和一个需要析构的空间总大小</strong>。</p>
<p>deallocate的具体实现我们已经在第一章空间配置器里讲过了。</p>
<hr>
<h1 id="4-vector对元素的操作"><a href="#4-vector对元素的操作" class="headerlink" title="4. vector对元素的操作"></a>4. vector对元素的操作</h1><h2 id="4-1-pop-back"><a href="#4-1-pop-back" class="headerlink" title="4.1 pop_back"></a>4.1 pop_back</h2><p>弹出最后一个元素，代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//弹出最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123; finish--; <span class="built_in">destroy</span>(finish); &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="comment">//全局销毁函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(T* pointer)</span> </span>&#123;</span><br><span class="line">    pointer-&gt;~<span class="built_in">T</span>();      <span class="comment">// 单个对象的析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把指向元素末尾的 finish 直接减一即可，然后调用<strong>全局的destroy销毁销毁最后一个元素的空间</strong></p>
<h2 id="4-2-erase"><a href="#4-2-erase" class="headerlink" title="4.2 erase"></a>4.2 erase</h2><p>删除 [first,last) <strong>左闭右开的范围的元素</strong>，代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消除[first,last)中的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将[last,finish)中的元素全部拷贝到first处的位置</span></span><br><span class="line">    iterator end_pos = std::<span class="built_in">copy</span>(last, finish, first);</span><br><span class="line">    <span class="built_in">destroy</span>(end_pos, finish);<span class="comment">//清除[end_pos,finish)元素空间</span></span><br><span class="line">    finish = finish - (last-first);</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用copy函数，copy的作用是是将 [last,finish) 左闭右开范围的元素拷贝至 first 处。</p>
<p>这样就做到了将 <strong>last之外finish之前</strong>往前移，覆盖掉 [last,finish)范围内的元素。</p>
<p>同时std::copy函数（往后会讲解）完成后返回end_pos，代表从此处开始，<strong>往后的元素都是无用的</strong></p>
<p>直接调用<strong>全局的destroy函数</strong>删除此<strong>end_pos - finish</strong> 的元素即可。</p>
<p>最后调整finish为操作之后的finish，返回first。</p>
<p><img src="https://great.wzznft.com/i/2023/03/09/p9etyy.png" alt=""></p>
<p><strong>erase 一个位置的元素：</strong></p>
<p>首先要判断删除的元素是不是<strong>最后一个元素</strong>（它的下一个位置是 finish的位置）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消除position位置的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position + <span class="number">1</span> != <span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(position + <span class="number">1</span>, finish, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">destroy</span>(finish);<span class="comment">//随便销毁一个元素</span></span><br><span class="line">    finish -= <span class="number">1</span>;<span class="comment">//随便减少1个元素大小</span></span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>当position位置的元素是最后一个元素时：position+1 == end；此时直接销毁他即可，相当于<strong>直接销毁最后一个元素</strong></li>
<li>当position位置的元素不是最后一个元素时：<strong>需要把后面的元素覆盖过来</strong>，使用std::copy函数，把后面的位置元素往前覆盖，然后再<strong>销毁最后一个位置元素</strong>。</li>
</ol>
<h2 id="4-3-clear"><a href="#4-3-clear" class="headerlink" title="4.3. clear"></a>4.3. clear</h2><p>直接清除[begin,end) 的全部元素即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清除所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-insert"><a href="#4-4-insert" class="headerlink" title="4.4 insert*"></a>4.4 insert*</h2><p>vector具有一个比较复杂的insert的版本，接受三个参数：</p>
<ul>
<li>起始位置</li>
<li>插入元素个数</li>
<li>insert元素值</li>
</ul>
<p>在起始位置 position处，插入 n个 元素，每个元素初始化为 x值</p>
<p>分为三种情况：</p>
<ul>
<li>如果备用空间大于插入的元素个数：<strong>无需扩容</strong></li>
<li>如何小于插入元素个数，则需要扩容</li>
</ul>
<p><strong>把这个复杂的搞定了，其他的就很简单了。</strong></p>
<hr>
<p><strong>无需扩容的情况：并且到finish为止，现有的元素的数量（elem_after）大于等于 插入的元素数量 n</strong></p>
<ol>
<li>首先把<strong>绿色区域往后拷贝</strong>，使用 uninitialized_copy</li>
<li>然后把<strong>蓝色区域往后拷贝</strong>，使用 copy_backward 反向拷贝到 old_finish</li>
<li>最后在<strong>position位置拷贝进新的x元素</strong>，使用 fill填充即可</li>
</ol>
<p><img src="https://yimitool.com/i/2023/03/10/pr0wsd.png" alt=""></p>
<p><strong>无需扩容的情况：但是到finish为止，现有的元素的数量（elem_after）小于 插入的元素数量 n</strong></p>
<ol>
<li>直接把<strong>n 大于elem_after之后的部分</strong>拷贝到 finish之后，使用 uninitialized_fll_n</li>
<li>把<strong>position到finish之间原有的元素全部拷贝到finish之后</strong>，为图中蓝色区域，使用 uninitialized_copy</li>
<li>最后把剩余的n的一部分填充至 position到finish之间，使用 fill填充</li>
</ol>
<p><img src="https://yimitool.com/i/2023/03/10/7dd797g.png" alt=""></p>
<p><strong>需要扩容的情况：</strong></p>
<ol>
<li>剩余备用的元素无法存放进全部的 n 个元素，<strong>因此需要重新分配空间，并且销毁原空间。</strong></li>
<li>首先获得容纳这些全部元素<strong>至少需要多少空间</strong></li>
<li>调用第二级空间配置器的<strong>allocate重新分配空间。</strong><ol>
<li><strong>首先把start到position的全部元素拷贝到新的空间，使用 uninitialized_copy</strong></li>
<li><strong>然后把这n个元素拷贝到finish之后的空间，使用 uninitialized_fill_n（注意这是个插入的过程）</strong></li>
<li><strong>最后再把原来 position到 finish之间的元素全部拷贝到 finish之后，使用 uninitialized_copy</strong></li>
</ol>
</li>
<li>再把原来的空间全部销毁，调用全局的<strong>destory</strong>，然后再调用第二级空间配置器的<strong>deallocate</strong>（销毁的顺序是<strong>先destroy然后再析构</strong>）</li>
<li>最后调整新的 start finish end_storage</li>
</ol>
<p><img src="https://yimitool.com/i/2023/03/10/qm5olb.png" alt=""></p>
<p>注意：insert的过程中如果出现了内存不足的情况，就执行 <strong>commit or rallback</strong>的规则：</p>
<p><strong>如果失败则try抛出异常，执行 destroy与 deallocate 销毁全部已成功的元素的空间及对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position, size_type n, <span class="type">const</span> T&amp; x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size_type</span>(end_of_storage - finish) &gt;= n) &#123;<span class="comment">//剩余的空间足够容纳n个</span></span><br><span class="line">      T x_copy = x;<span class="comment">//需要赋予的值</span></span><br><span class="line">      <span class="type">const</span> size_type elems_after = finish - position;</span><br><span class="line">      iterator old_finish = finish;</span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; n) &#123;<span class="comment">//插入点之后的现有元素个数大于要插入的个数n</span></span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(finish - n, finish, finish);<span class="comment">//[finish-n,finish]往后移动</span></span><br><span class="line">        finish += n;<span class="comment">//新的finish位置</span></span><br><span class="line">        <span class="built_in">copy_backward</span>(position, old_finish - n, old_finish);<span class="comment">//从后往前copy[position,old_finish-n]的元素</span></span><br><span class="line">        <span class="built_in">fill</span>(position, position + n, x_copy);<span class="comment">//[position,position+n]插入新的元素</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;<span class="comment">//插入点之后的现有元素个数小于等于要插入的个数n</span></span><br><span class="line">        <span class="built_in">uninitialized_fill_n</span>(finish, n - elems_after, x_copy);<span class="comment">//先把插入位置大于finish的部分元素全部插入</span></span><br><span class="line">        finish += n - elems_after;<span class="comment">//调整finish为插入部分新元素后的位置</span></span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(position, old_finish, finish);<span class="comment">//把原来的[position,old_finish]的全部元素移动到新的finish的后面</span></span><br><span class="line">        finish += elems_after;<span class="comment">//再次调整finish位置</span></span><br><span class="line">        <span class="built_in">fill</span>(position, old_finish, x_copy);<span class="comment">//把[position,old_finish]赋值为新的元素</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//如果说备用空间小于要插入的元素所占用的空间</span></span><br><span class="line">      <span class="type">const</span> size_type old_size = <span class="built_in">size</span>();        </span><br><span class="line">      <span class="type">const</span> size_type len = old_size + <span class="built_in">max</span>(old_size, n);<span class="comment">//获取总的需要的长度空间单元</span></span><br><span class="line">      <span class="comment">//分配空间</span></span><br><span class="line">      iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);<span class="comment">//新的start</span></span><br><span class="line">      iterator new_finish = new_start;<span class="comment">//新的finish</span></span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_fill_n</span>(new_finish, n, x);</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="keyword">ifdef</span>  __STL_USE_EXCEPTIONS </span></span><br><span class="line">      <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">      <span class="comment">//销毁原始空间</span></span><br><span class="line">      <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">      <span class="built_in">vector_deallocate</span>();</span><br><span class="line">      <span class="comment">//确定新的 start finish  end_of_storeage</span></span><br><span class="line">      start = new_start;</span><br><span class="line">      finish = new_finish;</span><br><span class="line">      end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-5-push-bcak"><a href="#4-5-push-bcak" class="headerlink" title="4.5 push_bcak*"></a>4.5 push_bcak*</h2><p>在容器的末尾插入一个元素，分为两种情况：</p>
<ol>
<li>如果还有<strong>备用空间</strong>，则直接构造对象。</li>
<li>否则，调用insert_aux进行扩充空间的insert</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish, x);<span class="comment">//使用 placement new 操作，直接在finish位置构造对象</span></span><br><span class="line">        ++finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);<span class="comment">//此时finish==end_of_storage</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看push_back在处理<strong>插入一个元素空间不足</strong>的时候的处理方法：</p>
<p>调用 insert_aux，这个函数接受一个position，表示插入位置，x表示插入值：</p>
<p><strong>在position位置插入元素x</strong></p>
<ol>
<li><p>如果空间足够插入此元素，则在<strong>position之后的元素往后移动一位</strong>。注意<strong>直接构造一个新的finish，即在finish处调用一次construct即可，无需在position处使用construct</strong></p>
</li>
<li><p>如果<strong>备用空间不够</strong>，则计算出现有空间大小，然后开<strong>两倍原始空间大小</strong>。</p>
<ol>
<li>调用第二级空间配置器的 allocate 开辟空间</li>
<li>把原始数据拷贝进新的空间中，<strong>在finish的地方调用一次construct</strong>，完成元素的插入。</li>
</ol>
</li>
<li>销毁原始空间： destroy和deallocate函数</li>
<li>调整参数的位置。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="type">const</span> T&amp; x) &#123;</span><br><span class="line">    <span class="comment">//在 position位置插入一个元素 x</span></span><br><span class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">    <span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">    ++finish;</span><br><span class="line">    T x_copy = x;</span><br><span class="line">    <span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);<span class="comment">//从后往前拷贝，元素顺序不变</span></span><br><span class="line">    *position = x_copy;<span class="comment">//空出position这一个位置之后，插入x_copy新元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//空间不够，开内存</span></span><br><span class="line">    <span class="type">const</span> size_type old_size = <span class="built_in">size</span>();<span class="comment">// start - finish 现有元素的空间size</span></span><br><span class="line">    <span class="type">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;<span class="comment">//开两倍内存，否则为1</span></span><br><span class="line">    iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">    iterator new_finish = new_start;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">      <span class="built_in">construct</span>(new_finish, x);</span><br><span class="line">      ++new_finish;</span><br><span class="line">      new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#       <span class="keyword">ifdef</span>  __STL_USE_EXCEPTIONS </span></span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">//commit or rallback</span></span><br><span class="line">      <span class="built_in">destroy</span>(new_start, new_finish); </span><br><span class="line">      data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">      <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#       <span class="keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">    <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">vector_deallocate</span>();</span><br><span class="line">    start = new_start;</span><br><span class="line">    finish = new_finish;</span><br><span class="line">    end_of_storage = new_start + len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL源码剖析</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码学习（2） - 迭代器概念与traits编程技法</title>
    <url>/2023/03/07/STL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A6%82%E5%BF%B5%E4%B8%8Etraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="1-迭代器设计思维"><a href="#1-迭代器设计思维" class="headerlink" title="1. 迭代器设计思维"></a>1. 迭代器设计思维</h1><p>STL的中心思想：将数据容器与算法分离开，彼此独立设计，再以一剂黏着剂将二者撮合在一起。</p>
<p>如何设计出这样的黏着剂呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个迭代器和一个搜索对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first != last &amp;&amp; *first != value) ++first;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find算法的源码揭示了 <strong>容器 算法与迭代器之间的合作关系</strong></p>
<hr>
<h2 id="1-1-制作List及其迭代器"><a href="#1-1-制作List及其迭代器" class="headerlink" title="1.1 制作List及其迭代器"></a>1.1 制作List及其迭代器</h2><p>来为list设计一个迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ mylist.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MT_LIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT_LIST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ListNode</span>(T val, ListNode* pnext = <span class="literal">nullptr</span>)</span><br><span class="line">		:_data(val), _next(pnext) &#123;&#125;</span><br><span class="line">	<span class="function">T <span class="title">value</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_data; &#125;</span><br><span class="line">	<span class="function">ListNode* <span class="title">next</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_next; &#125; <span class="comment">//关键函数</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> T&amp; val)<span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_data!=val; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T _data;</span><br><span class="line">	ListNode* _next;	<span class="comment">//next指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">List</span>() :_front(<span class="literal">nullptr</span>), _end(<span class="literal">nullptr</span>), _size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="comment">//单链表尾插</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_end</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ListNode&lt;T&gt;* pNew = <span class="keyword">new</span> ListNode&lt;T&gt;&#123; value &#125;;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_end-&gt;_next = pNew;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_end = pNew;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//单链表头插</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_front</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ListNode&lt;T&gt;* pNew = <span class="keyword">new</span> <span class="built_in">ListNode</span>&lt;T&gt;(value);</span><br><span class="line">		pNew-&gt;_next = <span class="keyword">this</span>-&gt;_front;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_front = pNew;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_size++;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_size == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;_end = <span class="keyword">this</span>-&gt;_front;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历链表</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(std::ostream&amp; out=std::cout)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ListNode&lt;T&gt;* temp = <span class="keyword">this</span>-&gt;_front;</span><br><span class="line">		<span class="keyword">while</span> (temp!=<span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			out &lt;&lt; temp-&gt;<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			temp = temp-&gt;_next;</span><br><span class="line">		&#125;</span><br><span class="line">		out &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">ListNode&lt;T&gt;* <span class="title">front</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_front; &#125;</span><br><span class="line">	<span class="function">ListNode&lt;T&gt;* <span class="title">end</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_end; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ListNode&lt;T&gt;* _end;</span><br><span class="line">	ListNode&lt;T&gt;* _front;</span><br><span class="line">	<span class="type">size_t</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !MT_LIST</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ mylist-iter.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_LIST_ITER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_LIST_ITER</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylist.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Node&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListIter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ListIter</span>&lt;Node&gt;(Node* p = <span class="literal">NULL</span>)</span><br><span class="line">		:_ptr(p) &#123;&#125;</span><br><span class="line">	Node&amp; <span class="keyword">operator</span>*()<span class="type">const</span> &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">	Node* <span class="keyword">operator</span>-&gt;()<span class="type">const</span> &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line">	ListIter&amp; <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//前置++</span></span><br><span class="line">		_ptr = _ptr-&gt;<span class="built_in">next</span>(); <span class="comment">//! 暴露了ListNode的next函数</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListIter <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//后置++</span></span><br><span class="line">		ListIter temp = *<span class="keyword">this</span>;</span><br><span class="line">		++* <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ListIter&amp; lhs)<span class="type">const</span> &#123; <span class="keyword">return</span> _ptr == lhs._ptr; &#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ListIter&amp; lhs)<span class="type">const</span> &#123; <span class="keyword">return</span> _ptr != lhs._ptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node* _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ main</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylist-iter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	传入后first和last调用ListIter类的重载的!=运算符。</span></span><br><span class="line"><span class="comment">	但是*first得到的是ListNode&lt;T&gt;类型的值，因此为了比较与T类型的值还需要进行操作：</span></span><br><span class="line"><span class="comment">		1. 直接在外部添加针对ListNode&lt;T&gt;和T的!=的重载运算符</span></span><br><span class="line"><span class="comment">		2. 在ListNode&lt;T&gt;内添加重载!=的运算符</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span> (first != last &amp;&amp; *first != value) ++first;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ListNode&lt;T&gt;&amp; pnode, <span class="type">const</span> T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pnode.<span class="built_in">value</span>() != val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	List&lt;<span class="type">int</span>&gt; mlist;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		mlist.<span class="built_in">insert_front</span>(i);</span><br><span class="line">		mlist.<span class="built_in">insert_end</span>(i + <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	mlist.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	ListIter&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">beg</span>(mlist.<span class="built_in">front</span>());</span><br><span class="line">	ListIter&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; end;</span><br><span class="line">	ListIter&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; Iter;</span><br><span class="line">	Iter = <span class="built_in">find</span>(beg, end, <span class="number">11</span>);</span><br><span class="line">	<span class="keyword">if</span> (Iter == end) std::cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;找到了! &quot;</span> &lt;&lt; Iter-&gt;<span class="built_in">value</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>为了实现一个针对 List的迭代器，我们暴露了太多关于 List 的细节：</p>
<ol>
<li>在制作beg和end迭代器的时候，我们<strong>暴露了 ListNode 这个一个类</strong>。</li>
<li>在 Find 的时候，我们<strong>暴露了 ++ 运算符的关于 ListNode类的 next操作</strong>。</li>
</ol>
<p>ListNode作为一个内部节点，<strong>应该完全隐藏起来才对</strong>。</p>
<p>这时 List 的迭代器的一个雏形，通过往下的学习，我们将逐步解决这些问题。</p>
<hr>
<h2 id="1-2-迭代器的相应型别"><a href="#1-2-迭代器的相应型别" class="headerlink" title="1.2 迭代器的相应型别"></a>1.2 迭代器的相应型别</h2><p>在运用迭代器的时候，我们很可能会用到迭代器的<strong>相应型别</strong>，</p>
<p><strong>迭代器所指之物的型别便是相应型别</strong></p>
<p>获得<strong>《迭代器相应型别》 的型别</strong>：</p>
<p>利用 function template的<strong>参数推导机制</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_temp</span><span class="params">(Iter it,T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//it: int* ; t: int</span></span><br><span class="line">	T tmp; <span class="comment">//tmp: int</span></span><br><span class="line">    <span class="comment">//func：</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func_temp</span>(val, *val);<span class="comment">//val: int* ;  *val: int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(&amp;a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>把func函数全部功能全部放入func_temp中，在func_temp通过template参数推导自动获得了 <strong>型别T</strong></p>
<p><strong>这样T 就是迭代器所指之物的型别</strong></p>
<p>但是迭代器的相应型别不只是所指之物的型别，<strong>相应的型别有五种</strong>，但是并非任何情况下都能使用这个<strong>template参数推导</strong>来取得。</p>
<hr>
<h2 id="1-3-Traits编程技巧"><a href="#1-3-Traits编程技巧" class="headerlink" title="1.3 Traits编程技巧"></a>1.3 Traits编程技巧</h2><p>迭代器所指对象的型别称为 该迭代器的 <strong>value type</strong>。</p>
<p>template参数推导无法处理作为返回值的 value type，如果解决这个问题？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mystu</span></span><br><span class="line">&#123;</span><br><span class="line">	T* ptr;</span><br><span class="line">	<span class="built_in">Mystu</span>(T* ptr = <span class="literal">NULL</span>) :<span class="built_in">ptr</span>(ptr) &#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*()<span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">func2</span><span class="params">(T ite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//T的型别是 ite的型别即 Mystu&lt;int&gt; 但是作为返回值的类型是什么呢？</span></span><br><span class="line">	<span class="keyword">return</span> *ite;<span class="comment">//解引用获得其值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<strong>内嵌类型声明</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mystu</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;	<span class="comment">//内嵌型别</span></span><br><span class="line">	T* ptr;</span><br><span class="line">	<span class="built_in">Mystu</span>(T* ptr = <span class="literal">NULL</span>) :<span class="built_in">ptr</span>(ptr) &#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*()<span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">func2</span><span class="params">(T ite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//T的型别是 ite的型别即 Mystu&lt;int&gt; 但是作为返回值的类型是什么呢？</span></span><br><span class="line">	<span class="keyword">return</span> *ite;<span class="comment">//解引用获得其值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mystu&lt;<span class="type">int</span>&gt; b&#123; <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">10</span>&#125; &#125;;</span><br><span class="line">	std::cout&lt;&lt;<span class="built_in">func2</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键做法：</p>
<ol>
<li>在类中 需要对 T 参数进行typedef。</li>
<li>在作为返回值的地方必须使用 typename 作为修饰，然后返回T的型别</li>
</ol>
<p><strong>关键词typename告诉编译器这是一个 Mystu&lt; T &gt;::value_type的型别</strong></p>
<hr>
<p>但是如果不是 <strong>类类型</strong>，就无法使用上述的<strong>定义内嵌类型</strong>的形式</p>
<p>原生指针就不是类，因此无法定义内嵌型别。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* c = <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">10</span> &#125;;</span><br><span class="line">std::cout&lt;&lt;<span class="built_in">func2</span>(c);	<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
<p>你会发现，就会报错，<strong>没有匹配的函数</strong>，因为<strong>原生指针不是类，无法定义内嵌类型</strong></p>
<p>但是STL提供了一种方法可以使得原生指针作为一种特殊情况被一般化。</p>
<p><strong>偏特化！</strong></p>
<p>萃取迭代器的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3. 萃取迭代器的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> <span class="comment">//普通类型</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//如果 T 有自己的value_type 那么通过这个traits，萃取出来的value_type 就是T的value_type</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;T&gt;::<span class="function">value_type <span class="title">func3</span><span class="params">(T ite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *ite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们会发现，他不和上面的内嵌型别是一样的吗，而且返回值还写复杂了，有什么用呢？</p>
<p>我们再写一个针对iterator_traits的偏特化版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// traits的特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这时候，你就会发现，这条语句竟然成功了，并且返回 10作为返回值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* c = <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">10</span> &#125;;</span><br><span class="line">std::cout&lt;&lt;<span class="built_in">func3</span>(c);	<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>
<p>这是因为 c作为一个普通的指针，<strong>我们传入 func3 函数之后，函数察觉到了 这是一个原生指针，因此调用 iterator_traits的原生指针T* 的偏特化版本，使得可以接受一个原生指针</strong></p>
<p>解决 参数是 const 类型的原生指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* d = <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">20</span> &#125;;</span><br><span class="line">std::cout&lt;&lt;<span class="built_in">func3</span>(d);	<span class="comment">//OK but 我们返回的仍然是const int 类型的值</span></span><br></pre></td></tr></table></figure>
<p>如果我们返回一个 非 const，则可以针对const 指针再来一个偏特化版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// traits的特化版本 const版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​    这样函数的返回值就是一个 非const，即去除了 参数的 const属性。</p>
<p>traits 所扮演的特性是 <strong>特性萃取机</strong>的角色，<strong>萃取各个迭代器的相应型别</strong>，要使得 特性萃取机能够有效的工作，每一个迭代器都应该以<strong>内嵌类型定义</strong>的形式定义出<strong>相应的型别</strong>。</p>
<hr>
<p>迭代器一共有五种<strong>相应型别</strong>：</p>
<ol>
<li><strong>value_type</strong></li>
<li><strong>difference_type</strong></li>
<li><strong>pointer</strong></li>
<li><strong>reference</strong></li>
<li><strong>iterator_catagoly</strong></li>
</ol>
<p><strong>为你的迭代器定义这五种相应型别。</strong></p>
<hr>
<h3 id="1-3-1-value-type"><a href="#1-3-1-value-type" class="headerlink" title="1.3.1 value_type"></a>1.3.1 value_type</h3><p>value_type是指<strong>迭代器的所指对象</strong>的相应型别。如上节所示，value_type 是任何STL容器的设计基础。</p>
<h3 id="1-3-2-deference-type"><a href="#1-3-2-deference-type" class="headerlink" title="1.3.2 deference_type"></a>1.3.2 deference_type</h3><p>deference_type用来表示表示<strong>两个迭代器之间的距离</strong>，可以用来表示一个容器的最大容量。</p>
<p>count函数用来返回等于val值的个数，因此如果一个<strong>泛型算法具有计数的功能</strong>，其返回值就必须使用deference_type类型的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::deference_type deference_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//count算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;T&gt;::<span class="function">deference_type <span class="title">count</span><span class="params">(Iter beg, Iter end, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;T&gt;::deference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; beg != end; ++beg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*beg == val)n++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们刚才自己写的 List就可以来测试一下：</p>
<p>只需要在<strong>List 的类中加上</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type</span><br></pre></td></tr></table></figure>
<p>ptrdiff_t 是 一个 int64类型的值，用于统计。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::difference_type difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//针对原生指针的偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对原生指针const的偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::difference_type _count(Iter beg, Iter end, <span class="type">const</span> T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::difference_type n = <span class="number">0</span>;<span class="comment">//n: ptrdiff_t</span></span><br><span class="line">	<span class="keyword">for</span> (; beg != end; ++beg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*beg == val)</span><br><span class="line">			++n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	List&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p.<span class="built_in">insert_end</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	p.<span class="built_in">insert_end</span>(<span class="number">5</span>);</span><br><span class="line">	p.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	ListIter&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">beg</span>(p.<span class="built_in">front</span>());</span><br><span class="line">	ListIter&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; end;</span><br><span class="line">	ListIter&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; Iter;</span><br><span class="line">	<span class="keyword">auto</span> ppp =  _count(beg, end, <span class="number">5</span>);</span><br><span class="line">	std::cout &lt;&lt; ppp &lt;&lt; std::endl;	<span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="1-3-3-reference-和-pointer"><a href="#1-3-3-reference-和-pointer" class="headerlink" title="1.3.3 reference 和 pointer"></a>1.3.3 reference 和 pointer</h3><p>代表迭代器所指对象的<strong>引用与指针类型</strong>，实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="1-3-4-iterator-category"><a href="#1-3-4-iterator-category" class="headerlink" title="1.3.4 iterator_category"></a>1.3.4 iterator_category</h3><p>首先来看迭代器的五种类型：</p>
<ol>
<li>Input iterator：只读迭代器</li>
<li>Output iterator：只写迭代器</li>
<li>Forward iterator：可读可写迭代器</li>
<li>Bidirectional iterator：双向移动迭代器</li>
<li>Random Access iterator：<strong>前四种迭代器都支持一种指针运算（++或者—），而此迭代器支持所有的指针运算。</strong></li>
</ol>
<p><strong>这五种迭代器自上而下呈加强状态，即功能越来越强。</strong></p>
<p>要对某种迭代器提供一种<strong>准确的定义</strong>，对另一种<strong>强化的迭代器</strong>提供另一种定义，这样才能使得效率最大化。</p>
<p>举例：如何设计 <strong>Advance函数</strong></p>
<p>advance函数的含义是传入两个参数，并且<strong>将第一个参数的迭代器 前进 n个位置。</strong></p>
<p>如何针对指定的迭代器类型来选择合适的实现功能呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于只读迭代器：Input 可读可写迭代器：Forward 都是这样的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator Iter, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (n--) ++Iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于双向迭代器：Bidirectional </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Bidirectional, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(Bidirectional Iter, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (n--) ++Iter;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (n++) --Iter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于随机迭代器：Random</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(RandomIterator Iter, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Iter += n;<span class="comment">//随机迭代器支持任意的指针运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们写出了每种迭代器的<strong>最佳的选择</strong>，那么我们怎么确定一个最终的执行函数呢？</p>
<p>难道要设计几个函数判断其是为<strong>只读型迭代器</strong>还是<strong>双向迭代器</strong>还是<strong>随机迭代器</strong>？</p>
<p>但是这样每次在执行advanc的时候都执行一次<strong>选择哪个版本的判断，太影响效率了</strong>，我们最好在编译期间就能判断执行哪个版本，我们可以使用<strong>重载函数的机制来实现</strong>。</p>
<p><strong>我们让这三个函数同名，并且加上第三个参数，第三个参数为迭代器类型，使得traits可以根据第三个参数的类型来推断出执行哪个函数</strong>。</p>
<p>因此第三个参数一定是一个 <strong>类</strong> 类型，我们使用以下方式来解决：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//五个标记类型</span></span><br><span class="line"><span class="comment">//五个标记类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Input_Iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Output_Iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Forward_Iterator_tag</span>: <span class="keyword">public</span> Input_Iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bidirectional_Iterator_tag</span>: <span class="keyword">public</span> Forward_Iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Random_Iterator_tag</span>:<span class="keyword">public</span> Bidirectional_Iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于只读迭代器：Input 可读可写迭代器：Forward 都是这样的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> _advance(InputIterator Iter, Distance n,Input_Iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (n--) ++Iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于可读可写迭代器:直接调用Input</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> _advance(InputIterator Iter, Distance n, Forward_Iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	_advance(Iter,n, <span class="built_in">Input_Iterator_tag</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于双向迭代器：Bidirectional </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Bidirectional, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> _advance(Bidirectional Iter, Distance n,Bidirectional_Iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (n--) ++Iter;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (n++) --Iter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于随机迭代器：Random</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(RandomIterator Iter, Distance n,Random_Iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Iter += n;<span class="comment">//随机迭代器支持任意的指针运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建<strong>五种迭代器标记</strong>，他们只作为标记使用，在实际的_advance中无需参数的名称，根据是哪一个型别，编译器可以推断出使用哪一个版本。</p>
<p>对于最终的执行函数，我们只需要来 traits萃取迭代器的类型即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//iterator_category函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::<span class="function">iterator_category <span class="title">iterator_category</span><span class="params">(<span class="type">const</span> Iter&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::iteratr_category category;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">category</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::iterator_category iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//原指针的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Random_Iterator_tag iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//const指针的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Random_Iterator_tag iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//执行函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; it, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_advance(it, n, <span class="built_in">iterator_category</span>(it));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于advance函数来说，InputIterator作为其函数参数类型的名字是合理的。</p>
<p><strong>因为STL的命名规则是 以函数所能接受的最低阶迭代器类型作为其迭代器参数的类型名称</strong></p>
<hr>
<h3 id="1-3-5-迭代器标签"><a href="#1-3-5-迭代器标签" class="headerlink" title="1.3.5 迭代器标签"></a>1.3.5 迭代器标签</h3><p>上面描述的五个迭代器的标签，不仅可以促成<strong>函数重载机制与traits萃取的功效</strong></p>
<p>而且通过继承，我们不必再写多个 标签的函数。</p>
<p>distance的函数是计算两个迭代器之间的距离：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type  </span><br><span class="line">	_distance(InputIterator beg, InputIterator end, Input_Iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (beg != end)</span><br><span class="line">	&#123;</span><br><span class="line">		++beg;</span><br><span class="line">		++n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;RandomIterator&gt;::difference_type</span><br><span class="line">	_distance(RandomIterator beg, RandomIterator end, Random_Iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//直接计算差距</span></span><br><span class="line">	<span class="keyword">return</span> end - beg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function">	<span class="title">distance</span><span class="params">(InputIterator beg, InputIterator end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category;</span><br><span class="line">	_distance(beg, end, <span class="built_in">category</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需处理两个迭代器类型即可，即InputIterator和RandomIterator</p>
<p>因为 其他的迭代器都可由 InputIterator 完全替代，通过继承我们可以直接指定他们的默认_distance 函数就是 InputIterator的 _distance函数。</p>
<h2 id="1-4-iterator模板"><a href="#1-4-iterator模板" class="headerlink" title="1.4 iterator模板"></a>1.4 iterator模板</h2><p>任何迭代器都应该提供上述<strong>五个相应型别</strong>，以利于traits的萃取。</p>
<p>STL提供的iterator完整如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Category,<span class="keyword">typename</span> Distance=<span class="type">ptrdiff_t</span>,</span><br><span class="line">	<span class="keyword">typename</span> Reference=T&amp;,<span class="keyword">typename</span> Pointer=T*&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> value_type = T;</span><br><span class="line">	<span class="keyword">using</span> difference_type = Distance;</span><br><span class="line">	<span class="keyword">using</span> reference = Reference;</span><br><span class="line">	<span class="keyword">using</span> pointer = Pointer;</span><br><span class="line">	<span class="keyword">using</span> iterator_category = Category;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现代 STL 使用using，当然typedef也是可以的。</p>
<p>iterator只是型别定义，不含任何成员，因此可以在后续设计的迭代器中<strong>继承它</strong></p>
<p>因此就可以在自己的迭代器中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListIter</span>:<span class="keyword">public</span> iterator&lt;T,std::forward_iterator_tag&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//类内</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只需要传入 T 以及 它的迭代器型别标签即可。</p>
<hr>
<p>简单总结：</p>
<ol>
<li>设计迭代器的相应型别，是迭代器的责任。</li>
<li><strong>设计容器的适当的迭代器，是容器本身的责任，只有容器才直到该如何设计适当的迭代器来遍历与操作自己。</strong>迭代器的行为包括 取值，前进，后退，取用成员。</li>
<li>设计算法则无需 <strong>容器和迭代器</strong> 的帮助，只要以迭代器为接口即可。</li>
</ol>
<p><strong>traits编程技巧的精华：</strong></p>
<ol>
<li><strong>内嵌型别的编程方法</strong></li>
<li><strong>template自动推导参数的方法。</strong></li>
</ol>
<hr>
<h2 id="1-5-iterator完整源代码"><a href="#1-5-iterator完整源代码" class="headerlink" title="1.5 iterator完整源代码"></a>1.5 iterator完整源代码</h2><p>SGISTL库的iteraotr的结构：</p>
<ol>
<li>五种迭代器类型</li>
<li>iterator类</li>
<li>迭代器萃取类，针对指针的偏特化</li>
<li>决定某个迭代器的型别（category，value_type，difference_type）</li>
<li>distance函数，advance函数</li>
</ol>
<p>手写完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_ITERATOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_ITERATOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 五种迭代器类型</span></span><br><span class="line"><span class="comment">2. iterator类</span></span><br><span class="line"><span class="comment">3. 迭代器萃取类，针对指针的偏特化</span></span><br><span class="line"><span class="comment">4. 决定某个迭代器的型别（category，value_type，difference_type）</span></span><br><span class="line"><span class="comment">5. distance函数，advance函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 五种迭代器类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InputIterator_tag</span> &#123;&#125;;<span class="comment">//读入迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OutputIterator_tag</span> &#123;&#125;;<span class="comment">//输出迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ForwardIterator_tag</span> &#123;&#125;;<span class="comment">//可读可写迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bidirectional_Iterator_tag</span> &#123;&#125;;<span class="comment">//双向迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RandomAccessIterator_tag</span> &#123;&#125;;<span class="comment">//随机迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. iterator类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> category, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Distance = std::<span class="type">ptrdiff_t</span>,</span><br><span class="line">	<span class="keyword">typename</span> Pointer = T*, <span class="keyword">typename</span> Reference = T&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> value_type = T;</span><br><span class="line">	<span class="keyword">using</span> difference_type = Distance;</span><br><span class="line">	<span class="keyword">using</span> pointer = Pointer;</span><br><span class="line">	<span class="keyword">using</span> reference = Reference;</span><br><span class="line">	<span class="keyword">using</span> iterator_category = category;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 迭代器型别萃取类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> value_type = <span class="keyword">typename</span> Iter::value_type;</span><br><span class="line">	<span class="keyword">using</span> difference_type = <span class="keyword">typename</span> Iter::difference_type;</span><br><span class="line">	<span class="keyword">using</span> pointer = <span class="keyword">typename</span> Iter::pointer;</span><br><span class="line">	<span class="keyword">using</span> reference = <span class="keyword">typename</span> Iter:reference;</span><br><span class="line">	<span class="keyword">using</span> iterator_category = <span class="keyword">typename</span> Iter::iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对指针的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> value_type = T;</span><br><span class="line">	<span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">	<span class="keyword">using</span> pointer = T*;</span><br><span class="line">	<span class="keyword">using</span> reference = T&amp;;</span><br><span class="line">	<span class="keyword">using</span> iterator_category = RandomAccessIterator_tag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> value_type = T;</span><br><span class="line">	<span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">	<span class="keyword">using</span> pointer = <span class="type">const</span> T*;</span><br><span class="line">	<span class="keyword">using</span> reference = <span class="type">const</span> T&amp;;</span><br><span class="line">	<span class="keyword">using</span> iterator_category = RandomAccessIterator_tag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 决定某个迭代器的类型（category，value_type，difference_type）</span></span><br><span class="line"><span class="comment">//4.1 category</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function">	<span class="title">iterator_category</span><span class="params">(<span class="type">const</span> Iter&amp; it)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> category = <span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::iterator_category;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">category</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//决定某个迭代器的difference_type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::<span class="function">difference_type*</span></span><br><span class="line"><span class="function">	<span class="title">difference_type</span><span class="params">(<span class="type">const</span> Iter&amp; it)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//决定某个迭代器的value_type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::<span class="function">value_type*</span></span><br><span class="line"><span class="function">	<span class="title">value_type</span><span class="params">(<span class="type">const</span> Iter&amp; it)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. distance函数，advance函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type</span><br><span class="line">	_distance(InputIterator begin, InputIterator end,InputIterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (begin != end)</span><br><span class="line">	&#123;</span><br><span class="line">		begin++;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;RandomIterator&gt;::difference_type</span><br><span class="line">	_distance(RandomIterator begin,RandomIterator end,RandomAccessIterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> end - begin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//distance主函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function">	<span class="title">distance</span><span class="params">(InputIterator begin, InputIterator end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//using category = typename iterator_traits&lt;InputIterator&gt;::iterator_category;</span></span><br><span class="line">	<span class="keyword">return</span> _distance(begin, end, <span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"><span class="comment">//advance函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> _advance(InputIterator it,Distance n,InputIterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (n--) ++it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> _advance(BidirectionalIterator it,Distance n,Bidirectional_Iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (n--) ++it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (n++) --it;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> _advance(RandomIterator it, Distance n,RandomAccessIterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	it += n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator it, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_advance(it, n, <span class="built_in">iterator_category</span>(it));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !MY_ITERATOR_H</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1-6-type-traits"><a href="#1-6-type-traits" class="headerlink" title="1.6 __type_traits"></a>1.6 __type_traits</h2><p><strong>iterator_traits负责萃取迭代器的特性，__type_traits负责萃取型别的特性。</strong></p>
<blockquote>
<p>ctor：构造函数</p>
<p>dtor：析构函数</p>
<p>copy ctor：拷贝构造函数</p>
<p>assignment：赋值运算符</p>
<p>trivial：无意义的：</p>
<ul>
<li>trivial ctor：没有构造函数</li>
<li>trivial dtor：没有析构函数</li>
<li>trivial copy ctor：没有拷贝构造函数</li>
<li>trivial assignment：没有赋值运算符</li>
</ul>
<p>non-trivial：有意义的</p>
<ul>
<li>non-trivial ctor：显式定义了构造函数</li>
<li>non-trivial dtor：显式定义了析构函数</li>
<li>non-trivial copy ctor：显式定义了拷贝构造函数</li>
<li>non-trivial assignment：显式定义了赋值运算符</li>
</ul>
<p>POD：具有trivial ctor，trivial dtor，trivial copy ctor，trivial assignment属性，即全部都是没有显式定义的。</p>
</blockquote>
<p>什么是<strong>型别特性？</strong></p>
<ul>
<li>这个类是否具备有意义的（即<strong>显式定义了</strong>） non-trivial 的构造/析构/拷贝构造/赋值运算 等操作，如果是trivia的（即<strong>没有显式定义</strong>），则我们就无需对ctor，dtor等进行操作，<strong>直接采用最有效率的内存操作</strong>，如memcpy，malloc等，对于大规模而频繁操作的容器具有很大的提升。</li>
</ul>
<hr>
<p>__type_traits提供了一种操作，针对不同的型别，允许在<strong>编译的时候</strong>就知道函数派送决定。如果我们知道了我们的类是否有一个 <strong>trivial ctor</strong> ，并且正好需要对这个类执行拷贝操作，则我们直接可以<strong>对内存操作</strong>。</p>
<p>__type_traits为像 iterator_traits一样，因此我们应该对它进行这样的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__type_traits&lt;T&gt;::has_trivial_default_constructor;</span><br><span class="line">__type_traits&lt;T&gt;::has_trivia_copy_constructor;</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_assignment_operator;</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_destructor;</span><br><span class="line">__type_traits&lt;T&gt;::i_POD_type;</span><br></pre></td></tr></table></figure>
<p>但是我们希望对 __type_traits的操作<strong>响应</strong>不是 <strong>真或者假</strong>，而是某一个类的对象，因为我们需要对这个<strong>响应的对象进行</strong>参数推导。而编译器只有面对class object这样的对象才具有参数推导的功能。</p>
<p>因此，上述的式子应该返回这样的<strong>响应对象</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__true_type</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__false_type</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>空白的类成员，既能够<strong>标识真假</strong>，又能够起到<strong>参数推导</strong>的作用。</p>
<p>因此为了达成这样的操作，__type_traits的内部应该是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_default_constructor = __false_type;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_copy_constructor = __false_type;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_assignment_operator = __false_type;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_destructor = __false_type;</span><br><span class="line">	<span class="keyword">using</span> is_POD_type = __false_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们首先定义出<strong>最保守的值</strong>。最保守的就是对所有型别都必定有效的保守值</p>
<p>__type_traits可以接受任意型别的参数。</p>
<hr>
<p>然后再设计针对每一种<strong>标量类型的特化版本</strong></p>
<p>包括 char， unsigned char，int，float，double，long long 等类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_default_constructor = __true_type;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_copy_constructor = __true_type;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_assignment_operator = __true_type;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_destructor = __true_type;</span><br><span class="line">	<span class="keyword">using</span> is_POD_type = __true_type;</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">signed</span> <span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_default_constructor = __true_type;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_copy_constructor = __true_type;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_assignment_operator = __true_type;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_destructor = __true_type;</span><br><span class="line">	<span class="keyword">using</span> is_POD_type = __true_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">....................</span><br><span class="line">    </span><br><span class="line"><span class="comment">//针对任意原生指针类型的偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_default_constructor = __true_type;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_copy_constructor = __true_type;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_assignment_operator = __true_type;</span><br><span class="line">	<span class="keyword">using</span> has_trivial_destructor = __true_type;</span><br><span class="line">	<span class="keyword">using</span> is_POD_type = __true_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>以下是__type_traits的应用举例：（从下往上看 uninitialized_fill_n 是要执行的函数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Size, <span class="keyword">typename</span> T&gt;</span><br><span class="line">ForwardIterator __uninitialized_fill_n_anx(ForwardIterator first, Size n,</span><br><span class="line">	<span class="type">const</span> T&amp; x, __false_type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//__false_type : 不是POD类型，进行普通的构造</span></span><br><span class="line">	ForwardIterator cur = first;</span><br><span class="line">	<span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n--, ++cur)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">construct</span>(&amp;*cur, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Size, <span class="keyword">typename</span> T&gt;</span><br><span class="line">ForwardIterator __uninitialized_fill_n_anx(ForwardIterator first, Size n,</span><br><span class="line">	<span class="type">const</span> T&amp; x, __true_type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//__true_type：是POD类型，可以进行快速的操作，操作内存</span></span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">fill_n</span>(first, n, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator,<span class="keyword">typename</span> Size,<span class="keyword">typename</span> T,<span class="keyword">typename</span> T1&gt;</span><br><span class="line">ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, <span class="type">const</span> T1&amp;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//T1为萃取出的迭代器所指的元素类型</span></span><br><span class="line">	<span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_pod;</span><br><span class="line">	<span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从 first处开始构造n个元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator,<span class="keyword">typename</span> Size,<span class="keyword">typename</span> T&gt;</span><br><span class="line">ForwardIterator <span class="built_in">uninitialized_fill_n</span>(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//value_type利用 iterator_traits 萃取出迭代器所指的元素类型</span></span><br><span class="line">	<span class="keyword">return</span> __uninitialized_fill_n(first, n, x, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>首先执行uninitialized_fill_n，传入三个参数，标识从first开始构造 n个 x</li>
<li>利用iterator_traits 的 value_type（参见上节）推断出迭代器<strong>所指对象的元素类型</strong></li>
<li>在<strong>uninitialized_fill_n 中 <strong>T1</strong> 得到<strong>此参数类型</strong>，再利用 </strong>type_trait的 类型推导，得出这个类型是 <strong>_true_type 还是 \</strong>false_type </li>
<li>如果是__true_type，则<strong>是POD类型</strong>，直接进行<strong>内存操作</strong></li>
<li>如果是__false_type，则<strong>不是POD类型</strong>，则只能按照其<strong>构造函数对其进行构造</strong></li>
</ol>
<p>如果这个class内含指针成员，并且对他进行动态内存分配，则它就是个非 POD的，需要实现出自己的 non-trivial 操作</p>
<p>在以后，针对每一个<strong>标量</strong>型别，我们都可以 利用 _type_traits 选择最高效的操作：</p>
<ol>
<li>_true_type：是trivial的，执行对内存的快速操作。</li>
<li>_false_type：不是trivial的，执行对象的构造，调用相应的函数。</li>
</ol>
]]></content>
      <categories>
        <category>STL源码剖析</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL源码学习（1）- 空间配置器</title>
    <url>/2023/03/07/STL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89-%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="1-SGI空间配置器"><a href="#1-SGI空间配置器" class="headerlink" title="1. SGI空间配置器"></a>1. SGI空间配置器</h1><p>SGI STL的空间配置器是 alloc而非allocator，并且<strong>不接受任何参数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>,std::alloc&gt; vec</span><br></pre></td></tr></table></figure>
<p>我们通常使用<strong>缺省的空间配置器</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc=alloc&gt;<span class="comment">//指定其默认空间配置器为 alloc</span></span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-1-std-allocator"><a href="#1-1-std-allocator" class="headerlink" title="1.1 std::allocator"></a>1.1 std::allocator</h2><p>SGI的 allocator空间配置器 <strong>只是对 new 和delete 做了一层包装</strong>，效率及其不佳，不建议使用它</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T* <span class="title">allocate</span><span class="params">(<span class="type">ptrdiff_t</span> size, T*)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">    T* tmp = (T*)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size * <span class="built_in">sizeof</span>(T))));</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line">	    cerr &lt;&lt; <span class="string">&quot;out of memory&quot;</span> &lt;&lt; endl; </span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T* buffer)</span> </span>&#123;</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>allocate：包装了 new </p>
<p>deallocate：包装了 delete</p>
<p>因此 SGI的 allocator <strong>是基层内存配置释放的行为，只有包装，没有效率的优势</strong></p>
<hr>
<h2 id="1-2-std-alloc"><a href="#1-2-std-alloc" class="headerlink" title="1.2 std::alloc"></a>1.2 std::alloc</h2><p>SGI 重要的空间配置器：std::alloc</p>
<p>我们常写的c++语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span>* obj=<span class="keyword">new</span> <span class="built_in">class</span>();</span><br><span class="line"><span class="keyword">delete</span> obj</span><br></pre></td></tr></table></figure>
<p>使用new创建对象与使用delete销毁对象。</p>
<p>使用new时的完整操作：</p>
<ol>
<li>首先调用 ::operator new<strong>配置内存</strong>。</li>
<li>然后调用 <strong>构造函数</strong> 初始化对象。</li>
</ol>
<p>同理delete的完整操作：</p>
<ol>
<li>首先调用 <strong>析构函数</strong> 销毁对象。</li>
<li>然后调用 ::operator delete <strong>释放内存</strong>。</li>
</ol>
<p>因此alloc把<strong>new和delete 以及他们各自的两部分分离开</strong>：</p>
<ul>
<li><strong>alloc:allocate</strong>：配置内存</li>
<li><strong>alloc:deallocate</strong>：释放内存</li>
<li><strong>::construct</strong>：构造对象</li>
<li><strong>::destroy</strong>：销毁对象</li>
</ul>
<p>他们分别存在于这两个头文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stl_alloc.h&gt; //对象的配置与释放</span><br><span class="line">#include &lt;stl_construct&gt;//对象的构造与析构</span><br></pre></td></tr></table></figure>
<h2 id="1-3-对象构造与析构：construct和destroy"><a href="#1-3-对象构造与析构：construct和destroy" class="headerlink" title="1.3 对象构造与析构：construct和destroy"></a>1.3 对象构造与析构：construct和destroy</h2><p>来看 &lt; stl_construct&gt; 头文件中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new.h&gt;</span>  <span class="comment">// 引入 new 运算符</span></span></span><br></pre></td></tr></table></figure>
<p>最基本的两大函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(T* pointer)</span> </span>&#123;</span><br><span class="line">    pointer-&gt;~<span class="built_in">T</span>();      <span class="comment">// 析构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">construct</span><span class="params">(T1* p, <span class="type">const</span> T2&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> (p) <span class="built_in">T1</span>(value);    <span class="comment">//T1::T1(value)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>destroy直接负责某个对象的析构，即 ~T() 操作。</p>
<p>construct直接负责某个对象的创建，但是请注意这个new 是一个 <strong>placement new操作</strong></p>
<blockquote>
<p>形如： new (ptr) T(value) 是一个 placement new操作</p>
<p>括号里的参数ptr是一个指针，它指向一个内存缓冲器，placement new将在这个缓冲器上分配一个对象。<br>Placement new的返回值是这个被构造对象的地址(比如括号中的传递参数)。<br>placement new主要适用于：在对时间要求非常高的应用程序中，因为这些程序分配的时间是确定的；长时间运行而不被打断的程序；以及执行一个垃圾收集器 (garbage collector)。</p>
<p>比如：</p>
<p>int n=2;</p>
<p>new (&amp;n) int(10);</p>
<p>std::cout&lt;&lt;n;   //  n  = 10</p>
</blockquote>
<p>其中这<strong>两个函数还具有其他的版本</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接受两个迭代器，并设法找出元素的类型 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">  __destroy(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>destroy的第二个版本：<strong>接受两个迭代器</strong>，然后 <strong>value_type会自动推导出 此迭代器的所指的元素的类型</strong></p>
<blockquote>
<p>value_type 属于__type_traits的成员，会自动推导出迭代器所指元素的类型，在往后的 第二章 我们会学到</p>
</blockquote>
<p>然后根据推导出的第三个参数的类型选择 适当的 __destroy函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy(ForwardIterator first, ForwardIterator last, T*) &#123;</span><br><span class="line"><span class="comment">//    trivial_destructor 是__type_traits&lt;T&gt;::has_trivial_destructor的别名</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">  __destroy_aux(first, last, <span class="built_in">trivial_destructor</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考一下：destroy有两个版本，<strong>第一个版本是一个对象的析构；第二个版本是 [first，last]范围 的析构</strong></p>
<p>对于整个范围的析构：如果我们不知道这个范围有多大，则无论它是什么类型，<strong>我们都需要对范围的每一个元素执行析构函数</strong>，对于自定义类型：student，xxx等 具有<strong>我们显式定义的析构函数</strong>，我们必须这样做。</p>
<p>但是对于 int，char，long等内置类型，我们有必要对他们每次都调用<strong>析构函数</strong>（系统自带的）？？？</p>
<p>如果我们对 这些内置类型 进行一次又一次的析构，则是效率的巨大牺牲，因此有没有一种办法可以推断出即将析构的是<strong>内置类型还是自定义类型</strong>；</p>
<ul>
<li>内置类型 _true_type类型 ：直接什么也不做即可。</li>
<li>非内置类型 _false_type 类型：执行每个元素的析构函数。</li>
</ul>
<p><strong>因此上面的destroy执行的就是这样的操作</strong>。</p>
<p>对于判断它是什么类型的 value_type 的实现方法，我们在 迭代器一节 会给出方法。</p>
<hr>
<p>如果是 <strong>内置类型</strong> 即<strong>_true_type</strong>类型：直接跳过即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无需析构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator, ForwardIterator, __true_type) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果是 <strong>非内置类型</strong>  即<strong>_false_type</strong> 类型：执行析构函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要析构destory</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) &#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first &lt; last; ++first)</span><br><span class="line">    <span class="built_in">destroy</span>(&amp;*first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在false_type版本中执行的这个destroy 就是destroy的第一个版本，即直接调用 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pointer-&gt;~<span class="built_in">T</span>();      <span class="comment">// 析构</span></span><br></pre></td></tr></table></figure>
<h2 id="1-4-空间配置与释放：allocate和deallocate"><a href="#1-4-空间配置与释放：allocate和deallocate" class="headerlink" title="1.4 空间配置与释放：allocate和deallocate"></a>1.4 空间配置与释放：allocate和deallocate</h2><p>C++的内存配置与释放：new和delete</p>
<p>这两个函数相当于C的malloc和free。</p>
<p><strong>因此SGI的空间配置与释放就是依据 malloc和free进行的</strong></p>
<p>SGI 的双层级配置器：</p>
<ol>
<li>第一级配置器用于 配置大小超过 128 字节的空间。</li>
<li>第二级配置器用于 配置大小小于 128 字节的空间。</li>
</ol>
<p>第一级配置器：<strong>__malloc_alloc_template</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__malloc_alloc_tetemplate &lt;<span class="type">int</span> inst&gt;     <span class="comment">//inst完全没用到</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    第二级配置器：<strong>__default_alloc_template</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__default_alloc_template</span> </span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是第一级还是第二级，SGI提供了一个接口，使得配置器的<strong>接口得以抽象</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_alloc</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*) Alloc::<span class="built_in">allocate</span>(n * <span class="built_in">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> (T*) Alloc::<span class="built_in">allocate</span>(<span class="built_in">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">                </span>&#123; Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in">sizeof</span> (T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：这个接口非常重要！</p>
<p><strong>成员函数allocate和deallocate是可以选择调用 第一级还是第二级配置器 的实现方法的。</strong></p>
<p>几乎所有的SGI STL容器全部使用这个接口：<strong>像是 vector，list等全部使用这个接口来处理空间的配置。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line">portected:</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;T,Alloc&gt; data_allocator	<span class="comment">//数据空间配置器</span></span><br><span class="line">	...</span><br><span class="line">    <span class="type">void</span> <span class="built_in">deallocate</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(xxxxx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>deallocate函数 调用 data_allocator ，从而调用 deallocate函数，实际上就是 simple_alloc 的两个deallocate函数，然后再根据是第一级配置器还是第二级配置器选择哪个版本的 deallocate函数。</p>
<p><img src="https://tudingtu.cn/i/2023/03/09/rb33pv.png" alt=""></p>
<p><img src="https://tudingtu.cn/i/2023/03/09/rbpb58.png" alt=""></p>
<h3 id="1-4-1-第一级空间配置器"><a href="#1-4-1-第一级空间配置器" class="headerlink" title="1.4.1 第一级空间配置器"></a>1.4.1 第一级空间配置器</h3><p>我们从<strong>__malloc_alloc_template</strong>类 中 一层一层的看：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span> *, <span class="type">size_t</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>oom：out of memmory 表示内存不足。</p>
<p><strong>__malloc_alloc_oom_handler</strong>是一个函数指针，<strong>可以处理内存不足的情况</strong></p>
<hr>
<p>创建n个大小的空间，<strong>allocate会直接 malloc这个大小的空间</strong>，如果分派失败，则调用内存不足的处理方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> *result = <span class="built_in">malloc</span>(n);   <span class="comment">//第一级配置器直接使用malloc分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_malloc</span>(n);<span class="comment">//无法满足要求，使用内存不足的处理方法</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>释放某个对象的空间</strong>，直接使用 deallocate 的free</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* n */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(p);    <span class="comment">//直接使用free释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>扩容，<strong>使用 包装的ralloc即可</strong>，同样会处理内存不足的处理情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">reallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* old_sz */</span>, <span class="type">size_t</span> new_sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> * result = <span class="built_in">realloc</span>(p, new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_realloc</span>(p, new_sz);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>发生内存不足的错误时的函数指针的处理：</p>
<p>可以指定 f 为 你任意的处理错误的方法，然后赋予给 函数指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以通过它指定你自己的out of memory 处理方法</span></span><br><span class="line"><span class="comment">//仿真 set_new_handle</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* set_malloc_handler(<span class="type">void</span> (*f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (* old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = f;</span><br><span class="line">    <span class="keyword">return</span>(old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>当出现内存不足时的处理方法：</p>
<p>oom_malloc 和 oom_realloc 会尝试在例程中压缩出空间，<strong>如果挤出了一点内存则返回此内存，如果一点内存都挤不出来，则出发 失败的异常。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (* my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//不断尝试</span></span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<span class="comment">//失败直接抛出异常</span></span><br><span class="line">        (*my_malloc_handler)(); <span class="comment">//尝试调用例程，企图释放内存</span></span><br><span class="line">        result = <span class="built_in">malloc</span>(n);<span class="comment">//尝试配置内存</span></span><br><span class="line">        <span class="keyword">if</span> (result) <span class="keyword">return</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_realloc</span>(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (* my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<span class="comment">//失败直接抛出异常</span></span><br><span class="line">        (*my_malloc_handler)();</span><br><span class="line">        result = <span class="built_in">realloc</span>(p, n);</span><br><span class="line">        <span class="keyword">if</span> (result) <span class="keyword">return</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#   <span class="keyword">define</span> __THROW_BAD_ALLOC cerr &lt;&lt; <span class="string">&quot;out of memory&quot;</span> &lt;&lt; endl; exit(1)</span></span><br></pre></td></tr></table></figure>
<p>失败直接退出</p>
<hr>
<p>第一级空间配置器 利用 malloc free和ralloc实现出了对内存的分配与释放。</p>
<p>并且也实现了C++的 new handler机制</p>
<blockquote>
<p>c++ 的new_handler机制： 当无法分配足够的内存时，在丢出std::bad_alloc之前，客端会调用一些指定的处理例程，称为 new_handler，然后尽全力帮你挤出内存，如果实在挤不出来则只能抛出异常。</p>
</blockquote>
<p>但是 第一级空间配置器使用的是 malloc，而不是 new，所以无法实现 C++纯正的 set_new_handler机制，因此必须手动模拟一个 <strong>set_new_handler</strong></p>
<p><strong>正如上面的 oom_malloc 和 oom_ralloc 函数的实现</strong></p>
<p>第一级空间配置器使用如下的别名：<strong>malloc_alloc</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//malloc_alloc 为第一级空间配置器</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="1-4-2-第二级空间配置器"><a href="#1-4-2-第二级空间配置器" class="headerlink" title="1.4.2 第二级空间配置器"></a>1.4.2 第二级空间配置器</h3><p>__default_alloc_template 作为第二级配置器用来处理<strong>避免太多小额区块造成的运行负担。</strong></p>
<p>区块越小，额外负担所占用的比例就越大，就越浪费</p>
<p>第二级配置器的做法：</p>
<ol>
<li>如果区块大于 128 字节，则移交第一级配置器实现</li>
<li>如果区块小于 128 字节，则交由<strong>内存池</strong>管理，这种方法又叫做 <strong>次级配置</strong>，每次分配一大块内存，就会产生并且维护一个<strong>自由链表</strong>。<ol>
<li>如果下次再有相同大小的区块需要分配，则直接从 free-list中取出</li>
<li>如果释放，则直接 回收 free-list 中的某一段</li>
</ol>
</li>
</ol>
<p><strong>配置会自动将任何区块的内存需求量设置为 8 的倍数</strong>：30 -&gt; 32</p>
<p><strong>并且维护16块 free-list，每个块为8字节，每个块都是一个 free-list，free-list总大小即为128字节，每个free-list各自管理自己对应的 8个字节的小额区块</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      自由链表 ： free_list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">obj</span> * free_list_link;</span><br><span class="line">    <span class="type">char</span> client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 union 来节省内存空间</p>
<p><strong>free-list 指向 还没有被分配的内存空间的地址，如果已经分配，则不再指向他们</strong></p>
<hr>
<p><strong>预定义 区块及free-list的个数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;<span class="comment">//上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;<span class="comment">//小型区块的上界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;  <span class="comment">//free_list个数</span></span><br></pre></td></tr></table></figure>
<hr>
<p>此函数表示将<strong>区块的内存需求量都上升为 8 的倍数</strong>（每块总共有8个字节，表示成<strong>能分多少块</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>free-list的定义 : 是一个数组，数组的每一个元素都是一个指针。</strong></p>
<p><strong>根据区块大小，决定使用第几块 free-list</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> obj * __VOLATILE free_list[__NFREELISTS]; <span class="comment">//链表：指针数组</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//决定使用第几号 free_list  从1开始</span></span><br><span class="line">  <span class="function"><span class="type">static</span>  <span class="type">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>)/__ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Chunk allocation state.</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *start_free;  <span class="comment">//内存池起始位置</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *end_free;    <span class="comment">//内存池结束位置</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> heap_size;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="1-4-2-1-空间配置函数-allocate"><a href="#1-4-2-1-空间配置函数-allocate" class="headerlink" title="1.4.2.1 空间配置函数 allocate"></a>1.4.2.1 空间配置函数 allocate</h4><p>allocate的执行过程：</p>
<ol>
<li>如果需要分配的空间 n超过了128个字节的大小，则就转到第一级空间配置器的实现上。</li>
<li>然后再从16个 free-list中选择适当的一个。</li>
<li>如果free-list中有可用的区块，则直接拿来用；否则就把区块的大小上调至 8 的倍数，然后再<strong>refill</strong>重新填充 free-list。</li>
<li><p>然后调整 free-list 为<strong>选出第 n 个区块</strong>后的下一个free-list。</p>
</li>
<li><p>最后取出 result 指向的第 n 个区块的空间起始地址</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    空间配置函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj ** my_free_list;<span class="comment">//二级指针</span></span><br><span class="line">    obj * result;</span><br><span class="line">    <span class="comment">//大于128 就调用第一级配置器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        <span class="keyword">return</span>(malloc_alloc::<span class="built_in">allocate</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从16个 free_list中选择一个使用</span></span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">    result = *my_free_list;<span class="comment">//result指向当前选择的自由链表</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n));<span class="comment">//free_list全为空， 准备重新填充free-list</span></span><br><span class="line">        <span class="keyword">return</span> r; <span class="comment">//返回起始地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出了 result这一块， 因此 free-list往后连接，跳过result这一块</span></span><br><span class="line">    *my_free_list = result -&gt; free_list_link;</span><br><span class="line">    <span class="keyword">return</span> (result);<span class="comment">//取出该块起始地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="1-4-2-2-空间释放函数-deallocate"><a href="#1-4-2-2-空间释放函数-deallocate" class="headerlink" title="1.4.2.2 空间释放函数 deallocate"></a>1.4.2.2 空间释放函数 deallocate</h4><p>回收区块：</p>
<ol>
<li>如果回收大于 128 个字节，则转到第一级空间配置器</li>
<li>寻找对应的 free-list区块</li>
<li><strong>把 p 指向的某一个区块插入到free-list中</strong>：<ol>
<li>首先q的next地址为free-list对应的下一个区块</li>
<li>free-list的当前区块转为 q区块</li>
<li>其实就是完成了链表的<strong>中间插入</strong>。</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//释放空间</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj *q = (obj *)p;</span><br><span class="line">    obj ** my_free_list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//大于128调用第一级配置器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES) &#123;</span><br><span class="line">        malloc_alloc::<span class="built_in">deallocate</span>(p, n);<span class="comment">//释放从p开始的 n 个元素的空间</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);<span class="comment">//寻找对应的free_list</span></span><br><span class="line">    <span class="comment">//调整list 回收区块</span></span><br><span class="line">    q -&gt; free_list_link = *my_free_list;</span><br><span class="line">    *my_free_list = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="1-4-2-3-重新填充-refill"><a href="#1-4-2-3-重新填充-refill" class="headerlink" title="1.4.2.3 重新填充 refill"></a>1.4.2.3 重新填充 refill</h4><p>前面讲到从free-list中取出第 n 个区块的区块，万一free-list中已经没有了可以用的区块，则需要<strong>重新填充 free-list 自由链表</strong></p>
<ol>
<li>从内存池中取出<strong>nobjs个区块</strong>，作为free-list的新节点，nobjs是引用的方式传递的。</li>
<li>如果只获得了一个区块，则直接分配给调用者用，free-list无需新的区块，通过返回 chunk 给到allocate的返回值；否则准备调整free-list，纳入新的节点。</li>
<li>然后在 chunk 空间内建立 free-list</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回一个大小为n的对象，并且为free_list增加节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">refill</span>(<span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//nobjs通过传递引用的方式 来取得nobjs个区块作为free_list的新节点</span></span><br><span class="line">    <span class="type">char</span> * chunk = <span class="built_in">chunk_alloc</span>(n, nobjs);</span><br><span class="line"></span><br><span class="line">    obj * __VOLATILE * my_free_list;</span><br><span class="line">    obj * result;</span><br><span class="line">    obj * current_obj, * next_obj;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);<span class="comment">//只获得一个区块，直接返回给调用者</span></span><br><span class="line">    <span class="comment">//多个区块：调整free_list  纳入新节点</span></span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//在chunk空间里建立free_List </span></span><br><span class="line">      result = (obj *)chunk;</span><br><span class="line">      *my_free_list = next_obj = (obj *)(chunk + n);<span class="comment">//free_list指向新配置的空间（取自内存池）</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//将free_list各个节点串联起来</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">1</span>; ; i++) &#123;</span><br><span class="line">        current_obj = next_obj;</span><br><span class="line">        next_obj = (obj *)((<span class="type">char</span> *)next_obj + n);</span><br><span class="line">        <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">            current_obj -&gt; free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current_obj -&gt; free_list_link = next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="1-4-2-4-内存池-chunk-alloc"><a href="#1-4-2-4-内存池-chunk-alloc" class="headerlink" title="1.4.2.4 内存池 chunk_alloc"></a>1.4.2.4 内存池 chunk_alloc</h4><ol>
<li>我们的<strong>内存池</strong>一定会尝试拥有一个 <strong>大小为单个节点空间的 20倍的一个内存空间（所以才叫做内存池）</strong></li>
<li>如果内存池的剩余空间大于这20倍的空间，则<strong>内存池容量充足</strong>，直接全部保存下来</li>
<li>如果内存池的剩余空间只能容纳小于20个，但是大于1个空间。则内存池会计算出最大的块数与<strong>最大能用的空间，把这剩余的空间全部保存下来</strong></li>
<li>如果一个节点空间也容纳不了。则尝试从heap堆中取得空间，则<strong>需要从堆中申请 2倍的 20倍的节点的空间+堆的额外空间</strong></li>
<li>最后调整堆空间，递归调用该函数，直到获取到了空间或者抛出异常为止。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存池</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span>&amp; nobjs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">char</span>* result;</span><br><span class="line">		<span class="type">size_t</span> total_bytes = size * nobjs;<span class="comment">//总的需要分配的大小  *20倍</span></span><br><span class="line">		<span class="type">size_t</span> pool_bytes_left = end_free - start_free;<span class="comment">//内存池剩余空间</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pool_bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">			<span class="comment">//内存池剩余容量充足 可以容纳20个节点</span></span><br><span class="line">			result = start_free;<span class="comment">//起始</span></span><br><span class="line">			start_free += total_bytes;<span class="comment">//total_bytes全部分配</span></span><br><span class="line">			<span class="keyword">return</span>(result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pool_bytes_left &gt;= size) &#123;</span><br><span class="line">			<span class="comment">//内存池剩余容量不能容纳全部，但是可以容纳 1个 及以上的块的空间</span></span><br><span class="line">			<span class="comment">//nobjs是引用类型，修改为实际能够供应的区块数</span></span><br><span class="line">			nobjs = pool_bytes_left / size;<span class="comment">//最大能容纳的n</span></span><br><span class="line">			total_bytes = size * nobjs;<span class="comment">//最大能分配的空间</span></span><br><span class="line">			result = start_free;<span class="comment">//起始地址空间</span></span><br><span class="line">			start_free += total_bytes;<span class="comment">//最多能容纳的total_bytes全部分配</span></span><br><span class="line">			<span class="keyword">return</span>(result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//一个块都容纳不了！ 则尝试heap中配置</span></span><br><span class="line">			<span class="comment">//新的空间大小为原始需要分配的空间大小的两倍</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//从heap上分配的空间大小： 2*所需节点空间大小*20+额外空间</span></span><br><span class="line">			<span class="type">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">			<span class="comment">//内存池还有一点剩余，但是不够一个节点的空间</span></span><br><span class="line">			<span class="keyword">if</span> (pool_bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				Area* <span class="keyword">volatile</span>* my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(pool_bytes_left);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//将内存池中的剩余空间全部编入</span></span><br><span class="line">				((Area*)start_free)-&gt;next = *my_free_list;</span><br><span class="line">				*my_free_list = (Area*)start_free;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			start_free = (<span class="type">char</span>*)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;<span class="comment">//malloc失败，说明heap上没有足够空间分配给我们了</span></span><br><span class="line">				Area* <span class="keyword">volatile</span> * my_free_list, * p;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt;= (<span class="type">size_t</span>)__MAX_BYTES; i += (<span class="type">size_t</span>)__ALIGN) &#123;</span><br><span class="line">					my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(i);</span><br><span class="line">					p = *my_free_list;</span><br><span class="line">					<span class="keyword">if</span> (<span class="number">0</span> != p) &#123;</span><br><span class="line">						*my_free_list = p-&gt;next;</span><br><span class="line">						start_free = (<span class="type">char</span>*)p;</span><br><span class="line">						end_free = start_free + i;</span><br><span class="line">						<span class="comment">//递归调用自己，修复nobjs</span></span><br><span class="line">						<span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				一点内存都没有了</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">				<span class="comment">//最后调用第一级配置器，看看能否得到改善</span></span><br><span class="line">				start_free = (<span class="type">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(bytes_to_get);</span><br><span class="line">			&#125;</span><br><span class="line">			heap_size += bytes_to_get;<span class="comment">//调整堆空间</span></span><br><span class="line">			end_free = start_free + bytes_to_get;</span><br><span class="line">			<span class="keyword">return</span> (<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-2-5-操作举例"><a href="#1-4-2-5-操作举例" class="headerlink" title="1.4.2.5 操作举例"></a>1.4.2.5 操作举例</h4><p><strong>我们直接拿第二级空间配置器alloc来举一个例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alloc all;</span><br><span class="line"><span class="type">int</span>* b = (<span class="type">int</span>*)all.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">*b = <span class="number">10</span>;</span><br><span class="line">all.<span class="built_in">deallocate</span>(b, <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span>* c = (<span class="type">int</span>*)all.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">all.<span class="built_in">deallocate</span>(c, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span> b;</span><br></pre></td></tr></table></figure>
<p>我们从最上面开始执行，它会如何操作呢？</p>
<p>首先执行：int<em> b = (int</em>)all.allocate(1);进入<strong>allocate函数</strong>：</p>
<p>要分配一个元素的空间，但是初始的时候肯定自由链表是NULL的，所以<strong>首先一定会直接进入 refill 函数里，填充free-list</strong></p>
<p>进入 refill函数：<strong>refill函数作用：取出内存并且填充free-list空间</strong></p>
<ol>
<li><p>refill<strong>直接进入 memory内存池</strong>中 尝试取得内存空间，进入 chunk_alloc函数：</p>
<ol>
<li>总的需要分配的大小为<strong>所需要的单个节点的20倍（单个节点的对齐为8）</strong>，因此<strong>total_bytes=160</strong>，但是v第一次内存池的空间为0，所以会进入else里面从heap中尝试开辟空间。</li>
<li>heap中需要开辟的空间为<strong>total_bytes的两倍再加上堆的额外空间</strong>，使用malloc分配内存，赋值给<strong>start_free</strong></li>
<li>分配成功，分配给heap空间，调整start_free与end_free，然后进入递归。</li>
<li>再次回到 chunk_alloc 函数中，此时内存池的空间为 320，足够所需要的160，因此赋值result为当前可用空间的地址，返回result。</li>
</ol>
</li>
<li><p>回到refill 中，chunk表示内存池的首地址。首先result表示地址空间的首地址，即<strong>取出一块8字节</strong>（内存对齐规则），表示我们将要取出的，<strong>然后再把剩下的19块填充到 自由链表 中</strong></p>
</li>
<li>然后从第二块开始进行<strong>块的尾插入链表</strong>，我们之前取出的result直接返回即可。</li>
<li>回到 allocate函数里，返回的 r 就是我们的空间的首地址，返回即可。</li>
</ol>
<hr>
<p><strong>然后我们准备销毁b的空间：</strong></p>
<ol>
<li>进入deallocate函数，寻找对应的free-list块为第0块</li>
<li>然后把q块<strong>头插</strong>入为自由链表的头，相当于完成了q所指的块空间的回收，自由链表又有了20个块。</li>
</ol>
<p><strong>然后我们打算对c分配空间：</strong></p>
<ol>
<li>进入allocate函数，发现自由链表存在空余的块空间，因此无需进入refill重新填充</li>
<li>result获得当前能够使用的块空间的首地址，直接返回即可。</li>
<li>然后自由链表失去了这个块，因此跳过这个块，重新调整自由链表的指向。</li>
</ol>
<p><strong>同理我们销毁c的空间</strong>：直接进入deallocate函数，然后把c所指向的块回收，然后自由链表重新获得了此块的空间。</p>
<p>最后我们delete整个b，因为这个内存池是由b创建的，因此我们销毁delete b之后的，b所指向的空间就会被销毁，恰好b的空间为第一个自由链表的所有空间。</p>
<h4 id="1-4-2-6-关于内存池的一些问题"><a href="#1-4-2-6-关于内存池的一些问题" class="headerlink" title="1.4.2.6 关于内存池的一些问题"></a>1.4.2.6 关于内存池的一些问题</h4><p><strong><em>STL内存配置器有没有内存泄漏？</em></strong></p>
<p>看了源码后很多人疑惑为什么在该Allocator的实现里只有对内存池malloc的代码，<strong>没看到类似free这样释放内存的代码</strong>，甚至该Allocator类都没有析构函数，这样<strong>不是会存在内存泄漏</strong>吗？</p>
<p>其实不然。</p>
<p>对于由链表维护的内存，其内存的释放工作应该是上一层调用者负责，比如容器Vector在析构函数中就将其申请的所有capacity大小的内存释放。相反内存池的中的内存将会一直保留直到程序退出。有的同学可能会认为“这不就是内存泄漏吗？比如创建了一个Vector变量，到Vector析构了之后再内存中竟然有一块内存没有被系统回收，这不是memory leak吗”。其实不然：</p>
<ol>
<li><strong>申请的内存没有被及时释放 不等于 内存泄漏</strong></li>
</ol>
<p>在单线程中，由于该Allocator中记录内存池起始的指针是<strong>static静态类型</strong>，所以只要是你在同一个线程中，<strong>无论你创建多少个Allocator，记录内存池的变量都是同一个</strong>，换句话说，当下次再创建Vector时，还是使用上一次使用的那个。也就是说他的存在时有意义的，这也是cache或memory pool的意义所在！</p>
<ol>
<li><strong>该内存池不会疯狂野生长</strong></li>
</ol>
<p>这个内存池的空间其实是很小的，因为大于128Byte的内存申请都直接转调了malloc，从源码中也可以看出，内存池每次重新灌水的新容量是2*total_size + round_up(heap_size &gt;&gt; 4)。</p>
<p><strong>内存池的存在是为了避免大量内存碎片的产生，代价是管理内存所需要多付出的时间和空间消耗。</strong></p>
<p>以上就是内存池一种存在直至程序退出的原因。</p>
<hr>
<h2 id="1-5-内存基本操作函数"><a href="#1-5-内存基本操作函数" class="headerlink" title="1.5 内存基本操作函数"></a>1.5 内存基本操作函数</h2><p>STL有五个非常重要的全局函数：</p>
<ol>
<li><strong>用于构造的construct函数</strong></li>
<li><strong>用于析构的destroy函数</strong></li>
<li>uninitialized_copy ：copy</li>
<li>uninitialized_fill：fill</li>
<li>uninitialized_fill_n：fill_n</li>
</ol>
<p><strong>前两个已经在对象的构造与析构中讲过了</strong></p>
<p>另外的三个函数将在本节讲解。</p>
<hr>
<h3 id="1-5-1-uninitialized-copy"><a href="#1-5-1-uninitialized-copy" class="headerlink" title="1.5.1 uninitialized_copy"></a>1.5.1 uninitialized_copy</h3><p>uninitialized_copy函数能够使得<strong>内存的配置</strong>和<strong>对象的构造</strong>分离开。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator</span></span><br><span class="line"><span class="function">  <span class="title">uninitialized_copy</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                     ForwardIterator result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_copy(first, last, result, <span class="built_in">value_type</span>(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 first到 last 迭代器范围的元素拷贝到 result所指向的位置。</p>
<p>即 该函数将 [first，last）范围内的元素 <strong>复制一份</strong>，并把这些 复制品放入 result的空间里。</p>
<p>针对输入范围的每一个迭代器 i ，construct 都会执行如下操作：</p>
<ul>
<li>new (ptr) T(val)</li>
<li>constuct（&amp;<em>(result+(i-first)),\</em>i)，产生 *i 的复制品，放置于输出位置 result后的相对位置中</li>
</ul>
<p>在实现任何一个容器的构造函数的时候，通常会有两个步骤：</p>
<ol>
<li>配置内存空间的大小</li>
<li><strong>使用 uninitialized_copy来在该内存区块上构造元素</strong></li>
</ol>
<p>uninitialized_copy 中调用的函数：</p>
<p>该函数 使用__type_traits 操作来推断出迭代器所指的元素类型是不是POD类型</p>
<ul>
<li>如果是 POD  __true_type：则<strong>拷贝时执行最简单的内存拷贝</strong></li>
<li>如果是 非POD __false_type：则<strong>需要调用相应的构造函数来逐一拷贝</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardIterator</span><br><span class="line">__uninitialized_copy(InputIterator first, InputIterator last,</span><br><span class="line">                     ForwardIterator result, T*) &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::is_POD_type is_POD;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_copy_aux(first, last, result, <span class="built_in">is_POD</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardIterator </span><br><span class="line">__uninitialized_copy_aux(InputIterator first, InputIterator last,</span><br><span class="line">                         ForwardIterator result,</span><br><span class="line">                         __true_type) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">copy</span>(first, last, result);<span class="comment">//是POD类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line">ForwardIterator </span><br><span class="line">__uninitialized_copy_aux(InputIterator first, InputIterator last,</span><br><span class="line">                         ForwardIterator result,</span><br><span class="line">                         __false_type) &#123;</span><br><span class="line">  ForwardIterator cur = result;<span class="comment">//不是POD类型</span></span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; first != last; ++first, ++cur)</span><br><span class="line">      <span class="built_in">construct</span>(&amp;*cur, *first);<span class="comment">//逐一进行拷贝</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(<span class="built_in">destroy</span>(result, cur));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-2-uninitialized-fill"><a href="#1-5-2-uninitialized-fill" class="headerlink" title="1.5.2 uninitialized_fill"></a>1.5.2 uninitialized_fill</h3><p>他的作用是为指定范围的元素赋予一个值：[first,last) 赋予初始值 val</p>
<p>与 uninitialized_copy类似，如果迭代器范围的每一个元素都指向一个未知的区域，那么会对迭代器范围的每一个元素都调用一次： construct(&amp;*i,val)，然后在这个位置上产生一个值val</p>
<p>同样使用value_type推断出迭代器所指元素的类型，然后传入__uninitialized_fill。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">uninitialized_fill</span><span class="params">(ForwardIterator first, ForwardIterator last, </span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">  __uninitialized_fill(first, last, x, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<strong>uninitialized_fill函数内部会使用  \</strong>type_traits推断类型是否为POD类型。</p>
<ul>
<li>如果是POD类型，则直接采用最简单的fill 填充的方式（STL算法）</li>
<li>如果不是POD类型，则对每一个元素调用其<strong>构造函数</strong>。</li>
</ul>
<p><strong>使用 first!= last ，first++ 作为for循环的参数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, </span><br><span class="line">                         <span class="type">const</span> T&amp; x, __true_type)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">fill</span>(first, last, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, </span><br><span class="line">                         <span class="type">const</span> T&amp; x, __false_type)</span><br><span class="line">&#123;</span><br><span class="line">  ForwardIterator cur = first;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; cur != last; ++cur)</span><br><span class="line">      <span class="built_in">construct</span>(&amp;*cur, x);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(<span class="built_in">destroy</span>(first, cur));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T1</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __uninitialized_fill(ForwardIterator first, ForwardIterator last, </span><br><span class="line">                                 <span class="type">const</span> T&amp; x, T1*) &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD;</span><br><span class="line">  __uninitialized_fill_aux(first, last, x, <span class="built_in">is_POD</span>());               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外 fill 的实现非常简单：<strong>其实就是往迭代器的范围赋值而已</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    *first = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="1-5-3-uninitialized-fill-n"><a href="#1-5-3-uninitialized-fill-n" class="headerlink" title="1.5.3 uninitialized_fill_n"></a>1.5.3 uninitialized_fill_n</h3><p>该函数接受三个参数，一个 first 表示起始位置；一个 n，表示操作的数量；一个val。</p>
<p>从first迭代器处开始，操作 n 个地址空间，把val赋值给这些位置。</p>
<p>其实与上面的uninitialized_fill是一样的，只不过上面表示<strong>范围</strong>，这个表示一个<strong>数量</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">uninitialized_fill_n</span><span class="params">(ForwardIterator first, Size n,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理使用 value_type 推断出迭代器的元素类型，然后再判断其是否为POD类型；</p>
<ul>
<li>如果是，则直接 fill_n 即可</li>
<li>如果不是，则需要调用其 构造函数</li>
</ul>
<p><strong>使用 n— ，当n=0时停止，这个for来作为循环。</strong></p>
<hr>
<p>注意：上面的三个函数都具有一个特性：<strong>commit or rallback</strong></p>
<p><strong>即要么对范围的操作全部成功（全部赋值成功），要么全部不成功</strong></p>
<p>如果不成功，会 抛出异常，然后调用destroy，将全部的成功的元素析构掉，因为他已经失败了，<strong>不允许他一半成功，一半失败</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">destroy</span>(result, cur);<span class="comment">//uninitialized_copy</span></span><br><span class="line"><span class="built_in">destroy</span>(first, cur);<span class="comment">//uninitialized_fill</span></span><br><span class="line"><span class="built_in">destroy</span>(first, cur);<span class="comment">//uninitialized_fill_n</span></span><br></pre></td></tr></table></figure>
<p>destroy 接受一个范围，然后就是我们上面所讨论的destroy的内容了</p>
<hr>
<p><img src="https://great.wzznft.com/i/2023/03/10/jymw4j.png" alt=""></p>
]]></content>
      <categories>
        <category>STL源码剖析</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法例题与讲解（2）</title>
    <url>/2023/03/06/%E8%B4%AA%E5%BF%83%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="P1478-陶陶摘苹果（升级版）"><a href="#P1478-陶陶摘苹果（升级版）" class="headerlink" title="P1478 陶陶摘苹果（升级版）"></a>P1478 陶陶摘苹果（升级版）</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE0Nzg=">P1478 陶陶摘苹果（升级版）<i class="fa fa-external-link-alt"></i></span></p>
<p>直接将摘苹果所需要的力气按照从到大排序即可。</p>
<p>那么这样，<strong>摘的最轻松的苹果不摘白不摘</strong>，摘它这么轻松，干嘛不摘。</p>
<p>如果遇到了 <strong>足够力气摘得苹果，但是高度够不到，不摘不就好了</strong>，又不损失什么，反正我们是按照花费得力气排序的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;apple[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.y&lt;b.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;apple[i].x&gt;&gt;apple[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(apple+<span class="number">1</span>,apple+<span class="number">1</span>+n,comp);</span><br><span class="line">    <span class="type">int</span> sum=a+b;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (apple[i].x&lt;=sum &amp;&amp; apple[i].y&lt;=m)</span><br><span class="line">        &#123;</span><br><span class="line">            m-=apple[i].y;</span><br><span class="line">            ans+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P5019-NOIP2018-提高组-铺设道路"><a href="#P5019-NOIP2018-提高组-铺设道路" class="headerlink" title="P5019 [NOIP2018 提高组] 铺设道路"></a>P5019 [NOIP2018 提高组] 铺设道路</h1><hr>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDUwMTk=">P5019 [NOIP2018 提高组] 铺设道路<i class="fa fa-external-link-alt"></i></span></p>
<p>这是一种很重要的贪心问题！</p>
<p>处理连续的一段区间，让这个区间里的数字做一些操作。</p>
<p>常见的这类问题有：</p>
<ol>
<li>这段区间的每个值都减少 1，直到为0为止，操作的区间的数字不能是0</li>
<li>发牌，每次从区间中发出一些牌，只能连续的发，不能跳跃，求出发完所有牌的最小发牌次数</li>
</ol>
<p>总结为一类问题：<strong>求 操作每个元素都不为零 的一段区间，使得整个序列所有的元素都为0的最少操作次数，每次操作只能操作一段区间</strong></p>
<p>回到这题：贪心算法如何求解？</p>
<p>可以注意到如果第 i 个的元素大于第 i-1 个位置的元素，<strong>则对 i 和 i-1 位置的操作次数一定是 nums[i] 减去 nums[i-1]</strong></p>
<p>即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i]&gt;nums[i<span class="number">-1</span>]) ans+=nums[i]-nums[i<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>注意到 ： i 位置的元素一定比 i-1 位置的元素大，因此无论如何你一定要 对 i 位置的元素操作为0，所以对 i 位置的元素操作相当于免费操作了 i -1 位置的元素。</p>
<p>类似于如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 2 5 3 5 </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 0 2 3 5</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 0 2 1 3</span><br></pre></td></tr></table></figure>
<p>最后遍历完整个序列之后，ans+ =nums[1]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 </span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]&lt;nums[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=nums[i+<span class="number">1</span>]-nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans+nums[<span class="number">1</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1208-USACO1-3-混合牛奶-Mixing-Milk"><a href="#P1208-USACO1-3-混合牛奶-Mixing-Milk" class="headerlink" title="P1208 [USACO1.3]混合牛奶 Mixing Milk"></a>P1208 [USACO1.3]混合牛奶 Mixing Milk</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEyMDg=">P1208 [USACO1.3]混合牛奶 Mixing Milk<i class="fa fa-external-link-alt"></i></span></p>
<p>贪心思路：直接按照牛奶的<strong>单价</strong>进行排序，如果<strong>单价有一样的，则按照 量多的在前面</strong></p>
<p>很明显，量多的并且单价还便宜的一定是最优的。</p>
<p>因此直接AC：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,p;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.a&lt;b.a) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.a==b.a) <span class="keyword">return</span> a.p&gt;b.p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;node[i].a&gt;&gt;node[i].p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node+<span class="number">1</span>,node+<span class="number">1</span>+m,comp);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (node[i].p&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            n-=node[i].p;<span class="comment">//购买了p个</span></span><br><span class="line">            ans+=node[i].a*node[i].p;<span class="comment">//p种的总成本</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans+=node[i].a*n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1094-NOIP2007-普及组-纪念品分组"><a href="#P1094-NOIP2007-普及组-纪念品分组" class="headerlink" title="P1094 [NOIP2007 普及组] 纪念品分组"></a>P1094 [NOIP2007 普及组] 纪念品分组</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwOTQ=">P1094 [NOIP2007 普及组] 纪念品分组<i class="fa fa-external-link-alt"></i></span></p>
<p>很典型的贪心问题：要使得组的数量尽可能少，则组内两个纪念品一定是一个<strong>尽量可能小，一个尽量可能大</strong></p>
<p>这样才满足<strong>一个组的利用率达到最高</strong></p>
<p><strong>即寻找 小于等于最大价值之和的 能够提供最大价值的两个纪念品</strong></p>
<p>则我们<strong>单价</strong>进行排序，<strong>左边尽量小</strong> 和 <strong>右边尽量大</strong> 的在 满足不大于最大价值<strong>限制</strong>的情况下，要组成一组，</p>
<p>如果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (s左 + s右 &gt; limit)</span><br><span class="line">&#123;</span><br><span class="line">	I右--  </span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">	I左++</span><br><span class="line">	I右--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则这样遍历完一遍后，整个序列中满足条件的<strong>两个最优的纪念品就分好了</strong>，则其他的就只能单独一组！</p>
<p>贪心算法的证明， 某大佬的解答：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvaGVpZG91ZG91L3NvbHV0aW9uLXAxMDk0">题解 P1094 【纪念品分组】 - heidoudou 的博客 - 洛谷博客 (luogu.com.cn)<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="type">bool</span> fg[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums+<span class="number">1</span>,nums+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[l]+nums[r]&gt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//不能分组</span></span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            fg[l]=<span class="literal">true</span>,fg[r]=<span class="literal">true</span>;</span><br><span class="line">            r--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dbg(fg,n);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fg[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题训练</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法例题与讲解（1）</title>
    <url>/2023/03/05/%E8%B4%AA%E5%BF%83%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="P2240-部分背包问题"><a href="#P2240-部分背包问题" class="headerlink" title="P2240  部分背包问题"></a>P2240  部分背包问题</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIyNDA=">P2240 【深基12.例1】部分背包问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class="fa fa-external-link-alt"></i></span></p>
<p>有点像01背包，但是又不是，01背包的物品的是不能再分的，而本题的物品是可以<strong>再分的</strong>，因此我们可以根据某个物品的<strong>部分重量和单位价值</strong>算出它的<code>部分最大价值</code>来作为我们选择的物品。</p>
<ol>
<li>首先计算<strong>单位价值</strong> = 总价值 / 总重量</li>
<li>按照贪心的思想，则单位价值大的一定是越优的，因此<strong>排序</strong>，单位价值大的排在前面。</li>
<li>按照单位价值排好序的顺序一个一个物品选，若背包的剩余容量不够则取某个物品的<code>部分最大价值</code>，然后退出即可。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,T;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> w,v,pro;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.pro&gt;b.pro)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;node[i].w&gt;&gt;node[i].v;</span><br><span class="line">        node[i].pro=node[i].v/node[i].w;	<span class="comment">//计算单位价值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node+<span class="number">1</span>,node+<span class="number">1</span>+n,cmp);<span class="comment">//按照单位价值排序</span></span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> temp=T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp&gt;=node[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=node[i].v;</span><br><span class="line">            temp-=node[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans+=(temp*node[i].pro);<span class="comment">//取最大部分价值</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,ans);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1223-排队接水"><a href="#P1223-排队接水" class="headerlink" title="P1223 排队接水"></a>P1223 排队接水</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEyMjM=">排队接水<i class="fa fa-external-link-alt"></i></span></p>
<p> 排队接水：一列人排成一队，接水的人有个<strong>接水的时间</strong>，而其他人都要<strong>等</strong>这个人接完水，然后再轮流接水，已经接完水的就完成任务了，即不需要算在排队等接水的人当中了。</p>
<p>我们要计算n个人的平均接水时间，因此需要把<strong>当前人接水的时间 * 后面等待的总人数</strong></p>
<p>因此我们可以总结出：<strong>最先接水的一定是接水所需时间最少的</strong>。为什么？</p>
<ul>
<li>如果你的接水时间是 1000 ，那么除这个人之外的9个人就需要等待 9 * 1000的时间。</li>
<li>如果你的接水时间是 10 ，那么除这个人之外的9个人就需要等待 9 * 10 的时间。</li>
</ul>
<p><strong>很显然按照接水时间短的先接水的这种做法一定是最优的。</strong></p>
<p>那么就直接按照时间排序即可，然后计算 平均的等待时间，最后再除以一次总人数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N],presum[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num,val;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.val&lt;b.val) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.val==b.val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.num&lt;b.num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        node[i].num=i;</span><br><span class="line">        cin&gt;&gt;node[i].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node+<span class="number">1</span>,node+<span class="number">1</span>+n,comp);<span class="comment">// 按照接水的时间排序，如果时间相等，则按序号</span></span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=(n-i)*node[i].val;<span class="comment">//后面的每个人都需要等这个时间</span></span><br><span class="line">        cout&lt;&lt;node[i].num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,ans/n);<span class="comment">//最后再计算平均值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1   </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1803-凌乱的yyy-线段覆盖"><a href="#P1803-凌乱的yyy-线段覆盖" class="headerlink" title="P1803 凌乱的yyy / 线段覆盖"></a>P1803 凌乱的yyy / 线段覆盖</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE4MDM=">P1803 凌乱的yyy / 线段覆盖<i class="fa fa-external-link-alt"></i></span></p>
<p>这道题其实就是贪心的经典问题：<strong>给出任务的开始和结束时间，求总共能完成的任务的最大数量</strong></p>
<p>贪心思路：</p>
<ul>
<li><strong>结束时间早的一定是最优的（在此不给出证明）</strong></li>
</ul>
<p>过程如下；</p>
<ol>
<li><p>因此把每个任务按照结束时间排序，结束时间早的是最优的。</p>
</li>
<li><p>按照结束时间<strong>早正序</strong>排序，如果下一个任务的开始时间在上一个任务的进行过程中，则说明还没有完成上一个任务，因此跳过这个任务，<strong>只能是下一个任务的开始时间最差的等于上一个任务的结束时间</strong></p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s,e;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.e&lt;=b.e) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;node[i].s&gt;&gt;node[i].e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束时间最早</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fg=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(node+<span class="number">1</span>,node+<span class="number">1</span>+n,comp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">1</span>)<span class="comment">//第一个一定是可以的</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            fg=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (node[i].s&gt;=node[fg].e)	<span class="comment">//如果下一个任务的开始在上一个任务的结束，则可以</span></span><br><span class="line">            &#123;</span><br><span class="line">                fg=i;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1090-NOIP2004-提高组-合并果子"><a href="#P1090-NOIP2004-提高组-合并果子" class="headerlink" title="P1090 [NOIP2004 提高组] 合并果子"></a>P1090 [NOIP2004 提高组] 合并果子</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwOTA=">P1090 [NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G<i class="fa fa-external-link-alt"></i></span></p>
<p>题目让我们求合并两堆的最小花费的总和， 因此我们很容易想到<strong>最小的两堆一起合并一定是最优的</strong></p>
<p><strong>我们便可以想到直接排序即可，花费小的在前面，然后前两个合并成一个，然后再把这个合并的放进去再排序，最后知道这个队列只有一个元素为止，因此我们每次所统计的两堆的和就是最后的答案。</strong></p>
<p>这道题目的思想是很容易的。</p>
<p>但是如何做到 <strong>将两堆取出来合并后的值再放回去</strong> ？ 我们可以想到 堆排序。</p>
<p>进而想到堆排序的一个应用：<strong>优先队列</strong></p>
<p>我们要制造 <strong>小顶堆</strong>，即堆顶元素是最小的，然后取出堆的前两个元素，合并后再<strong>插入堆</strong></p>
<p>优先队列C++：<code>priority_queue</code>小顶堆形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q;</span><br></pre></td></tr></table></figure>
<p>大顶堆形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;int&gt; q;</span><br></pre></td></tr></table></figure>
<p>因此就解决了，当然你也可以<strong>手写堆</strong>，包含构建<strong>初始堆和堆的调整过程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        q.<span class="built_in">push</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">size</span>()==<span class="number">1</span>)<span class="comment">//特判</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;q.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num1=q.<span class="built_in">top</span>();	<span class="comment">//取出最小的</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> num2=q.<span class="built_in">top</span>();	<span class="comment">//取出第二小的</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> sum=num1+num2;</span><br><span class="line">        ans+=sum;<span class="comment">//注意统计res</span></span><br><span class="line">        q.<span class="built_in">push</span>(sum);	<span class="comment">//合并后再插入堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P3817-小A的糖果"><a href="#P3817-小A的糖果" class="headerlink" title="P3817 小A的糖果"></a>P3817 小A的糖果</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MTc=">P3817 小A的糖果<i class="fa fa-external-link-alt"></i></span></p>
<p>让我们求 在相邻的两个盒子的总数不超过 m 的情况下，至少需要吃的数量。</p>
<p>貌似我们可以进行排序？ 从小到大，然后从左往右吃</p>
<p><strong>不可以</strong></p>
<p>我们注意到盒子是有先后顺序的，因此不能够改变位置（当然如果你会排序的做法则当我没说）</p>
<p>我们就直接贪心即可：</p>
<ol>
<li>从左往右遍历，如果当前的盒子 i 的数量 + 后一个盒子 i+1 的数量 超过了规定 m，则我们一定需要在这两个中吃糖果，如何吃呢？<ol>
<li>如果我们选择吃 i ，则 我们只会改变 i+1着一种情况，即 【i，i+1】是一组</li>
<li>但是如果我们吃 i+1，则我们不仅改变了【i，i+1】这一组，还可能改变 【 i+1，i+2】下一组，<strong>因此吃后面的一定是最优的（求最少的吃的数量）</strong></li>
</ol>
</li>
<li>遍历到后面的每个 i 盒子的时候，它的 i -1个位置的盒子数量 一定被上一种情况吃了。但是我们的第 1 个盒子怎么办呢，它可没有前一个？<ol>
<li>我们直接错一下位即可， <strong>让0（实际不存在，从1开始）号盒子 与 1 号成一组，然后我们吃后面的，这样不就吃到 1 号盒子了吗</strong></li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=i<span class="number">-1</span>,b=i;	<span class="comment">//从0开始，则保证了1号也能作为第二个盒子</span></span><br><span class="line">        <span class="keyword">if</span> (nums[a]+nums[b]&gt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//尽量吃第二个</span></span><br><span class="line">            ans+=nums[a]+nums[b]-m;<span class="comment">//两个的总数 - 规定 = 这组中要吃的数量</span></span><br><span class="line">            nums[b]=m-nums[a];	<span class="comment">//全部吃第二个盒子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1106-删数问题"><a href="#P1106-删数问题" class="headerlink" title="P1106 删数问题"></a>P1106 删数问题</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDExMDY=">P1106 删数问题<i class="fa fa-external-link-alt"></i></span></p>
<p>在序列中删除 k 位后能够组成的最小的数。</p>
<p>貌似很简单？ </p>
<p><strong>直接从左往右，碰到一个 i 位置元素如果比 i-1 位置的元素大 ，则删除 i 位置的元素？</strong></p>
<p><strong>错误的</strong>！！</p>
<p>示例：</p>
<p>1 5 9 8 (2) ，删除两个，按照上面的思路，则删除 5 和 9，最后得到 18，但是实际上 15是最优的（删后两个）</p>
<p>1 2 6 5 9 7 （3），删除三个，按照上面的思路，则删除 2 6 和 9，得到了 1 5 7，但是实际上只要 2没被删除则其他的都比这个小。</p>
<p>那么怎么删呢？ 观察一下<strong>式子</strong>，<strong>定义：比两边都大，则此位置为山峰</strong></p>
<p>1 5 9(山峰) 8(山峰)  ：删除<strong>山峰</strong>，得到 1 5</p>
<p><strong>为什么 8 也是山峰，9比8大啊，因为我们提前删除了9，因此 8 的前面是 5。</strong></p>
<p>1 2 6(山峰) 5 9(山峰) 7(山峰)：删除山峰，得到 1 2 5</p>
<p><strong>答案：我们删除山峰位置的元素，则最后的数一定是最小的</strong></p>
<hr>
<p>实际上山峰在此题只需要表示为：<strong>比后面的数大即可</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s);<span class="comment">//原始长度</span></span><br><span class="line">    <span class="keyword">while</span> (k--)<span class="comment">//需要删除 k 个元素，每次循环一次则一定删除一个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i]&gt;s[i+<span class="number">1</span>]) <span class="comment">//如果比后面的数字大，则删除 i 位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//后面的位置元素依次覆盖过来，模拟删除 i 位置元素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;len<span class="number">-1</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    s[j]=s[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len--; <span class="comment">//s长度减1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;len &amp;&amp; s[i]==<span class="string">&#x27;0&#x27;</span>) i++;<span class="comment">//处理前导0，记录前0的数量</span></span><br><span class="line">    <span class="keyword">if</span> (i==len) <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);<span class="comment">//如果前0的数量等于s的长度，则整个都是0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//否则从i位置开始（忽略前0），直到最后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;s[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>刷题训练</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习(4) - git在服务器上的操作</title>
    <url>/2023/03/05/git%E5%AD%A6%E4%B9%A0-4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="1-协议"><a href="#1-协议" class="headerlink" title="1. 协议"></a>1. 协议</h1><p>Git使用四种协议来<strong>传输数据</strong>：</p>
<ol>
<li>本地传输</li>
<li>SSH协议</li>
<li>Git协议</li>
<li>HTTP协议</li>
</ol>
<h2 id="1-1-本地协议"><a href="#1-1-本地协议" class="headerlink" title="1.1 本地协议"></a>1.1 本地协议</h2><p>其实就是硬盘上的另一个目录，其中团队的每个成员都对一个<strong>共享的文件系统具有访问权</strong>。</p>
<p>如果你使用一个共享的文件系统，就可以在<strong>一个本地文件系统中克隆仓库，推送和获取</strong>。克隆的时候只需要将远程仓库的路径作为 URL 使用，比如下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone F:/code/git/Git-test</span><br><span class="line">Cloning into &#x27;Git-test&#x27;...</span><br><span class="line">done.</span><br></pre></td></tr></table></figure>
<p>这样我们就在<strong>本地的文件夹创建了一个具有本地协议的远程仓库</strong></p>
<p>也可以使用<code>file://</code> 的前缀：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone file://F:/code/git/Git-test</span><br><span class="line">Cloning into &#x27;Git-test&#x27;...</span><br><span class="line">remote: Enumerating objects: 35, done.</span><br><span class="line">remote: Counting objects: 100% (35/35), done.</span><br><span class="line">remote: Compressing objects: 100% (25/25), done.</span><br><span class="line">remote: Total 35 (delta 9), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Receiving objects: 100% (35/35), done.</span><br><span class="line">Resolving deltas: 100% (9/9), done.</span><br></pre></td></tr></table></figure>
<p>两种方式的不同：</p>
<ol>
<li>直接使用路径：Git会尝试以<strong>硬链接或者直接复制它文件</strong>。</li>
<li>如果使用file:// ：Git会调用它平时通过<strong>网络来传输数据的工序</strong>，效率相对较低。</li>
</ol>
<p>使用 <code>file://</code> 前缀的主要原因是当你需要一个<strong>不包含无关引用或对象的干净仓库副本</strong>的时候 — 一般指从其他版本控制系统导入的</p>
<hr>
<p>把本地的仓库添加作为你的远程仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add local_proj F:/code/git/Git-test/Git-test</span><br></pre></td></tr></table></figure>
<p>查看所有的远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">local_proj</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<p>现在我们就由 <code>local_proj</code> 和<code>origin</code>两个远程仓库了</p>
<h2 id="1-2-SSH协议"><a href="#1-2-SSH协议" class="headerlink" title="1.2 SSH协议"></a>1.2 SSH协议</h2><p>SSH协议是Git中最常用的协议。</p>
<p>SSH 也是唯一一个<strong>同时支持读写操作的网络协议</strong>，另外两个协议（HTTP和Git）通常是只读的，执行写操作一定是SSH协议。</p>
<p>SSH 同时也是一个验证授权的网络协议；而因为其普遍性，一般架设和使用都很容易。</p>
<p>SSH协议的使用我们都已经很熟悉了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone ssh://git@github.com:luumod/Git-test.git</span><br></pre></td></tr></table></figure>
<p>便可以把我们的GitHub上的仓库克隆到我们的本地。</p>
<p>可以省略<code>ssh://</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:luumod/Git-test.git</span><br></pre></td></tr></table></figure>
<p>通过 SSH 进行访问是安全的 — 所有数据传输都是加密和授权的。</p>
<p>最后，和 Git 及本地协议一样，SSH 也很高效，会在传输之前尽可能压缩数据。</p>
<h2 id="1-3-Git协议"><a href="#1-3-Git协议" class="headerlink" title="1.3 Git协议"></a>1.3 Git协议</h2><p>这是一个包含在 Git 软件包中的特殊守护进程。</p>
<p>打算支持 Git 协议的仓库，需要先创建 <code>git-daemon-export-ok</code> 文件 — 它是协议进程提供仓库服务的必要条件 — 但除此之外该服务没有什么安全措施。</p>
<p>要么所有人都能克隆 Git 仓库，要么谁也不能。</p>
<p>Git协议是最快的<strong>传输协议</strong>，对一个不需要对读操作进行授权的项目来说，架设Git协议是一个不错的选择。</p>
<p>Git 协议消极的一面是缺少授权机制。用 Git 协议作为访问项目的唯一方法通常是不可取的。一般的做法是，同时提供 SSH 接口，让几个开发者拥有推送（写）权限，其他人通过 <code>git://</code> 拥有只读权限。 Git 协议可能也是最难架设的协议。它要求有单独的守护进程，需要定制 — 我们将在本章的 “Gitosis” 一节详细介绍它的架设 — 需要设定 <code>xinetd</code> 或类似的程序，而这些工作就没那么轻松了。该协议还要求防火墙开放 9418 端口，而企业级防火墙一般不允许对这个非标准端口的访问。大型企业级防火墙通常会封锁这个少见的端口。</p>
<h2 id="1-4-HTTP-S协议"><a href="#1-4-HTTP-S协议" class="headerlink" title="1.4 HTTP/S协议"></a>1.4 HTTP/S协议</h2><p>HTTP或者HTTPS协议具有非常高的<strong>简洁性</strong>。</p>
<p>我们把Git的裸仓库文件放在http的根目录下，配置一个特定的 <code>post-update</code>挂钩就可以实现</p>
<ol>
<li>配置 <code>post-update</code>挂钩</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd .git</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mv hooks/post-update.sample hooks/post-update</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chmod a+x hooks/post-update</span><br></pre></td></tr></table></figure>
<p><code>mv</code>命令是把source文件改名为 dest，即<code>post-update.sample</code>改为<code>post-update</code></p>
<p><code>chmod a+x</code>是指all所有人都可以x执行excu 这个<code>post-update</code></p>
<p>在你向仓库推送的时候，<code>post-update</code>会执行：    <code>git update-server-info</code>来确保通过 HTTP 的获取和克隆正常工作。</p>
<p>之后我们便可以通过HTTP来克隆仓库了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone http://example.com/gitproject.git</span><br></pre></td></tr></table></figure>
<p>通过 HTTP 进行推送操作也是可能的，不过这种做法不太常见，并且牵扯到复杂的 WebDAV 设定。</p>
<h1 id="2-服务器上部署Git"><a href="#2-服务器上部署Git" class="headerlink" title="2. 服务器上部署Git"></a>2. 服务器上部署Git</h1><p>首先把现有仓库导出为<strong>裸仓库</strong>，即一个不含当前工作目录的仓库：</p>
<p>使用 <code>--bare</code> ，裸仓库的目录名以 <code>.git</code>结尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone --bare Git-test Git-test.git</span><br><span class="line">Cloning into bare repository &#x27;Git-test.git&#x27;...</span><br><span class="line">done.</span><br></pre></td></tr></table></figure>
<p><code>clone</code>其实就是 相当于 <code>git init</code> 和<code>git fetch</code></p>
<p>先由它建立一个空目录，而之后传输数据对象的操作并无任何输出，只是悄悄在幕后执行。</p>
<p><strong>它仅取出 Git 仓库的必要原始数据，存放在该目录中，而不会另外创建工作目录。</strong></p>
<p>有了裸仓库的副本后，剩下的就是把它放到服务器上并设定相关协议。假设一个域名为 <code>git.example.com</code> 的服务器已经架设好，并可以通过 SSH 访问，我们打算把所有 Git 仓库储存在 <code>/opt/git</code> 目录下。只要把裸仓库复制过去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ scp -r my_project.git user@git.example.com:/opt/git</span><br></pre></td></tr></table></figure>
<p>现在，所有对该服务器有 SSH 访问权限，并可读取 <code>/opt/git</code> 目录的用户都可以用下面的命令克隆该项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone user@git.example.com:/opt/git/my_project.git</span><br></pre></td></tr></table></figure>
<p>如果某个 SSH 用户对 <code>/opt/git/my_project.git</code> 目录有写权限，那他就有推送权限。如果到该项目目录中运行 <code>git init</code> 命令，并加上 <code>--shared</code> 选项，那么 Git 会自动修改该仓库目录的组权限为可写（译注：实际上 <code>--shared</code> 可以指定其他行为，只是默认为将组权限改为可写并执行 <code>g+sx</code>，所以最后会得到 <code>rws</code>。）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh user@git.example.com</span><br><span class="line">$ cd /opt/git/my_project.git</span><br><span class="line">$ git init --bare --shared</span><br></pre></td></tr></table></figure>
<p>由此可见，根据现有的 Git 仓库创建一个裸仓库，然后把它放上你和同事都有 SSH 访问权的服务器是多么容易。现在已经可以开始在同一项目上密切合作了。</p>
<p>值得注意的是，这的的确确是架设一个少数人具有连接权的 Git 服务的全部 — 只要在服务器上加入可以用 SSH 登录的帐号，然后把裸仓库放在大家都有读写权限的地方。一切都准备停当，无需更多。</p>
<p>下面的几节中，你会了解如何扩展到更复杂的设定。这些内容包含如何避免为每一个用户建立一个账户，给仓库添加公共读取权限，架设网页界面，使用 Gitosis 工具等等。然而，只是和几个人在一个不公开的项目上合作的话，仅仅是一个 SSH 服务器和裸仓库就足够了，记住这点就可以了。</p>
<h1 id="3-SSH公钥的创建"><a href="#3-SSH公钥的创建" class="headerlink" title="3. SSH公钥的创建"></a>3. SSH公钥的创建</h1><p>查看是否有SSH公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">id_rsa  id_rsa.pub  known_hosts  known_hosts.old</span><br></pre></td></tr></table></figure>
<p>有 <code>.pub</code> 后缀的文件就是公钥，另一个文件则是密钥。</p>
<p>如果没有，则使用下面的命令来创建 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /Users/schacon/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local</span><br></pre></td></tr></table></figure>
<p>它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。</p>
<p>现在，所有做过这一步的用户都得把它们的公钥给你或者 Git 服务器的管理员（假设 SSH 服务被设定为使用公钥机制）。他们只需要复制 <code>.pub</code> 文件的内容然后发邮件给管理员。</p>
]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习（3）- Git分支的操作管理与工作流程</title>
    <url>/2023/03/04/git%E5%AD%A6%E4%B9%A0-3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="1-Git分支的概念"><a href="#1-Git分支的概念" class="headerlink" title="1. Git分支的概念"></a>1. Git分支的概念</h1><p>在Git提交的时候，会保存一个<strong>指向文件快照的指针</strong>，包含本次提交的作者等相关信息。</p>
<p>同时也包含多个指向文件内容快照的父指针。</p>
<p>我们首先创建三个文件，然后执行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;my first project&#x27;</span><br></pre></td></tr></table></figure>
<p>暂存操作会对每一个文件计算<strong>校验和</strong>（即第一章中提到的 SHA-1 哈希字串），然后把当前版本的<strong>文件快照保存到 Git 仓库中</strong>（Git 使用 blob 类型的对象存储这些快照）</p>
<p>此时Git仓库中的五个对象:</p>
<ol>
<li>三个 blob 类型的对象</li>
<li>一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象；</li>
<li>以及一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 <strong>commit 对象</strong>。</li>
</ol>
<p><strong>Git 的分支 本质上就是指向一个commit对象的可变指针</strong></p>
<p>Git使用master作为分支的<strong>默认名字</strong>，并且<strong>master始终指向你最后一次提交的对象</strong>，他会自己更新</p>
<hr>
<p>使用Git创建一个新的分支：叫做testing</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch testing</span><br></pre></td></tr></table></figure>
<p><strong>则testing 会和 master一样，一起指向 最后一次提交的commit对象，testing 不会覆盖 master</strong></p>
<p>Git如何知道你在哪个分支上工作的呢？</p>
<ul>
<li>Git有一个HEAD指针：<strong>指向你正在工作中的本地分支的指针</strong></li>
</ul>
<p>运行<code>git branch</code> 之后我们仅仅是创建了一个分支，但是<strong>实际工作分支仍然是默认的master，即我们的HEAD指针指向master</strong>，<strong>我们可以使用下面的命令切换分支</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout testing</span><br></pre></td></tr></table></figure>
<p><strong>这样我们的HEAD指针就指向了 testing分支</strong></p>
<hr>
<p>此时我们<strong>再次提交</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;second pro&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>此时我们的工作分支testing 和HEAD指针会指向我们最新的这次提交，而master分支指向的是之前的提交。</strong></p>
<p>即我们的每次提交只会改变当前工作分支与 HEAD指针，其他分支保存的仍是之前的历史版本</p>
<p>如果此时我们输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<p>则我们现在的工作目录是master分支，HEAD指针也指向master。</p>
<p><strong>这就是实现了在历史版本中切换的目的！也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</strong></p>
<hr>
<p>此时我们在master分支中进行提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;three pro&#x27;</span><br></pre></td></tr></table></figure>
<p>就会产生如下效果：</p>
<p>我们的这次提交 与 上一次的 second pro 处于同一层中，即在树结构中他们的父节点都是之前master和HEAD所在的位置，即之前的节点拥有了两个父节点</p>
<blockquote>
<p>由于 Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。</p>
</blockquote>
<p><strong>Git 在每次提交时都记录了祖先信息</strong></p>
<h1 id="2-分支的新建与合并"><a href="#2-分支的新建与合并" class="headerlink" title="2. 分支的新建与合并"></a>2. 分支的新建与合并</h1><h2 id="2-1-新建与切换分支"><a href="#2-1-新建与切换分支" class="headerlink" title="2.1 新建与切换分支"></a>2.1 新建与切换分支</h2><p>首先我们已经有了几次的提交信息</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/6xm60on.png" alt=""></p>
<p><strong>现在我们接到了一个需求：我们需要实现一个新的功能，则我们需要创建一个新的分支</strong></p>
<p>新建一个分支并且切换到该分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b iss53</span><br></pre></td></tr></table></figure>
<p>相当于执行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch iss53</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout iss53</span><br></pre></td></tr></table></figure>
<p><strong>相当于 master 和 iss53 两个指针同时指向了最新的一次提交，并且当前HEAD指针指向 iss53 分支</strong></p>
<p><img src="https://tudingtu.cn/i/2023/03/04/ozoq8b.png" alt=""></p>
<p>然后我们开始实现这个功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim xxxx</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;new question&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>此时我们正在完成 iss53 分支的功能扩展</strong>，则此时分支如下所示：</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/p0yxd5.png" alt=""></p>
<hr>
<p>此时我们突然接到了一个紧急电话（<strong>注意：iss53 功能并没有完成，但是这个严重错误的优先级非常高</strong>）！！！ 我们的原来的<strong>某个分支版本上出现了一个严重错误，需要紧急修改</strong></p>
<p>假设其在master分支上（当前仍在iss53分支）则我们需要切换到 master 分支上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<p><strong>然后我们需要创建一个分支来解决这个严重错误。</strong>我们新建并切换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b hotfix</span><br></pre></td></tr></table></figure>
<p>然后我们解决这个严重错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim xxx</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add xxx</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;solve error&#x27;</span><br></pre></td></tr></table></figure>
<p>我们便解决了这个问题，并且提交了，此时的分支如下所示：</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/p3y6g6.png" alt=""></p>
<p>注意：此时我们HEAD工作目录指向的是 hotfix（即解决了这个重大错误的分支）</p>
<p>我们需要合并到原始的master分支中：</p>
<p>要合并我们需要首先回到master中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<h2 id="2-2-合并分支"><a href="#2-2-合并分支" class="headerlink" title="2.2 合并分支"></a>2.2 合并分支</h2><p>关于<strong>合并</strong>我们使用<code>git merge</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge hotfix</span><br></pre></td></tr></table></figure>
<p>注意：此时我们执行的是 <strong>Fast—forword合并</strong>，即<strong>如果分支的直接父节点是原来的需要合并到的版本，则会直接把master移动到hotfix分支上</strong></p>
<p>如下图所示：</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/p6efhh.png" alt=""></p>
<h2 id="2-3-删除分支"><a href="#2-3-删除分支" class="headerlink" title="2.3 删除分支"></a>2.3 删除分支</h2><p>既然我们已经解决了 这个严重错误，并且我们也完成合并了，那<strong>么这个 hotfix显然没用了，直接删除这个分支即可：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d hotfix</span><br></pre></td></tr></table></figure>
<p>则我们继续回到 iss53 来完成这一功能（<strong>之前说了，iss53并没有完成，只是 hotfix的优先级高</strong>）</p>
<p>则切换分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout iss53</span><br></pre></td></tr></table></figure>
<p>经过一顿操作后，我们终于完成 iss53 的功能扩展，并且提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ...</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;终于完成！&#x27;</span><br></pre></td></tr></table></figure>
<p>则此时分支图如下所示：</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/p9esz9.png" alt=""></p>
<p><strong>则最终我们再把这个 扩展 功能与我们的master进行合并：</strong></p>
<p>首先切换到master</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge iss53</span><br></pre></td></tr></table></figure>
<p>合并后，分支图如下所示：</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/payozr.png" alt=""></p>
<p>注意我们的此次合并不同于刚才的严重错误 的合并，刚才<strong>master是 解决严重父亲的直接父节点，因此合并就是父节点移动到孩子节点。</strong></p>
<p><strong>但是此次合并的是同一祖先节点的不同兄弟节点，因此我们 采用两个分支与它们的最近公共祖先 三者一起进行合并</strong>，最终合并为 C6，并且master指向它。然后删除 iss53 分支即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d iss53</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-管理分支"><a href="#3-管理分支" class="headerlink" title="3. 管理分支"></a>3. 管理分支</h1><ol>
<li>列出当前所有分支：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch </span><br></pre></td></tr></table></figure>
<p>其中带星号的表示的是当前<strong>工作分支</strong></p>
<ol>
<li>查看各个分支的<strong>最后一个提交对象的信息</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure>
<p>显示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &#x27;iss53&#x27;</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure>
<ol>
<li>显示<strong>已经与当前分支合并</strong>的分支：<strong>也就是说哪些分支是当前分支的直接上游。</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch --merged</span><br></pre></td></tr></table></figure>
<p>​    未合并的分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果我们把已经与当前分支合并的分支，如 iss53（功能如上节所示），则 在<code>--merge</code> 时会显示，则我们可以轻松的删除它： <code>git branch -d</code></p>
</li>
<li><p>如果我们的 <code>--no-merged</code> 时有任何分支，如testing，则我们<strong>无法删除它</strong>。</p>
<ul>
<li><strong>因为 Git 判断 iss53已经与master合并了，则master 已经包含了iss53的所有功能，则删除也无妨；testing尚未与 master合并，如果贸然删除可能会丢失数据，因此 Git 在删除 testing 此时会报错。</strong></li>
<li>强制删除： <code>-D</code></li>
</ul>
</li>
</ul>
<h1 id="4-分支开发的工作流程"><a href="#4-分支开发的工作流程" class="headerlink" title="4. 分支开发的工作流程"></a>4. 分支开发的工作流程</h1><h2 id="4-1-长期分支"><a href="#4-1-长期分支" class="headerlink" title="4.1 长期分支"></a>4.1 长期分支</h2><p>即把master分支 放在一个<strong>比较稳定的即将发布的版本中</strong>，然后如果添加什么功能，则直接创建新的分支，这些新的分支是master的<strong>平行分支</strong>，即是master分支的平行的孩子们。</p>
<p>如果要合并分支，则可以随时 把这些功能分支合并到 master 分支中，<strong>即master指向的对象直接指向当前 这个功能的分支上，类似于上面的 解决重大错误的 分支的合并的合并策略。</strong></p>
<p>如下图所示：</p>
<p><img src="https://great.wzznft.com/i/2023/03/04/qik47c.png" alt=""></p>
<p>你可以用这招<strong>维护不同层次的稳定性</strong>。</p>
<blockquote>
<p>某些大项目还会有个 <code>proposed</code>（建议）或 <code>pu</code>（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入 <code>next</code> 或 <code>master</code> 的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。再次说明下，使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。</p>
</blockquote>
<h2 id="4-2-特性分支"><a href="#4-2-特性分支" class="headerlink" title="4.2 特性分支"></a>4.2 特性分支</h2><p>一个特性分支是指<strong>一个短期的，用来实现单一特性或与其相关工作的分支</strong>。</p>
<p>在Git 中创建分支是非常轻松的，因此特性分支使用非常普遍</p>
<p><strong>特性分支的流程：</strong></p>
<ol>
<li>工作目录在<code>master</code>中，干到C1的时候，突然出现了一个问题，则转到<code>iss91</code>解决这个问题</li>
<li>在 <code>iss91</code> 中 干到C6的时候，发现 貌似有更好的办法 <code>iss91v2</code> 可以解决这个问题，则在合适的位置 C4进行另一个方法分支的解决</li>
<li>做到 C8的时候，突然没思路了，则先写会的，即先把<code>master</code>中其他的完成，转移到<code>master</code>完成到 C10之后， <code>iss91v2</code> 突然有思路了，则继续回到完成C11，之后提交 <code>iss91v2</code></li>
<li>但是此时又冒出个奇妙的想法，因此 <code>dumbidea</code>在master中测试一下，做个实验。</li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/04/7duaea2.png" alt=""></p>
<p>最后我们便得到了合并后的分支：</p>
<ol>
<li><code>dumabidea</code> 它出色的完成了功能，可以作为master的下一个版本</li>
<li>使用<code>iss91v2</code>然后抛弃了<code>iss91</code>版本</li>
<li>最后两个分支合。</li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/04/qpnjzg.png" alt=""></p>
<h1 id="5-远程分支"><a href="#5-远程分支" class="headerlink" title="5. 远程分支"></a>5. 远程分支</h1><p>如果你有一个本地分支 需要和别人分享， <code>git push (远程仓库名) (分支名)</code> 来推送到远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>Git 自动把 <code>master</code> 分支名扩展为 <code>refs/heads/master:refs/heads/master</code></p>
<p><strong>即取出我在本地的master分支，推送到远程仓库的master分支上去。</strong></p>
<p>运行下面实现相同的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master:master</span><br></pre></td></tr></table></figure>
<p><strong>你可以把本地分支推送到某个命名不同的远程分支</strong>：</p>
<p>若想把远程分支叫作 <code>ylh</code>，可以用 <code>git push origin master:ylh</code> 来推送数据。</p>
<p>其他人想要再次从服务器上获取数据时，他们将得到一个新的远程分支 <code>origin/master</code>，并指向服务器上 <code>master</code> 所指向的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch master</span><br></pre></td></tr></table></figure>
<p><strong>如果要把该远程分支的内容合并到当前分支</strong>，可以运行 <code>git merge origin/master</code>。如果想要一份自己的 <code>master</code> 来开发，<strong>可以在远程分支的基础上分化出一个新的分支来：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b master2 origin/master</span><br></pre></td></tr></table></figure>
<p>这会切换到新建的 <code>master2</code> 本地分支，其内容同远程分支 <code>origin/master</code> 一致，这样你就可以在里面继续开发了。</p>
<p><strong>删除远程分支</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin :master</span><br></pre></td></tr></table></figure>
<p>记住我们不久前见过的 <code>git push [远程名] [本地分支]:[远程分支]</code> 语法，如果省略 <code>[本地分支]</code>，那就等于是在说“在这里提取空白然后把它变成<code>[远程分支]</code>”。</p>
<h1 id="6-分支衍和"><a href="#6-分支衍和" class="headerlink" title="6. 分支衍和"></a>6. 分支衍和</h1><p>一个分支中的修改整合到另一个分支中有两种方法：</p>
<ol>
<li>merge：合并</li>
<li>rebase：衍和</li>
</ol>
<p><strong>最容易的整合方式： merge命令。</strong></p>
<hr>
<p>什么是<strong>衍和</strong>？</p>
<p>在<code>merge</code> 的时候，我们会把<strong>两个对象快照和他们的最近公共最先 三者进行一次合并</strong>。</p>
<p>而现在我们可以把<strong>其中一个对象快照里的变化在另一个对象中重新再打一遍</strong>。在 Git 里，这种操作叫做<em>衍合（rebase）</em>。有了 <code>rebase</code> 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。</p>
<ol>
<li>首先<strong>在C3的exp</strong>中执行下面的命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure>
<p>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 <code>experiment</code>）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 <code>master</code>）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 <code>experiment</code> 的提交历史，使它成为 <code>master</code> 分支的直接下游，如图 3-29 所示：</p>
<p><strong>总结：C3的exp 现在 衍和到了 C3’ 的位置</strong></p>
<p><img src="https://great.wzznft.com/i/2023/03/04/svqd3m.png" alt=""></p>
<ol>
<li>然后再执行一次 <strong>平行合并</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge exp</span><br></pre></td></tr></table></figure>
<p>就形成了如下的分支图：</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/sxhqzq.png" alt=""></p>
<p>虽然最后与 <code>merge</code>整合得到的结果没有任何区别，但衍合能产生一个<strong>更为整洁</strong>的提交历史。</p>
<hr>
<p><strong>衍和的复杂版本：</strong></p>
<p>把<code>server</code>的分支包含进来，在<code>master</code>上进行一次衍和操作：<code>git rebase [主分支] [特性分支]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase master server</span><br></pre></td></tr></table></figure>
<p>使用 <code>--onto</code>：取出client分支，找出client与server的最近<strong>公共祖先</strong>，然后此LCA在 <code>master</code>上做一次<strong>衍和操作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase --onto master server client</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。</strong></p>
]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习（2） - 基本命令操作总结</title>
    <url>/2023/03/03/git%E5%AD%A6%E4%B9%A0-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-创建-git仓库"><a href="#1-创建-git仓库" class="headerlink" title="1 创建 git仓库"></a>1 创建 git仓库</h1><h2 id="1-1-从现有工作目录中初始化新仓库"><a href="#1-1-从现有工作目录中初始化新仓库" class="headerlink" title="1.1 从现有工作目录中初始化新仓库"></a>1.1 从现有工作目录中初始化新仓库</h2><p>需要到你需要用git管理的项目中输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>便会创建一个空的git项目，<strong>并且当前目录下会出现一个名为 .git 的目录</strong>， Git 需要的数据和资源都存放在这个目录中，不过我们目前只是初始化所有的文件与目录</p>
<ol>
<li>告诉 git在这个目录中有几个文件需要版本控制。我使用了几个cpp的文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add *.cpp</span><br></pre></td></tr></table></figure>
<p>还可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;initial project version&#x27;</span><br></pre></td></tr></table></figure>
<p>你已经得到了一个实际维护着若干文件的 Git 仓库。</p>
<h2 id="1-2-从现有仓库克隆"><a href="#1-2-从现有仓库克隆" class="headerlink" title="1.2 从现有仓库克隆"></a>1.2 从现有仓库克隆</h2><p>克隆某个开源项目的git仓库，可以使用 git clone 命令</p>
<p>例如克隆一份Ruby语言的 Git 代码仓库 ticgit可以使用下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:schacon/ticgit.git</span><br></pre></td></tr></table></figure>
<p>这表示在当前文件夹下新建一个ticgit，其中包含一个  .git 的文件夹，<strong>用于保存下载下来的所有版本记录</strong>，然后从中取出最新版本的文件拷贝。</p>
<p><strong>修改克隆的名字</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:schacon/ticgit.git myticgit</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://great.wzznft.com/i/2023/03/03/w5knrj.png" alt=""></p>
<p>在克隆的时候，我们可以选择不同的<strong>数据传输协议</strong>，在我们的例子中选择的是 <strong>ssh传输协议</strong>，你还可以有<code>https://</code>开头或者<code>user@server:/path.git</code>传输协议</p>
<p><img src="https://tudingtu.cn/i/2023/03/03/w69pwj.png" alt=""></p>
<h1 id="2-记录仓库更新"><a href="#2-记录仓库更新" class="headerlink" title="2. 记录仓库更新"></a>2. 记录仓库更新</h1><p>当我们创建了git存储库后，我们便可以在<strong>工作目录</strong>对这写文件进行更新。</p>
<p>在工作目录中的文件无非有两种状态：</p>
<ol>
<li>已跟踪：已跟踪的文件是指本来就被纳入版本控制管理的文件，<strong>在上次快照中有它们的记录</strong>，工作一段时间后，它们的状态可能是<strong>未更新，已修改或者已放入暂存区</strong>。<strong>在克隆获取库后，工作目录的所有文件都是已跟踪的。</strong></li>
<li>未跟踪：其他所有的文件都是未跟踪的，即他们既没有快照，也没有放入暂存区。在修改后 git才会把他们表示为已修改的，然后放到暂存区准备提交更新。</li>
</ol>
<h2 id="2-1-查看跟踪状态"><a href="#2-1-查看跟踪状态" class="headerlink" title="2.1 查看跟踪状态"></a>2.1 查看跟踪状态</h2><p>输入下面的命令来查看当前工作目录的文件<strong>处于什么状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>出现的情况：</p>
<ol>
<li>当前工作目录很干净，所有<strong>已跟踪</strong>文件在上次提交后都未被更改过。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<ol>
<li>现在让我们修改一下，比如添加一个文件（<strong>注意：需要在git克隆的仓库内执行</strong>）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim README</span><br></pre></td></tr></table></figure>
<p>然后随便输入一些内容保存退出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>会出现：<strong>Untracked files ，即未跟踪状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>
<p><strong>表示我们的README 处于Untracked files即未跟踪状态</strong></p>
<blockquote>
<p>未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，因而不用担心把临时文件什么的也归入版本管理。</p>
</blockquote>
<h2 id="2-2-跟踪新文件"><a href="#2-2-跟踪新文件" class="headerlink" title="2.2 跟踪新文件"></a>2.2 跟踪新文件</h2><p>跟踪我们上面新建的 README文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure>
<p>当我们再次 <code>git status</code>，会发现它处于：</p>
<p><strong>Changes to be committed，即未提交状态，它这时已经被跟踪了，但是没有提交。</strong>即处于<code>暂存状态</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   README</span><br></pre></td></tr></table></figure>
<p>其实 <code>git add</code> 的作用就是<strong>将一个文件放入暂存区域中，并且把所有未跟踪的文件或者目录变为已跟踪状态。</strong></p>
<blockquote>
<p>这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等</p>
</blockquote>
<h2 id="2-3-暂存已修改的文件"><a href="#2-3-暂存已修改的文件" class="headerlink" title="2.3 暂存已修改的文件"></a>2.3 暂存已修改的文件</h2><p>我们修改一个<strong>已经存在于历史版本的文件</strong>：README.mkd</p>
<p>忽略上面的内容，我们会看到这样的状态：<strong>Changes not staged for commit</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   README.mkd</span><br></pre></td></tr></table></figure>
<p> 表示已经跟踪的文件发生了修改，但是还没有放在暂存区里。</p>
<p>要暂存这次更新，则需要执行<code>git add</code>（看上节关于git add的讲解）命令。</p>
<p>现在我们运行此命令把 README.mkd放到<strong>暂存区</strong>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add README.mkd</span><br></pre></td></tr></table></figure>
<p>再次status其状态得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   README</span><br><span class="line">        modified:   README.mkd</span><br></pre></td></tr></table></figure>
<p>两个文件都被放在<strong>暂存区</strong>了，提交后便会被更新到仓库中</p>
<hr>
<p>注意：如果此时你又想<strong>修改一个已经被放在暂存区的文件</strong>，则修改后会发现，出现了两个相同的文件，<strong>一个已跟踪并且放在暂存区，而另一个已跟踪未在暂存区。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   README</span><br><span class="line">        modified:   README.mkd</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   README.mkd</span><br></pre></td></tr></table></figure>
<p>这是因为 git只会暂存 执行<code>git add</code>后的文件，因此此时需要重新 输入此命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add README.mkd</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   README</span><br><span class="line">        modified:   README.mkd</span><br></pre></td></tr></table></figure>
<h2 id="2-4-忽略某些文件"><a href="#2-4-忽略某些文件" class="headerlink" title="2.4 忽略某些文件"></a>2.4 忽略某些文件</h2><p>我们不想让某些文件被纳入git的管理，即他们<strong>根本不用出现在未跟踪状态下</strong></p>
<p>我们创建或者修改一下 .gitignore 文件即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim .gitignore</span><br></pre></td></tr></table></figure>
<p>修改后，查看文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.gem</span><br><span class="line">*.swp</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br><span class="line">*.log</span><br><span class="line">*.tmp</span><br><span class="line">*.pid</span><br><span class="line">rdoc/</span><br><span class="line">pkg/</span><br></pre></td></tr></table></figure>
<ol>
<li><code>*.gem</code> <code>*.swp</code> <code>*.[oa]</code> 表示我们要忽略以 gem  swp  o a 等后缀的文件</li>
<li><code>~</code> 表示 一些文件的副本，或者其他文件</li>
<li><code>rdoc/</code> 表示的是一个 <strong>文件夹</strong>，因为它的末尾是  /</li>
</ol>
<p>要养成一开始就设置好 <code>.gitignore</code> 文件的习惯，以免将来误提交这类无用的文件。（可以对一些模式<strong>取反</strong>，表示的就是忽略他们之外的文件或者目录）</p>
<h2 id="2-5-查看已暂存或者未暂存的更新"><a href="#2-5-查看已暂存或者未暂存的更新" class="headerlink" title="2.5 查看已暂存或者未暂存的更新"></a>2.5 查看已暂存或者未暂存的更新</h2><p>查看<strong>具体修改了什么地方</strong>，可以使用下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<p>运行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/README b/README</span><br><span class="line">index e31a6eb..0a7d6e9 100644</span><br><span class="line">--- a/README</span><br><span class="line">+++ b/README</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> 你好!6</span><br><span class="line"> 6666</span><br><span class="line"> hjhhhh</span><br><span class="line">+我修改了一行</span><br></pre></td></tr></table></figure>
<p>前面的 + 号表示我们<strong>添改</strong>了这一行的内容，- 号则表示我们<strong>删改</strong>了一行信息</p>
<p><strong>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改了之后还没有暂存起来的变化</strong></p>
<hr>
<p>查看已经暂存的文件与上次提交的文件的差异：</p>
<p>首先把README先 放入暂存区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure>
<p>运行如下命令：即可查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure>
<p>简单总结：</p>
<ol>
<li><code>git diff</code>：查看某个文件还<strong>没有被暂存起来的改动</strong>，其实就是显示你当前修改了什么内容，与在暂存区的内容做比较。<strong>暂存前后的变化</strong></li>
<li><code>git diff --cached</code>：查看某个文件<strong>已经被暂存和上一次提交时的文件的内容差异</strong>。<strong>已经暂存的变化</strong></li>
</ol>
<h2 id="2-6-提交更新"><a href="#2-6-提交更新" class="headerlink" title="2.6 提交更新"></a>2.6 提交更新</h2><p>首先检查有没有修改了但是没有被暂存的，因为<strong>提交只会提交暂存区的</strong></p>
<p>检查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add xxx # 如果还存在未暂存的目标</span><br></pre></td></tr></table></figure>
<p>检查完成后，输入<strong>提交命令：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>
<p><strong>这时就会出现一个文本编辑器，并且输入本次提交的说明</strong></p>
<p>我的出现了 vscode，可以按照下列的命令进行修改默认哪个编辑器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.editor xxxxx</span><br></pre></td></tr></table></figure>
<p>默认的提交信息包括最后一次<code>git status</code>显示的信息</p>
<blockquote>
<p>如果觉得这还不够，可以用 <code>-v</code> 选项将修改差异的每一行都包含到注释中来。</p>
</blockquote>
<p>退出编辑器时，Git 会丢掉注释行，<strong>将说明内容和本次更新提交到仓库。</strong></p>
<p>在空行输入提交信息：保存后退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">learning git use  </span><br></pre></td></tr></table></figure>
<p>接着就会提示你提交成功！并且显示当前是在哪个分支（master）提交的，本次提交的完整 <strong>SHA-1 校验和</strong>是什么（<code>582f005</code>），以及在本次提交中，有<strong>多少文件修订过</strong>，<strong>多少行添改和删改过</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[master 582f005] learning git use</span><br><span class="line"> 3 files changed, 10 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
</blockquote>
<p>使用 <code>-m</code> 快速添加提交信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m 我要学习</span><br><span class="line"> </span><br><span class="line">[master f949baa] 我要学习</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>
<h2 id="2-7-跳过暂存"><a href="#2-7-跳过暂存" class="headerlink" title="2.7 跳过暂存"></a>2.7 跳过暂存</h2><p>使用下面的命令可以将修改的文件无需放入暂存区，即无需使用<code>git add</code>的命令，可以<strong>直接 提交</strong>。</p>
<p>修改了一个文件之后，执行下面的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure>
<p>即在commit的时候添加一个  <code>-a</code>  2.</p>
<p>实现快速修改提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a -m 跳过暂存</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[master 042500c] 跳过暂存</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>
<h2 id="2-8-移除文件"><a href="#2-8-移除文件" class="headerlink" title="2.8 移除文件"></a>2.8 移除文件</h2><p>从 Git 中移除某个不想要的文件，即从<strong>已经暂存的区域移除某个文件</strong>。</p>
<p><strong>输入以下命令，来删除暂存区的文件，并且直接把它从工作目录中删除，连未跟踪区域都别留下。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm xxx</span><br></pre></td></tr></table></figure>
<p>相当于直接删除这个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        deleted:    README</span><br></pre></td></tr></table></figure>
<p>如果要删除一个<strong>已经放在暂存区</strong>的文件，则必须<strong>强制删除</strong>，输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm -f xxx </span><br></pre></td></tr></table></figure>
<p>只从暂存区删除，<strong>即删除跟踪，但是不删除其本身</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm --cached xxx</span><br></pre></td></tr></table></figure>
<p>此命令删除所有 <code>log/</code> 目录下扩展名为 <code>.log</code> 的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm log/\*.log</span><br></pre></td></tr></table></figure>
<p>删除当前目录及其子目录中所有 <code>~</code> 结尾的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm \*~</span><br></pre></td></tr></table></figure>
<h2 id="2-9-移动文件"><a href="#2-9-移动文件" class="headerlink" title="2.9 移动文件"></a>2.9 移动文件</h2><p>我们想要把一个文件README.txt 改为 README ，可以使用下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv README.txt README </span><br></pre></td></tr></table></figure>
<p><code>mv</code> 表示 把文件从README.txt 改为 README</p>
<p>实际上执行了三条语句是等价的：<strong>注意README.txt一定是在暂存区域内</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv README.txt README</span><br><span class="line">git rm README.txt</span><br><span class="line">git add README</span><br></pre></td></tr></table></figure>
<ol>
<li>mv命令把README.txt 改为 README，但是此时<strong>README.txt仍在暂存区</strong>，并且<strong>README在未暂存区</strong></li>
<li><strong>删除暂存区的README.txt</strong></li>
<li><strong>把README放入暂存区</strong></li>
</ol>
<p>实际上 <code>git mv file_from file_to</code> 便可以表示这一过程，无需写三条</p>
<h1 id="3-查看提交历史"><a href="#3-查看提交历史" class="headerlink" title="3. 查看提交历史"></a>3. 查看提交历史</h1><p>演示: 首先运行命令获取项目库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/schacon/simplegit-progit.git</span><br></pre></td></tr></table></figure>
<p>在此项目中运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>会出现以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>
<p><code>git log</code> 会按<strong>提交时间</strong>列出所有的更新，<strong>最近的更新排在最上面</strong></p>
<p>每次更新都有一个 SHA-1 校验和，作者姓名电子邮箱，提交时间与<strong>提交说明</strong></p>
<hr>
<p>使用 <code>-p</code> 显示每次提交的内容差异 <code>-2</code>只显示最近两次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -p -2</span><br></pre></td></tr></table></figure>
<hr>
<p>使用<code>--word-diff</code>获取<strong>单词层面</strong>的变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -p --word-diff</span><br></pre></td></tr></table></figure>
<hr>
<p>使用<code>-stat</code> 显示简要的<strong>增改行数统计</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure>
<p>每个提交都列出了修改过的文件，以及其中添加和移除的行数，并在最后列出所有增减行数小计。</p>
<hr>
<p><code>--pretty</code> 可以指定使用完全不同于默认格式的方式展示提交历史</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --pretty=xxx</span><br></pre></td></tr></table></figure>
<p>xxx可以为：oneline，short，full，fuller</p>
<p><code>format</code> 定制显示的格式，相当于debug</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选项	 说明</span><br><span class="line">%H	提交对象（commit）的完整哈希字串</span><br><span class="line">%h	提交对象的简短哈希字串</span><br><span class="line">%T	树对象（tree）的完整哈希字串</span><br><span class="line">%t	树对象的简短哈希字串</span><br><span class="line">%P	父对象（parent）的完整哈希字串</span><br><span class="line">%p	父对象的简短哈希字串</span><br><span class="line">%an	作者（author）的名字</span><br><span class="line">%ae	作者的电子邮件地址</span><br><span class="line">%ad	作者修订日期（可以用 -date= 选项定制格式）</span><br><span class="line">%ar	作者修订日期，按多久以前的方式显示</span><br><span class="line">%cn	提交者(committer)的名字</span><br><span class="line">%ce	提交者的电子邮件地址</span><br><span class="line">%cd	提交日期</span><br><span class="line">%cr	提交日期，按多久以前的方式显示</span><br><span class="line">%s	提交说明</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><code>log</code> 的后面参数的其他选择</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选项	说明</span><br><span class="line">-p	按补丁格式显示每个更新之间的差异。</span><br><span class="line">--word-diff	按 word diff 格式显示差异。</span><br><span class="line">--stat	显示每次更新的文件修改统计信息。</span><br><span class="line">--shortstat	只显示 --stat 中最后的行数修改添加移除统计。</span><br><span class="line">--name-only	仅在提交信息后显示已修改的文件清单。</span><br><span class="line">--name-status	显示新增、修改、删除的文件清单。</span><br><span class="line">--abbrev-commit	仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</span><br><span class="line">--relative-date	使用较短的相对时间显示（比如，“2 weeks ago”）。</span><br><span class="line">--graph	显示 ASCII 图形表示的分支合并历史。</span><br><span class="line">--pretty	使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</span><br><span class="line">--oneline	`--pretty=oneline --abbrev-commit` 的简化用法</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><code>--since 和 --until</code> 对<strong>时间作出限制</strong></p>
<p>显示最近两周的提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --since=2.weeks</span><br></pre></td></tr></table></figure>
<p>其他选择:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选项	说明</span><br><span class="line">-(n)	仅显示最近的 n 条提交</span><br><span class="line">--since, --after	仅显示指定时间之后的提交。</span><br><span class="line">--until, --before	仅显示指定时间之前的提交。</span><br><span class="line">--author	仅显示指定作者相关的提交。</span><br><span class="line">--committer	仅显示指定提交者相关的提交。</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="4-撤销操作"><a href="#4-撤销操作" class="headerlink" title="4. 撤销操作"></a>4. 撤销操作</h1><h2 id="4-1-修改最后一次操作"><a href="#4-1-修改最后一次操作" class="headerlink" title="4.1 修改最后一次操作"></a>4.1 修改最后一次操作</h2><p>如果在提交后，发现提交信息写错了，或者漏掉几个文件没有加，则可以这样修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<hr>
<p>如果还没有暂存文件就提交了，则可以这样操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit # 提交了</span><br><span class="line">git add file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<p>上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p>
<h2 id="4-2-取消暂存中的文件"><a href="#4-2-取消暂存中的文件" class="headerlink" title="4.2 取消暂存中的文件"></a>4.2 取消暂存中的文件</h2><p>我们有多个文件还未暂存，但是我们<strong>不小心一次性全部放入暂存了</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>但是我们想一个一个放，不能一次性放入，因此我们使用这两条命令（git status显示的内容有说明）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure>
<p>HEAD表示上一个版本 HEAD^ HEAD^^  …. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git store --staged file</span><br></pre></td></tr></table></figure>
<h2 id="4-3-取消对文件的修改"><a href="#4-3-取消对文件的修改" class="headerlink" title="4.3 取消对文件的修改"></a>4.3 取消对文件的修改</h2><p>我们<strong>不想对这个文件进行修改了</strong>，让他回到一开始的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- benchmarks.rb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可能已经意识到了，这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过来重写了此文件。所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。如果只是想回退版本，同时保留刚才的修改以便将来继续工作，可以用下章介绍的 stashing 和分支来处理，应该会更好些。</p>
</blockquote>
<h1 id="5-远程管理仓库"><a href="#5-远程管理仓库" class="headerlink" title="5. 远程管理仓库"></a>5. 远程管理仓库</h1><p> 管理远程仓库的工作，包括<strong>添加远程库</strong>，<strong>移除废弃的远程库</strong>，<strong>管理各式远程库分支</strong>，<strong>定义是否跟踪这些分支</strong></p>
<h2 id="5-1-查看当前远程库"><a href="#5-1-查看当前远程库" class="headerlink" title="5.1 查看当前远程库"></a>5.1 查看当前远程库</h2><p>查看当前配置有哪些远程库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>
<p>注意：<strong>默认存在一个 origin的远程库</strong>，Git 默认使用这个名字来标识你所克隆的原始仓库。</p>
<p>显示原始仓库的<strong>克隆地址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote --v</span><br></pre></td></tr></table></figure>
<p>如果有多个远程仓库，此命令将全部列出。</p>
<h2 id="5-2-添加远程仓库"><a href="#5-2-添加远程仓库" class="headerlink" title="5.2 添加远程仓库"></a>5.2 添加远程仓库</h2><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add pb  git://github.com/paulboone/ticgit.git</span><br></pre></td></tr></table></figure>
<p>添加了一个 远程仓库  名称为 pb</p>
<p><strong>pb代表的就是远程仓库的地址</strong></p>
<p>抓取仓库地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch pb</span><br></pre></td></tr></table></figure>
<p>Paul 的主干分支（master）已经完全可以在本地访问了，对应的名字是 <code>pb/master</code>，你可以将它合并到自己的某个分支，或者切换到这个分支，看看有些什么有趣的更新。</p>
<h2 id="5-3-从远程仓库抓取数据"><a href="#5-3-从远程仓库抓取数据" class="headerlink" title="5.3 从远程仓库抓取数据"></a>5.3 从远程仓库抓取数据</h2><p>使用下面的命令从<strong>远程仓库抓取数据到本地</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch &lt;remote-name&gt;</span><br></pre></td></tr></table></figure>
<p>此命令从<strong>远程仓库中拉取所有你本地仓库中还没有的数据</strong>。</p>
<hr>
<p>抓取从你上次克隆这个仓库以来，别人上传到此仓库中的所有更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure>
<p>有一点很重要，需要记住，<strong>fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支</strong>，只有当你确实准备好了，才能手工合并。</p>
<h2 id="5-4-推送数据到远程仓库"><a href="#5-4-推送数据到远程仓库" class="headerlink" title="5.4 推送数据到远程仓库"></a>5.4 推送数据到远程仓库</h2><p>项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push [remote-name] [branch-name]</span><br></pre></td></tr></table></figure>
<p>把本地的branch分支推送到远程 remote 服务器上</p>
<h2 id="5-5-查看远程仓库信息"><a href="#5-5-查看远程仓库信息" class="headerlink" title="5.5 查看远程仓库信息"></a>5.5 查看远程仓库信息</h2><p>命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show [remote-name]</span><br></pre></td></tr></table></figure>
<p>查看某个远程仓库的信息</p>
<p>它友善地告诉你如果是在 <strong>master 分支</strong>，就可以用 <code>git pull</code> 命令抓取数据合并到本地。</p>
<p>另外还列出了所有<strong>处于跟踪状态中的远端分支</strong>。</p>
<h2 id="5-6-远程仓库的删除与重命名"><a href="#5-6-远程仓库的删除与重命名" class="headerlink" title="5.6 远程仓库的删除与重命名"></a>5.6 远程仓库的删除与重命名</h2><p>修改某个远程仓库在本地的名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rename pb pbnewname</span><br></pre></td></tr></table></figure>
<p>对远程仓库的重命名，也会使对应的分支名称发生变化。</p>
<p>删除对应的远程仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm pbname</span><br></pre></td></tr></table></figure>
<h1 id="6-打标签"><a href="#6-打标签" class="headerlink" title="6. 打标签"></a>6. 打标签</h1><p>在某一时间点上打上标签</p>
<p>git的标签类型：</p>
<ol>
<li>轻量型标签：是个不会变化的标签，只指向某个特定对象的引用</li>
<li>含附注的标签：存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明。</li>
</ol>
<h2 id="6-1-显示所有标签"><a href="#6-1-显示所有标签" class="headerlink" title="6.1 显示所有标签"></a>6.1 显示所有标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>标签按字母顺序排列，所以<strong>标签的先后不表示重要程度的轻重</strong>.</p>
<p>筛选标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -l &#x27;v1.4.2.*&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-创建标签"><a href="#6-2-创建标签" class="headerlink" title="6.2 创建标签"></a>6.2 创建标签</h2><p>创建含附注的标签：<code>-a</code> 后附带<strong>标签的名字</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -a v1.4 -m &#x27;my version 1.4&#x27;</span><br></pre></td></tr></table></figure>
<p><code>-m</code>表示指定对应的标签说明，如果没有 -m后面的内容，则会跳转到vscode让你手动编写 <strong>标签说明</strong></p>
<p>使用下面的命令来显示标签对应的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git show v1.4</span><br></pre></td></tr></table></figure>
<p>列出了此标签的提交者和提交时间，以及相应的标签说明。</p>
<p>创建个人的<strong>私钥</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -s v1.5 -m &#x27;my signed 1.5 tag&#x27;</span><br></pre></td></tr></table></figure>
<p>创建<strong>轻量级标签</strong>，直接给出标签的名字即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag v1.8</span><br></pre></td></tr></table></figure>
<h2 id="6-3-加注标签"><a href="#6-3-加注标签" class="headerlink" title="6.3 加注标签"></a>6.3 加注标签</h2><p>已经提交的版本中<strong>补上标签信息</strong>：</p>
<p>首先显示所有的版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure>
<p>可以看到 没有标签，我们输入命令，让其中一个版本加上标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -a v1.9 085bb3b</span><br></pre></td></tr></table></figure>
<p><strong>注意：直需要加上校验和的前几位即可，git就会识别这是哪一个版本。</strong></p>
<p>显示我们刚加的标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git show v1.9</span><br></pre></td></tr></table></figure>
<h2 id="6-4-分享标签"><a href="#6-4-分享标签" class="headerlink" title="6.4 分享标签"></a>6.4 分享标签</h2><p>通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 <code>git push origin [tagname]</code> 即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin v1.5</span><br></pre></td></tr></table></figure>
<p>一次性推送所有的本地标签上去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>
<h1 id="7-Git使用技巧"><a href="#7-Git使用技巧" class="headerlink" title="7. Git使用技巧"></a>7. Git使用技巧</h1><h2 id="7-1-自动补全"><a href="#7-1-自动补全" class="headerlink" title="7.1 自动补全"></a>7.1 自动补全</h2><p>首先可以查看自己的 Git 有没有自动补全的功能，如下操作所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git con&lt;tab&gt;</span><br></pre></td></tr></table></figure>
<p>输入git co 然后 按<strong>两次tab键</strong>，会出现提示的命令： config 和commit</p>
<p><img src="https://great.wzznft.com/i/2023/03/04/m5tqml.png" alt=""></p>
<p><strong>如果上述办法不可以</strong>，则需要进行如下操作：</p>
<blockquote>
<p>如果你用的是 Bash shell，可以试试看 Git 提供的自动补全脚本。下载 Git 的源代码，进入 <code>contrib/completion</code> 目录，会看到一个 <code>git-completion.bash</code> 文件。将此文件复制到你自己的用户主目录中（译注：按照下面的示例，还应改名加上点：<code>cp git-completion.bash ~/.git-completion.bash</code>），并把下面一行内容添加到你的 <code>.bashrc</code> 文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.git-completion.bash</span><br></pre></td></tr></table></figure>
<p>也可以为系统上所有用户都设置默认使用此脚本。Mac 上将此脚本复制到 <code>/opt/local/etc/bash_completion.d</code> 目录中，Linux 上则复制到 <code>/etc/bash_completion.d/</code> 目录中。这两处目录中的脚本，都会在 Bash 启动时自动加载。</p>
</blockquote>
<h2 id="7-2-使用别名"><a href="#7-2-使用别名" class="headerlink" title="7.2 使用别名"></a>7.2 使用别名</h2><p>为命令起一个别名： <code>git config</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>
<p>接下来输入 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git st</span><br></pre></td></tr></table></figure>
<p>其实就是 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status </span><br></pre></td></tr></table></figure>
<p><strong>取消在暂存区的文件</strong>：<strong>完整命令如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure>
<p>可以使用别名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git unstage file</span><br></pre></td></tr></table></figure>
<p><strong>显示最后一次提交的文件，完整命令如下</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -1 HEAD</span><br></pre></td></tr></table></figure>
<p>可以使用别名，看起来会更清晰</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.last &#x27;log -1 HEAD&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git last</span><br></pre></td></tr></table></figure>
<p> Git 只是简单地在命令中替换了你设置的别名</p>
<p><strong>输入Git外部命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.visual &#x27;!gitk&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git visual </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习（1） - git的安装与配置</title>
    <url>/2023/03/03/git%E5%AD%A6%E4%B9%A0-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><ol>
<li>本地版本控制系统</li>
<li>集中化的版本控制系统</li>
<li>分布式版本控制系统</li>
</ol>
<h1 id="git基础"><a href="#git基础" class="headerlink" title="git基础"></a>git基础</h1><p>git与其他版本控制系统的区别是：<strong>git只保存文件数据的整体是否发生变化。</strong> 而大多数其他系统则只关心文件内容的<strong>具体差异</strong></p>
<p>换句话说：<strong>git保存每次更新时的文件快照</strong></p>
<p>Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的 VCS。</p>
<p>git的所有操作都是对本地文件的资源操作，因此不需要联网。 <strong>Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。</strong></p>
<p>git每次只需要从本地数据库读取内容，在任何时候都可以随时读取，再查看历史版本的时候，git会在保存的<strong>历史快照中</strong>查询，而不需要请求远程服务器或者把查询老版本的文件。</p>
<p>git可以在没有网络的时候<strong>随时提交更新到本地</strong>，等到有网络的时候再<strong>上传远程仓库</strong>。</p>
<p>git具有内容完整性的功能：<strong>在保存到 Git 之前，所有数据都要进行内容的校验和计算，并将此结果作为数据的唯一标识和索引。</strong>任何文件如果在传输时发生损坏，git都能察觉。</p>
<p>git使用 SHA-1 算法计算数据的校验和，这实际上是一个<strong>哈希值</strong>，git通过将文件转换为哈希值来工作，并依靠它作为git的索引。</p>
<hr>
<h2 id="git文件的三种形式"><a href="#git文件的三种形式" class="headerlink" title="git文件的三种形式"></a>git文件的三种形式</h2><ol>
<li>已提交：文件已经被安全的保存在本地数据库中</li>
<li>已修改：已经修改了文件，但是还没有保存提交</li>
<li>已暂存：把已修改的文件放在下次提交要保存的清单中</li>
</ol>
<p>git管理项目的三个区域：</p>
<ol>
<li>git的工作目录：项目中取出<strong>某个版本的所有文件和目录</strong>，用以开始后续工作。</li>
<li>暂存区域：暂存区域只不过是个简单的文件，一般都放在 Git 目录中。</li>
<li>本地仓库：Git或者 .git 目录：是保存元数据和对象数据库的地方，实际上克隆仓库的时候就是克隆这里面的数据</li>
</ol>
<hr>
<p>Git的工作流程：</p>
<ol>
<li>在<strong>工作目录</strong>中修改某些文件。</li>
<li>修改完成后的文件进行<strong>快照</strong>存放在<strong>暂存区域</strong>中</li>
<li>把暂存区域中的文件的快照提交更新到<strong>Git目录</strong>中。</li>
</ol>
<p>三种状态：</p>
<ol>
<li>已提交状态</li>
<li>已暂存状态</li>
<li>已修改状态</li>
</ol>
<h1 id="git的安装"><a href="#git的安装" class="headerlink" title="git的安装"></a>git的安装</h1><h2 id="源代码安装"><a href="#源代码安装" class="headerlink" title="源代码安装"></a>源代码安装</h2><ol>
<li>如果有 yum，则输入以下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install curl-devel expat-devel gettext-devel \</span><br><span class="line">  openssl-devel zlib-devel</span><br></pre></td></tr></table></figure>
<ol>
<li>如果有apt-get，则输入以下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \</span><br><span class="line">  libz-dev libssl-dev</span><br></pre></td></tr></table></figure>
<p>之后，从下面的 Git 官方站点下载最新版本源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://git-scm.com/download</span><br></pre></td></tr></table></figure>
<p>然后编译并安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar -zxf git-1.7.2.2.tar.gz</span><br><span class="line">$ cd git-1.7.2.2</span><br><span class="line">$ make prefix=/usr/local all</span><br><span class="line">$ sudo make prefix=/usr/local install</span><br></pre></td></tr></table></figure>
<p>现在已经可以用 <code>git</code> 命令了，用 <code>git</code> 把 Git 项目仓库克隆到本地，以便日后随时更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git://git.kernel.org/pub/scm/git/git.git</span><br></pre></td></tr></table></figure>
<h2 id="linux安装"><a href="#linux安装" class="headerlink" title="linux安装"></a>linux安装</h2><ol>
<li>具有yum的时候，通过yum安装</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install git-core</span><br></pre></td></tr></table></figure>
<ol>
<li>Ubuntu 具有 apt-get的时候，通过apt-get安装</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure>
<h2 id="window安装"><a href="#window安装" class="headerlink" title="window安装"></a>window安装</h2><ol>
<li>通过GitHub的开源项目安装 下载exe，并且运行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://msysgit.github.com/</span><br></pre></td></tr></table></figure>
<ol>
<li>上一种方法国内下载慢，可以使用阿里镜像安装</li>
</ol>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZWdpc3RyeS5ucG1taXJyb3IuY29tL2JpbmFyeS5odG1sP3BhdGg9Z2l0LWZvci13aW5kb3dzLw==">阿里镜像下载 git<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h1><p>git config工具，实际上是 git-config命令，使用这个命令来配置或者读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<ol>
<li><code>/etc/gitconfig</code>：系统中所有用户都使用的配置，git config时使用 —system。</li>
<li><code>~/.gitconfig</code>：用户工作目录下的配置文件只适用于此用户git config时使用 —global。</li>
<li><code>.git/config</code>：当前项目的配置文件，只针对于当前项目。</li>
</ol>
<p>每一个级别的配置都会覆盖上层相同的配置，因此<code>.git/config</code>会覆盖<code>/etc/gitconfig</code>中的同名变量。</p>
<p><code>.gitconfig</code>的路径：默认在C盘的user的文件夹下。</p>
<h2 id="修改用户信息"><a href="#修改用户信息" class="headerlink" title="修改用户信息"></a>修改用户信息</h2><p>git在提交更新的时候需要知道是谁提交了，因此需要配置个人信息</p>
<p>输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.email 电子邮箱</span><br></pre></td></tr></table></figure>
<p>使用—global配置的.gitconfig的文件路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Users\username\.gitconfig&quot;</span><br></pre></td></tr></table></figure>
<p><strong>我们配置的是用户主目录的那个，因此所有的项目默认使用这个配置。</strong></p>
<p>如果要在<strong>某个特定的项目中</strong>使用其他用户或者电脑，则需要去掉 —global ，重新配置信息即可。</p>
<h2 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h2><p>默认的git输入信息使用的文编编辑器</p>
<p>我这里使用vscode，你也可以使用Emacs  或者 vim</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.editor vscode</span><br></pre></td></tr></table></figure>
<h2 id="差异比较工具"><a href="#差异比较工具" class="headerlink" title="差异比较工具"></a>差异比较工具</h2><p>在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global merge.tool vimdiff</span><br></pre></td></tr></table></figure>
<h2 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h2><p>输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
<h2 id="使用帮助命令"><a href="#使用帮助命令" class="headerlink" title="使用帮助命令"></a>使用帮助命令</h2><p>想要知道某个命令如何使用： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config &lt;xxx&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo与github搭建个人博客</title>
    <url>/2023/03/02/hexo%E4%B8%8Egithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="0-前置内容"><a href="#0-前置内容" class="headerlink" title="0. 前置内容"></a>0. 前置内容</h1><ol>
<li><strong>git 的下载</strong>： 官网下载较慢，这边推荐阿里镜像下载：</li>
</ol>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZWdpc3RyeS5ucG1taXJyb3IuY29tL2JpbmFyeS5odG1sP3BhdGg9Z2l0LWZvci13aW5kb3dzLw==">阿里镜像下载 git<i class="fa fa-external-link-alt"></i></span></p>
<p>往下滑选择接近当前日期的最新版本  2.39.2 windows</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124lpsb.png" alt=""></p>
<p>选择 2.39.2 -64 的exe下载，大概有 50Mb大小</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124lsc8.png" alt=""></p>
<p>下载好后，直接<strong>一直点下一步即可</strong>。如果你了解过git，则可以按照自己的习惯下载，这不重要。</p>
<ol>
<li><strong>Nodejs下载</strong></li>
</ol>
<p>直接百度搜索 Nodejs，<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">Nodejs下载<i class="fa fa-external-link-alt"></i></span> </p>
<p>选择 18.14.2 的 LTS版本下载</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124luej.png" alt=""></p>
<h1 id="1-hexo创建个人博客"><a href="#1-hexo创建个人博客" class="headerlink" title="1. hexo创建个人博客"></a>1. hexo创建个人博客</h1><p>hexo是什么？</p>
<ul>
<li><p>正如hexo的首页所显示的，它是一款非常快速，简介，高效的博客框架平台，我们可以利用hexo快速生成博客网站的模板，然后部署为我们自己的博客网站。</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124lxlr.png" alt=""></p>
</li>
</ul>
<p>直接进入操作：</p>
<ol>
<li><strong>在任意盘符中新建 hexo 文件夹</strong>，这里我创建在了F盘</li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/02/124m59v.png" alt=""></p>
<ol>
<li><strong>打开hexo文件夹，空白的地方右键，选择 Git Bash Here</strong> ，即我们使用 git 环境创建 hexo的blog模板（必须提前安装好 git），打开后如下图所示：<strong>/ f / hexo表示当前操作位置在 F盘的 hexo文件夹中</strong></li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/02/124m6dn.png" alt=""></p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124mb6h.png" alt=""></p>
<ol>
<li><strong>在 git窗口中依次输入以下命令</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd blog</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>全部输入完成后，hexo文件夹中便会生成一个 blog 子文件夹，并且blog文件夹里面包含有很多信息：</p>
<p><img src="https://great.wzznft.com/i/2023/03/02/1282mhg.png" alt=""></p>
<p>关于这些文件夹，做一个简单的介绍：</p>
<ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：生成文章的一些模板</li>
<li>source：用来存放你的文章</li>
<li>themes：主题</li>
</ul>
<p>然后输入这两条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s </span><br></pre></td></tr></table></figure>
<p>完成后会显示如下内容，则说明<strong>配置成功</strong>!</p>
<p><img src="https://great.wzznft.com/i/2023/03/03/piaj7x.png" alt=""></p>
<p>在  git 中输入 Ctrl+C 即可关闭hexo s的内容。</p>
<p>打开浏览器，在浏览器输入 <strong>localhost:4000</strong> 即可进入你的<strong>初始默认博客</strong></p>
<p>它长这样：</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/12e7hdk.png" alt=""></p>
<p>注意：这只是一个<strong>离线版本的博客</strong> ，只能你自己看见，因此我们还需要 GitHub或者 gittee提供的 ssh功能将他变为对外开放的。</p>
<h1 id="2-GitHub创建仓库"><a href="#2-GitHub创建仓库" class="headerlink" title="2. GitHub创建仓库"></a>2. GitHub创建仓库</h1><ol>
<li>首先注册一个GitHub的仓库，然后在<strong>个人主页中选择 new 新建仓库</strong></li>
</ol>
<p>注意： 仓库名称的<strong>前半部分与你的用户名一致</strong>，即 lummod，<strong>后半部分 为  .git.io 固定格式</strong>（忽略红色警告，因为我已经创建过了！），可以选择一个readme为说明文件（随便），然后<strong>点击创建仓库</strong></p>
<p><img src="https://tudingtu.cn/i/2023/03/02/12idvsn.png" alt=""></p>
<ol>
<li>回到 git bash黑窗口中，<strong>输入以下两个命令</strong>（逐条）：</li>
</ol>
<p>yourname改为你的<strong>GitHub的用户名</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br></pre></td></tr></table></figure>
<p>youremail改为你的<strong>注册GitHub时的邮箱</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
<p>一定不要输入错，这样github才能检查到这个用户属于你</p>
<ol>
<li><strong>创建 ssh，输入命令，然后一直回车</strong></li>
</ol>
<p>youremail改为你的<strong>注册GitHub时的邮箱</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
<p>之后会提示你已完成 ssh的创建，在文件中找到这个路径</p>
<p><img src="https://great.wzznft.com/i/2023/03/02/12lqlrh.png" alt=""></p>
<p>记住这两个文件</p>
<ol>
<li>在 GitHub的 Setting里面，找到 SSH keys，<strong>把 id_rsa.pub 里面的内容全部复制到 key 进去</strong>，title随便写一个就行</li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/02/12mxnrn.png" alt=""></p>
<p>操作完成后，就成功了。</p>
<h1 id="3-hexo部署到GitHub"><a href="#3-hexo部署到GitHub" class="headerlink" title="3. hexo部署到GitHub"></a>3. hexo部署到GitHub</h1><ol>
<li>在 blog文件夹下面找到 <strong>_config.yml 文件</strong>，这是属于 你的博客的<strong>配置文件</strong>，<strong>点进入一看就知道了，你可以在这里面直接修改 姓名，内容，等用户的信息</strong>。双击打开它（vscode或者其他文本编辑器，记事本都可以）</li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/nknu8o.png" alt=""></p>
<ol>
<li>先找一下有没有以下这段内容（我也忘记了是我添加的还是自带的），<strong>如果自带则一定是空的，则修改为如下所示，如果没有，则直接复制下面内容到 文档的末尾：</strong></li>
</ol>
<p><strong>user表示你的GitHub的用户名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line"># deploy:</span><br><span class="line">#   type: &#x27;&#x27;</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/username/username.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  # message: Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>说明：类型是 git，远程 ssh连接是 你的 repo输入项，branch 输入gh-pages。</strong></p>
<p>另外，找到 第16行（或者直接搜索 url）修改url 为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://username.github.io</span><br></pre></td></tr></table></figure>
<p>  同样username是你的GitHub的用户名。</p>
<ol>
<li>完成后，保存文件并且退出，在 git bash中输入以下命令：</li>
</ol>
<p><strong>表示安装 git部署命令工具</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<ol>
<li>最后输入以下三行命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。<br><code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写<br><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p>
<p><strong>如果是在离线端即 localhost:4000端测试你的博客，则只需要 hexo  g + hexo s 即可，无需 hexo d</strong></p>
<ol>
<li>输入完成后会出现一堆内容，不用管他<strong>，只要最后内容如下所示，</strong>就表示成功了！</li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/03/nl3wwl.png" alt=""></p>
<p>然后你就可以在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username.github.io  # https://username.github.io</span><br></pre></td></tr></table></figure>
<p><strong>访问到你的博客了，其中username是你GitHub用户名，这个网站不是离线的，其他人都可以访问到！！！</strong></p>
<h1 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h1><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>在 根目录中，git bash黑窗口中输入 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;博客名称&quot;</span><br></pre></td></tr></table></figure>
<p>然后打开 blog/source/_posts/ 文件夹后，你的 博客名称的md文档就创建好，<strong>直接打开编写即可，可以添加一些标签给这个文章</strong>，如 tags：编程技术</p>
<p><img src="https://great.wzznft.com/i/2023/03/03/p8mg87.png" alt=""></p>
<h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>生成静态文件。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-d</code>, <code>--deploy</code></td>
<td style="text-align:left">文件生成后立即部署网站</td>
</tr>
<tr>
<td style="text-align:left"><code>-w</code>, <code>--watch</code></td>
<td style="text-align:left">监视文件变动</td>
</tr>
<tr>
<td style="text-align:left"><code>-b</code>, <code>--bail</code></td>
<td style="text-align:left">生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td style="text-align:left"><code>-f</code>, <code>--force</code></td>
<td style="text-align:left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-c</code>, <code>--concurrency</code></td>
<td style="text-align:left">最大同时生成文件的数量，默认无限制</td>
</tr>
</tbody>
</table>
</div>
<p>该命令可以简写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-p</code>, <code>--port</code></td>
<td style="text-align:left">重设端口</td>
</tr>
<tr>
<td style="text-align:left"><code>-s</code>, <code>--static</code></td>
<td style="text-align:left">只使用静态文件</td>
</tr>
<tr>
<td style="text-align:left"><code>-l</code>, <code>--log</code></td>
<td style="text-align:left">启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody>
</table>
</div>
<p>该命令可以简写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p><strong>部署网站，构建在GitHub的服务器中。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-g</code>, <code>--generate</code></td>
<td style="text-align:left">部署之前预先生成静态文件</td>
</tr>
</tbody>
</table>
</div>
<p>该命令可以简写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>命令配合使用，重新构建网站（release）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>访问离线的端口（debug）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<h1 id="5-添加插件"><a href="#5-添加插件" class="headerlink" title="5. 添加插件"></a>5. 添加插件</h1><h2 id="5-1-主题"><a href="#5-1-主题" class="headerlink" title="5.1 主题"></a>5.1 主题</h2><ol>
<li>hexo提供了非常多的主题模板，在hexo的网站里往下滑，点击<strong>探索主题</strong>即可。</li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/nlx1xa.png" alt=""></p>
<ol>
<li>选择某一个主题，然后可以点击 中间是<strong>预览的效果</strong>，点击蓝色的名字是 该<strong>主题的GitHub的下载地址</strong></li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/nmwn8v.png" alt=""></p>
<ol>
<li>我的<strong>主题是 next</strong>，next是一款非常简洁舒服的主题，并且可支持的插件非常多，功能也很强大，可以直接搜索next，然后点击 GitHub的地址，进入下载</li>
<li>根据它的下载提示，直接在 git bash窗口中输入，即可下载next主题</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<ol>
<li>下载完成之后，在 blog文件夹（即根目录）下找到 <strong>themes文件夹，这个文件夹里面存放你下载的主题文件</strong>，可以看到next主题又再次包含一个文件夹，其中包含了next 主题的配置信息</li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/nqh1kl.png" alt=""></p>
<ol>
<li>修改blog的主题：首先返回<strong>blog根目录中，打开 _config.yml 文件</strong>（建议备份一份，直接复制即可），然后在 _config.yml 中<strong>找到  theme选项</strong>（如果你使用vscode，则直接 ctrl+h搜索即可，否则就自己往下滑），然后把 <strong>theme 上输入 next，表示使用的主题是next</strong>（使用其他主题也是如此）</li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/nrs0i4.png" alt=""></p>
<ol>
<li>之后就成功！输入 localhost:4000 或者 hexo g， hexo d，然后输入 username.github.io， 离线或者在线都可以看到设置的next的主题，具体效果自己查看吧！</li>
</ol>
<h2 id="5-2-博客基本信息"><a href="#5-2-博客基本信息" class="headerlink" title="5.2 博客基本信息"></a>5.2 博客基本信息</h2><p>修改 博客的标题，副标题，描述，等等基本信息。。。</p>
<p>在 blog根目录下打开 _config.yml 配置文件，直接修改以下信息即可（看不懂英文的直接有道云翻译即可）</p>
<p>注意，语言要改成 zh-CN即中国，其他的自己随便改改</p>
<p><img src="https://tudingtu.cn/i/2023/03/03/nur4r6.png" alt=""></p>
<h2 id="5-3-创建新的菜单"><a href="#5-3-创建新的菜单" class="headerlink" title="5.3 创建新的菜单"></a>5.3 创建新的菜单</h2><p><strong>打开 themes 的 next 的 _config.yml ，我们此时打开的是主题的配置文件，不是根目录的。</strong></p>
<p>找到第118行或者 搜索menu，即可看到：这里其实就是我们的博客菜单选项。在一开始我们只有home和 archives是开着的，<strong>如果你想添加一个 tags或者about菜单该如何操作呢？</strong></p>
<p><img src="https://tudingtu.cn/i/2023/03/03/o07neg.png" alt=""></p>
<ol>
<li>首先在 blog的根目录中打开 git bash黑窗口，输入以下的命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags  # tags可以是其他的</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>然后在这个 _config 的menu中把 tags这一项取消注释</strong>，然后重新构建：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<ol>
<li>在localhost：4000中 看看效果：</li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/o2eke4.png" alt=""></p>
<p>添加完成之后，<strong>我们在 blog根目录中打开 source文件夹，即可看到我们的菜单文件夹， tags，打开后，它其实就是一个 md文档！你可以自己在md文档上编辑，然后重新构建看看效果！</strong></p>
<p><img src="https://tudingtu.cn/i/2023/03/03/o31yhd.png" alt=""></p>
<p>同理我们可以<strong>自己创建 菜单，输入 hexo new page xxx</strong>，然后在 <strong>主题的config_yml 的menu中按照其他的格式添加即可 。</strong></p>
<h2 id="5-4-添加搜索功能"><a href="#5-4-添加搜索功能" class="headerlink" title="5.4 添加搜索功能"></a>5.4 添加搜索功能</h2><p>打开博客的<strong>搜索文章的 功能</strong></p>
<p>下载<strong>搜索插件</strong>：</p>
<p>git bash黑窗口中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<ol>
<li>主题 的 _config 配置文件中找到 <strong>local_search</strong>，下面的 <strong>enable输入true即可。</strong></li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/ot2kta.png" alt=""></p>
<ol>
<li>在根目录的 _config.yml 文件中 的末尾添加下面的内容：（选项的内容可以适当修改）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo-generator-searchdb</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10</span><br></pre></td></tr></table></figure>
<p>重新构建后，即可看到效果：</p>
<p><img src="https://great.wzznft.com/i/2023/03/03/ovkwm1.png" alt=""></p>
<h2 id="5-5-添加阅读时间字数提示"><a href="#5-5-添加阅读时间字数提示" class="headerlink" title="5.5 添加阅读时间字数提示"></a>5.5 添加阅读时间字数提示</h2><p>效果如图：</p>
<p><img src="https://great.wzznft.com/i/2023/03/03/owxl01.png" alt=""></p>
<ol>
<li>git 黑窗口中输入以下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>在blog的根目录的 _config中 复制下面这段话到末尾</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br><span class="line">  exclude_codeblock: false</span><br><span class="line">  awl: 2	</span><br><span class="line">  wpm: 275</span><br><span class="line">  suffix: &quot;mins.&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li>在 <strong>主题的 config文件中找到，并且 输入 true即可，效果可以自行查看。</strong></li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/oyhmga.png" alt=""></p>
<h2 id="5-6-打赏功能"><a href="#5-6-打赏功能" class="headerlink" title="5.6 打赏功能"></a>5.6 打赏功能</h2><p>在 主题的 config中找到如下的 <strong>raward功能</strong></p>
<ol>
<li>enable选择打开，comment输入文字</li>
<li>在缀主题的images文件夹中把你的<strong>付款码的图片放到 /blog /themes /next /source /images/ 中</strong>，它会按照这个路径寻找图片</li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/03/oz699b.png" alt=""></p>
<p><strong>可以发现 这个images文件夹里面的图片都是可以修改的，找到合适的地点，然后更改你的 图片即可换成你想要的图片了。</strong></p>
<h2 id="5-7-切换主题"><a href="#5-7-切换主题" class="headerlink" title="5.7 切换主题"></a>5.7 切换主题</h2><p>在 主题的config文件夹中找到这个地方，<strong>直接注释或者取消注释即可</strong></p>
<p><img src="https://tudingtu.cn/i/2023/03/03/p28l6c.png" alt=""></p>
<h2 id="5-8-添加不蒜子统计"><a href="#5-8-添加不蒜子统计" class="headerlink" title="5.8 添加不蒜子统计"></a>5.8 添加不蒜子统计</h2><p>在主题的config文件中找到这个地方，直接enable输入true即可。它可以帮助我们<strong>统计网站的观看人数</strong></p>
<p><img src="https://tudingtu.cn/i/2023/03/03/p4k4l4.png" alt=""></p>
<h2 id="5-9-添加百度统计"><a href="#5-9-添加百度统计" class="headerlink" title="5.9 添加百度统计"></a>5.9 添加百度统计</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxOTc3Mi9hcnRpY2xlL2RldGFpbHMvMTIzMjczMTYz">为hexo的next主题添加百度统计功能，<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="…-待更新"><a href="#…-待更新" class="headerlink" title="… 待更新"></a>… 待更新</h2>]]></content>
      <tags>
        <tag>hexo博客配置</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数知识点总结</title>
    <url>/2023/03/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-行列式"><a href="#1-行列式" class="headerlink" title="1. 行列式"></a>1. 行列式</h1><p>行列式的定义：n*n个数字排成n行n列，叫做n阶行列式。</p>
<p>行列式的项数：</p>
<ol>
<li>2阶行列式有2项</li>
<li>3阶行列式有6项</li>
<li>4阶行列式有24项</li>
</ol>
<h2 id="1-1-余子式与代数余子式"><a href="#1-1-余子式与代数余子式" class="headerlink" title="1.1 余子式与代数余子式"></a>1.1 余子式与代数余子式</h2><p>余子式：关于一个k阶子式的余子式，是A去掉了这个k阶子式所在的行与列之后得到的（n－k）×（n－k）矩阵的行列式。</p>
<p>代数余子式：元素aₒₑi的代数余子式与该元素本身没什么关系，只与该元素的位置有关。</p>
<p><strong>行列式按行展开</strong></p>
<ul>
<li>行列式的值D = 任意一行（列）元素<em>自己的<em>*代数余子式</em></em>之和</li>
</ul>
<hr>
<p><strong>异乘变零定理</strong></p>
<ul>
<li>某行元素与另一行元素的代数余子式乘积之和=0</li>
</ul>
<hr>
<p>拉普拉斯定理（k阶子式）</p>
<ul>
<li>k=2<ul>
<li>2阶子式：取任意两行两列，交界的元素就是2阶子式</li>
<li>余子式：两行两列之外（剩余）的元素就是余子式</li>
<li>代数余子式：（-1）^（行1+行2+列1+列2）*余子式</li>
</ul>
</li>
</ul>
<p>拉普拉斯展开定理</p>
<ul>
<li>n阶行列式中，任意取定k行，由k行元素组成的所有<strong>k阶子式</strong>与<strong>代数余子式</strong>的乘积之和=行列式的值（D）</li>
</ul>
<hr>
<p>行列式相乘：（同阶行列式）三阶行列式：</p>
<ul>
<li><p>第一行</p>
<ul>
<li>第一行元素*第一列元素，元素对应先相乘再相加</li>
<li>第一行元素*第二列元素，…</li>
<li>第一行元素*第三列元素，… </li>
</ul>
</li>
<li><p>第二行</p>
<ul>
<li>第二行元素*第一列元素，…</li>
<li>第二行元素*第二列元素，…</li>
<li>第二行元素*第三列元素，… </li>
</ul>
</li>
<li><p>第三行</p>
<ul>
<li>第三行元素*第一列元素，…</li>
<li>第三行元素*第二列元素，…</li>
<li>第三行元素*第三列元素，… </li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-2-行列式计算"><a href="#1-2-行列式计算" class="headerlink" title="1.2 行列式计算"></a>1.2 行列式计算</h2><ul>
<li>化成上下三角</li>
<li><p>按行展开</p>
</li>
<li><p>制造<strong>行和</strong>：如图所示行列式</p>
</li>
</ul>
<script type="math/tex; mode=display">
\left|\begin{matrix}
    x & a & a \\
    a & x & a \\
    a & a & x 
   \end{matrix} \right|-> 
   (x+2a)\left|\begin{matrix}
    1 & a & a \\
    1 & x & a \\
    1 & a & x 
   \end{matrix} \right| ->
   (x+2a) \left|\begin{matrix}
    1 & 0 & 0 \\
    1 & x & 0 \\
    1 & 0 & x 
   \end{matrix} \right|(用第一列乘-a加到后两列去，形成下三角求和)</script><ul>
<li><p>加边法：不能改变原行列式的值</p>
</li>
<li><p>范德蒙德行列式：[<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/ojIPlvrfokpnooYzliJflvI8vNjA4MTI4OD9mcm9tdGl0bGU96IyD5b636JKZ5b636KGM5YiX5byPJmFtcDtmcm9taWQ9MTU5OTUzMzYmYW1wO2ZyPWFsYWRkaW4=">范德蒙行列式_百度百科 (baidu.com)<i class="fa fa-external-link-alt"></i></span>]</p>
</li>
<li><strong>反对称行列式</strong><ul>
<li>主对角线全为零 aii=-aii  aii=0</li>
<li>对角线对称位置对应成<strong>相反数</strong> aij=-aji</li>
<li>如果是<strong>奇数阶</strong>，则D=0（利用转置性质）</li>
</ul>
</li>
<li><strong>对称行列式</strong><ul>
<li>主对角线元素没有要求</li>
<li>对角线对称位置对应成<strong>相等</strong> aij=aji</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-3-克莱姆法则"><a href="#1-3-克莱姆法则" class="headerlink" title="1.3 克莱姆法则"></a>1.3 克莱姆法则</h2><p><strong>方程的个数等于未知量的个数</strong></p>
<ul>
<li>n个方程，n个未知量 </li>
<li><p>D !=0 ： <strong>Xi= Di/D</strong>  </p>
</li>
<li><p><strong>Di 表示的是把系数行列式中第 i 列的元素用 常数项列 替代</strong></p>
</li>
</ul>
<p>定理与推论：</p>
<ul>
<li>定理1：系数行列式D不等于0，则方程组有唯一解，解为：x1=D1/D,x2=D2/D ….<ul>
<li>推论1：线性方程组<strong>无解或者有多组不同的解</strong>，<strong>系数行列式D=0</strong></li>
</ul>
</li>
</ul>
<ul>
<li>定理2：齐次线性方程组的系数行列式 <strong>D!=0</strong>，则齐次线性方程组<strong>只有零解</strong><ul>
<li>齐次线性方程组有非零解的<strong>充要条件</strong> &lt;==&gt; D=0</li>
</ul>
</li>
</ul>
<p>简单来说： </p>
<ol>
<li>D!=0 ，只有零解</li>
<li>D=0，有非零解</li>
</ol>
<hr>
<h1 id="2-矩阵"><a href="#2-矩阵" class="headerlink" title="2. 矩阵"></a>2. 矩阵</h1><h2 id="2-1-矩阵的运算"><a href="#2-1-矩阵的运算" class="headerlink" title="2.1 矩阵的运算"></a>2.1 矩阵的运算</h2><h3 id="2-1-1-加法运算"><a href="#2-1-1-加法运算" class="headerlink" title="2.1.1 加法运算"></a>2.1.1 加法运算</h3><ul>
<li><p>同型矩阵才能相加减</p>
</li>
<li><p>对应行对应列的元素相加即可</p>
</li>
</ul>
<h3 id="2-1-2-数乘运算"><a href="#2-1-2-数乘运算" class="headerlink" title="2.1.2 数乘运算"></a>2.1.2 数乘运算</h3><ul>
<li>把矩阵的每一个元素都乘以k</li>
<li>矩阵的加减法与矩阵的数乘运算统称为<strong>矩阵的线性运算</strong></li>
</ul>
<h3 id="2-1-3-矩阵的乘法"><a href="#2-1-3-矩阵的乘法" class="headerlink" title="2.1.3 矩阵的乘法"></a>2.1.3 矩阵的乘法</h3><p>定义： 设A=(aij)m<em>s， B=(bij)s </em> n ,则C=(cij)m*n=AB</p>
<ul>
<li>只有当左边矩阵A的行数等于右边矩阵B的列数才能做乘法运算。</li>
<li><p>相乘后，结果矩阵的行数等于左边矩阵A的行数，列数等于右边矩阵B的列数。</p>
</li>
<li><p>矩阵cij的元素等于矩阵A的第i行与矩阵B第j列元素相乘后相加。</p>
</li>
<li><p>矩阵乘法与普通乘法运算规则不同</p>
</li>
<li>若矩阵满足AB=BA，则A和B是可交换的，仅当A和B可交换时，才满足交换律，结合律等数学公式</li>
</ul>
<h3 id="2-1-4-矩阵的幂运算"><a href="#2-1-4-矩阵的幂运算" class="headerlink" title="2.1.4 矩阵的幂运算"></a>2.1.4 矩阵的幂运算</h3><ul>
<li>将k个Aij连乘即为A的k次幂</li>
</ul>
<h2 id="2-2-矩阵的转置"><a href="#2-2-矩阵的转置" class="headerlink" title="2.2 矩阵的转置"></a>2.2 矩阵的转置</h2><ul>
<li>将矩阵Aij转换为Aji，即行列互换即为A的转置</li>
<li>（AB）的转置 = B转置*A转置</li>
<li>A的转置等于A，则A是对称矩阵</li>
<li>A的转置等于-A，则A是反对称矩阵</li>
</ul>
<h2 id="2-3-方阵的行列式"><a href="#2-3-方阵的行列式" class="headerlink" title="2.3 方阵的行列式"></a>2.3 方阵的行列式</h2><ul>
<li>N阶方阵的所有元素（Aij）n*n 按照原来的位置构成的的行列式，称为方阵A的行列式，记作 |A|或者 detA</li>
<li>方阵行列式：是一个数；方阵：是一个数表</li>
<li>方阵行列式的性质</li>
<li>A的n阶方阵，若|A|!=0，则A为非奇异矩阵，当 |A|=0，则A为奇异矩阵</li>
</ul>
<h2 id="2-4-伴随矩阵"><a href="#2-4-伴随矩阵" class="headerlink" title="2.4 伴随矩阵"></a>2.4 伴随矩阵</h2><ul>
<li>A=（aij）n<em>n 是n阶方阵，则行列式 |A|中的每个元素aij的<em>*代数余子式</em></em>Aij所构成的矩阵称为矩阵A的伴随矩阵</li>
<li><strong>A*在（i，j）上的位置元素等于 A在 （j，i）上的位置的元素的代数余子式！！！！！！！</strong></li>
<li><p>伴随的一般求法：</p>
<ul>
<li>二阶矩阵的伴随： 对角线元素互换，反对角线添负号</li>
<li>三阶矩阵的伴随：将矩阵<strong>转置后</strong>求<strong>代数余子式</strong></li>
</ul>
</li>
<li><p>A是n阶方阵，A<em>是A的伴随矩阵，则满足： AA </em>=A *A=|A|E</p>
</li>
</ul>
<h2 id="2-5-逆矩阵"><a href="#2-5-逆矩阵" class="headerlink" title="2.5 逆矩阵"></a>2.5 逆矩阵</h2><ul>
<li>对于n阶方阵A，存在一个n阶方阵B，使得AB=BA=E，则称A是<strong>可逆矩阵</strong>，B是A的<strong>逆矩阵</strong>。记作A-1=B</li>
<li>单位矩阵E是可逆的，它的逆矩阵等于自身，零矩阵不是可逆矩阵</li>
</ul>
<h3 id="2-5-1-逆矩阵性质"><a href="#2-5-1-逆矩阵性质" class="headerlink" title="2.5.1 逆矩阵性质"></a>2.5.1 逆矩阵性质</h3><ul>
<li>若方阵A可逆，则A的<strong>逆矩阵是唯一</strong>的： 若B，C都是A 的逆矩阵，则AB=AC=E，B=BE=B(AC)=C(AB)=CE，所以 A=B</li>
<li>AB=E，则AB均可逆，A-1=B，B-1=A，判断A是不是B的逆矩阵：判断AB=E</li>
<li><strong>方阵A可逆，则|A|!=0，且|A-1|=1/|A|</strong>，<strong>判断A是否可逆，则仅需判断 |A|！=0</strong> ，|A|！=0 &lt;==&gt; A可逆</li>
<li>方阵A可逆，则A-1也可逆，则（A-1）-1=A</li>
<li>方阵A可逆，且k！=0，则 （kA）-1= 1/k *（A-1）</li>
<li>方阵A可逆，则A转置也可逆，（A转置）-1=（A-1）转置</li>
<li>AB是同阶可逆矩阵，AB也可逆，则（AB）-1=B-1* A-1</li>
</ul>
<h3 id="2-5-2-逆矩阵的求法"><a href="#2-5-2-逆矩阵的求法" class="headerlink" title="2.5.2 逆矩阵的求法"></a>2.5.2 逆矩阵的求法</h3><ul>
<li>根据伴随矩阵（求低阶方阵逆矩阵） <strong>若A是非奇异矩阵（|A|不等于0，则A是可逆的），则A-1=1/|A| * A伴随</strong></li>
</ul>
<h3 id="2-5-3-逆矩阵的应用"><a href="#2-5-3-逆矩阵的应用" class="headerlink" title="2.5.3 逆矩阵的应用"></a>2.5.3 逆矩阵的应用</h3><ul>
<li>对于一个线性方程组： A是系数矩阵，B是常系数矩阵，X是未知数矩阵，因此线性方程组用矩阵表示为AX=B，<strong>因此求线性方程组的解，可以转换为求相应矩阵的解</strong></li>
</ul>
<h2 id="2-6-矩阵的初等变换"><a href="#2-6-矩阵的初等变换" class="headerlink" title="2.6 矩阵的初等变换"></a>2.6 矩阵的初等变换</h2><p>性质</p>
<ol>
<li>交换矩阵的 第 i 行（列）与第 j 行（列）</li>
<li>非零常数 k 乘以 矩阵的第 i 行（列）</li>
<li>矩阵的第 j 行乘以 k倍 加到第 i 行上去</li>
</ol>
<p>矩阵的初等行或者列变换统称为 <strong>矩阵的初等变换</strong></p>
<ul>
<li>矩阵A经过有限次初等变换变成B，则A与B<strong>等价</strong><ul>
<li>反身性</li>
<li>对称性</li>
<li>传递性</li>
</ul>
</li>
<li>矩阵的左上角为一个<strong>单位矩阵</strong>，其余元素都是零，则该矩阵为<strong>标准型矩阵</strong><ul>
<li>任何一个非奇异矩阵，经过有限次初等行变换都能变成<strong>单位矩阵 E</strong> </li>
<li>推论：<strong>矩阵A可逆的充要条件使它与单位矩阵E等价</strong></li>
</ul>
</li>
</ul>
<p>行变换转换为标准型矩阵的一般步骤:</p>
<ol>
<li>行变换 转换为 <strong>行阶梯型矩阵</strong></li>
<li>行阶梯形矩阵 转换为 <strong>行最简</strong></li>
<li>行最简 列变换转换为<strong>标准型</strong></li>
</ol>
<p><strong>单位矩阵的行数等于行阶梯非零行的行数</strong></p>
<hr>
<h3 id="2-6-1-初等矩阵"><a href="#2-6-1-初等矩阵" class="headerlink" title="2.6.1 初等矩阵"></a>2.6.1 初等矩阵</h3><p>三种初等变换：</p>
<ol>
<li>交换第 i 行 与第 j 行</li>
<li>非零常数乘以 第 i 行</li>
<li>第 j 行乘以k 加到第 i 行上去</li>
</ol>
<p>性质：</p>
<ol>
<li>初等矩阵都是可逆矩阵，且其逆矩阵也是同类型的初等矩阵</li>
<li>初等矩阵的转置仍是同类型的初等矩阵</li>
<li>对一个矩阵A施行一次<strong>初等行变换等于对 A左乘一个m阶单位矩阵</strong>；对矩阵A施行<strong>一次初等列变换相当于对A右乘一个n阶单位矩阵</strong></li>
</ol>
<h2 id="2-7-初等变换的应用"><a href="#2-7-初等变换的应用" class="headerlink" title="2.7 初等变换的应用"></a>2.7 初等变换的应用</h2><h3 id="2-7-1-求逆矩阵"><a href="#2-7-1-求逆矩阵" class="headerlink" title="2.7.1 求逆矩阵"></a>2.7.1 求逆矩阵</h3><ul>
<li><strong>对矩阵 A 与 E做相同的初等变换等于对矩阵A 做初等行变换化为单位矩阵E时，E就变成了A的逆矩阵A-1</strong>（单位矩阵E乘以任何矩阵A，都等于矩阵A本身）</li>
</ul>
<script type="math/tex; mode=display">
(A,E)->(E,A^{-1})</script><p>初等列变换也是同理</p>
<h3 id="2-1-2-求解矩阵方程"><a href="#2-1-2-求解矩阵方程" class="headerlink" title="2.1.2 求解矩阵方程"></a>2.1.2 求解矩阵方程</h3><p>在矩阵A，B，C均可逆的前提下：</p>
<ol>
<li>AX=B，则 X=A-1B</li>
<li>XA=B，则 X=BA-1</li>
<li>AXB=C，则 X=A-1CB-1 </li>
</ol>
<ul>
<li>对矩阵 A 与 E做相同的初等变换等于对矩阵A 做初等行变换化为单位矩阵E时，E就变成了A的逆矩阵A-1</li>
</ul>
<script type="math/tex; mode=display">
(A,B)-^{初等行变换}->(E,A^{-1}B)</script><p>初等列变换也是同理</p>
<hr>
<h2 id="2-9-行最简矩阵与矩阵的秩"><a href="#2-9-行最简矩阵与矩阵的秩" class="headerlink" title="2.9 行最简矩阵与矩阵的秩"></a>2.9 行最简矩阵与矩阵的秩</h2><h3 id="2-9-1-行最简矩阵"><a href="#2-9-1-行最简矩阵" class="headerlink" title="2.9.1 行最简矩阵"></a>2.9.1 行最简矩阵</h3><p>行阶梯形矩阵：</p>
<ol>
<li>零行位于所有非零行的下面。</li>
<li>首非零元前面零的个数一定逐行严格增加</li>
</ol>
<p><strong>行最简型矩阵：</strong></p>
<ol>
<li>行阶梯形矩阵经过初等行变换使得 <strong>每一行的首非零元全部变为1，且他们所在列的其他元素都是 0</strong>，则成这样的矩阵为 <strong>行最简型矩阵</strong></li>
</ol>
<h3 id="2-9-2-矩阵的秩"><a href="#2-9-2-矩阵的秩" class="headerlink" title="2.9.2 矩阵的秩"></a>2.9.2 矩阵的秩</h3><p>定义：在矩阵A中，<strong>不为零子式的最高阶数称为A的秩</strong>，r（A）=min（m，n），则A为满秩矩阵，否则为降秩矩阵</p>
<p>性质：</p>
<ul>
<li>任意矩阵A与秩满足： 0&lt;=r(A)&lt;=min(m,n)</li>
<li><p>矩阵A可逆，则|A|不为零，则与 r（A）=n 形成<strong>充分必要条件</strong>，矩阵A为<strong>满秩矩阵</strong></p>
<ul>
<li><strong>n阶方阵可逆的充要条件：r(A)=n</strong></li>
</ul>
</li>
<li><p><strong>行阶梯形矩阵的秩等于它非零行的行数或者首非零元的个数</strong></p>
</li>
</ul>
<p>求矩阵秩的一般方法：<strong>用初等变换将矩阵转换为阶梯型矩阵</strong></p>
<p>关于秩的相关结论：</p>
<ol>
<li>矩阵A的 n 阶子式全为0，则 r(A)&lt;n</li>
<li>矩阵A的 n 阶子式全不为0，则 r(A)&gt;=n</li>
<li>若矩阵A与B等价，则 r(A)=r(B)</li>
<li>若矩阵Q，P可逆，则 r(PA)=r(AQ)=r(PAQ)=r(A)</li>
</ol>
<h3 id="2-9-3-分块矩阵"><a href="#2-9-3-分块矩阵" class="headerlink" title="2.9.3 分块矩阵"></a>2.9.3 分块矩阵</h3><hr>
<h1 id="3-向量组的线性相关性"><a href="#3-向量组的线性相关性" class="headerlink" title="3. 向量组的线性相关性"></a>3. 向量组的线性相关性</h1><p>向量的线性运算</p>
<p><strong>线性方程组的向量形式： a1x1+a2x2+a3x3+ … a4x4=B，借助向量可以讨论线性方程组</strong></p>
<h2 id="3-1-向量组的线性关系"><a href="#3-1-向量组的线性关系" class="headerlink" title="3.1 向量组的线性关系"></a>3.1 向量组的线性关系</h2><h3 id="3-1-1-线性组合与线性表示"><a href="#3-1-1-线性组合与线性表示" class="headerlink" title="3.1.1 线性组合与线性表示"></a>3.1.1 线性组合与线性表示</h3><p>定义：设 n维向量组 a1，a2，a3 ，B</p>
<ol>
<li><p>若k1，k2，k3为任意一组常数，则称 k1a1+k2a2+k3a3…+k4a4为向量组 a1+a2+a3的一个<strong>线性组合</strong></p>
</li>
<li><p>若k1，k2，k3为任意一组常数，使得 B=k1a1+k2a2+k3a3+…knan成立，则称B可由向· 量组<strong>线性表示</strong></p>
</li>
</ol>
<p><strong>向量B是否可由a1,a2,a3,an线性表示的方法：判断线性方程组k1a1+k2a2+knan是否有解</strong></p>
<h3 id="3-1-2-线性相关与线性无关"><a href="#3-1-2-线性相关与线性无关" class="headerlink" title="3.1.2 线性相关与线性无关"></a>3.1.2 线性相关与线性无关</h3><ol>
<li>若存在一组<strong>不全为零</strong>的数 k1,k2,k3,kn 使得 k1a1+k2a2+…+knan =0 成立，则称a1,a2,a3是<strong>线性相关</strong>的</li>
<li>当且仅当 k1,k2,k3,kn <strong>全为零</strong> 使得 k1a1+k2a2+…+knan =0 成立，则称a1,a2,a3是<strong>线性无关</strong>的</li>
</ol>
<p>简单来说：</p>
<ol>
<li><strong>线性相关：有非零解</strong></li>
<li><strong>线性无关：只有零解</strong></li>
</ol>
<p><strong>判断一个向量组的线性关系的方法：</strong></p>
<ol>
<li>令 k1a1+k2a2+…+knan =0，求出 k1,k2,k3的值</li>
<li><strong>如果全为零：线性无关；不全为零：线性相关</strong></li>
</ol>
<hr>
<h3 id="3-1-3-线性相关性结论-重要"><a href="#3-1-3-线性相关性结论-重要" class="headerlink" title="3.1.3 线性相关性结论(重要)"></a>3.1.3 线性相关性结论(重要)</h3><ul>
<li><strong>s个n维 即n*s形式的矩阵：</strong>  线性方程组<strong>线性相关的充要条件是齐次线性方程组有非零解</strong>，<strong>线性无关的充要条件是齐次线性方程组只有零解</strong><ul>
<li><strong>n个n维 即方阵：向量组线性相关的充要条件是行列式的值为0；线性无关的充要条件是行列式的值不为0.</strong></li>
<li><strong>向量组所含向量的个数大于维数，向量组一定线性相关</strong></li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>方阵形式：直接判断行列式的值是否为零，线性相关D为0，线性无关D不为0</li>
<li>行数大于列数的矩阵：判断齐次线性方程组的解，线性相关有非零解，线性无关只有零解</li>
<li>列数大于行数的矩阵：向量个数大于维数，一定线性相关</li>
</ol>
</blockquote>
<ul>
<li>向量组 a1  a2  am线性<strong>相关</strong>的充分必要条件是：其中至少有一个向量可由其余m -1 个向量线性表示<ul>
<li>向量组 a1  a2  am线性<strong>无关</strong>的充分必要条件是：其中每一个向量都不能由其余m -1 个向量线性表示</li>
</ul>
</li>
<li>若向量组 a1  a2  am线性无关，而向量组 a1  a2  a3 B线性相关，<strong>则 B可由 a1  a2  a3 线性表示，且表达式唯一</strong></li>
<li>若部分线性相关，则整个向量组也线性相关<ul>
<li>若整体线性无关，则任意一个部分也线性无关</li>
</ul>
</li>
<li>如果n维向量组 a1  a2  an线性无关，则在每一个向量上都添加 m 个分量，得到的 <strong>n+m 维接长的向量组也线性无关</strong><ul>
<li>如果n维向量组 a1  a2  an线性相关，则在每一个向量上都减去 m 个分量，得到的 <strong>n-m 维截断的向量组也线性相关</strong></li>
</ul>
</li>
</ul>
<h2 id="3-2-向量组的秩"><a href="#3-2-向量组的秩" class="headerlink" title="3.2 向量组的秩"></a>3.2 向量组的秩</h2><h3 id="3-2-1-向量组的极大无关组"><a href="#3-2-1-向量组的极大无关组" class="headerlink" title="3.2.1 向量组的极大无关组"></a>3.2.1 向量组的极大无关组</h3><p>定义：设向量组T： a1 ,  a2 , a3 … an 中有一部分向量组 a1  a2   a3   ar （r&lt;n）满足</p>
<ol>
<li>a1 a2 a3  ar<strong>线性无关</strong></li>
<li>在向量组T中除去（1-r）任取一个向量 ai，<strong>满足 a1 a2  a3 ar，ai 线性相关</strong>，则称 a1  a2  a3  ar是向量组T的一个<strong>极大线性无关组</strong>。简称为极大无关组</li>
</ol>
<p>根据上节的结论:</p>
<blockquote>
<p>若向量组 a1  a2  am线性无关，而向量组 a1  a2  a3 B线性相关，<strong>则 B可由 a1  a2  a3 线性表示，且表达式唯一</strong></p>
</blockquote>
<p>可得：<strong>向量组T中任意向量 ai 都可由 a1  a2   a3   ar线性表示</strong></p>
<p>极大无关组不一定是唯一的，只含零向量的向量组没有极大无关组</p>
<hr>
<p>定义2：设有两个向量组1，2，向量组2中的每一个元素都可由向量组1线性表示，则<strong>称向量组2可由向量组1线性表示</strong>，否则称不可线性表示。</p>
<ul>
<li>若两个向量组1和2可以<strong>互相</strong>线性表示，则称他们<strong>等价</strong></li>
</ul>
<p>定理：</p>
<ul>
<li><strong>若向量组1可以由向量组2线性表示，且向量组1的元素个数大于向量组2的元素个数，则向量组1线性相关</strong></li>
</ul>
<h3 id="3-2-2-向量组的秩的定义"><a href="#3-2-2-向量组的秩的定义" class="headerlink" title="3.2.2 向量组的秩的定义"></a>3.2.2 向量组的秩的定义</h3><p>定义： 向量组T的极大无关组所包含向量的个数，称为向量组的的秩</p>
<p>定理：</p>
<ul>
<li>向量组 a1 a2  as<strong>线性无关</strong>的充要条件是 r(a1 a2 as)=s，即<strong>它的秩等于它所包含的向量的个数</strong></li>
<li>相互等价的向量组的秩相等</li>
<li><strong>如果两个向量组的秩相等，且其中一个向量组可由另一个线性表示，则两个向量组等价</strong></li>
</ul>
<blockquote>
<ol>
<li>秩的个数等于向量的个数，线性无关</li>
<li>秩的个数小于向量的个数，线性相关</li>
</ol>
</blockquote>
<p>行向量组与列向量组：</p>
<ul>
<li>行向量组的秩为<strong>行秩</strong>，列向量组的秩为<strong>列秩</strong></li>
<li><strong>行秩=列秩=矩阵的秩</strong></li>
</ul>
<p><strong>求向量组极大无关组的方法：先将列向量组构成矩阵A，然后对A实行初等行变换，把A化为行最简型矩阵，由行最简型矩阵列之间的关系，确定原向量组间的线性关系，从而确定极大无关组。</strong></p>
<h2 id="3-3-向量空间"><a href="#3-3-向量空间" class="headerlink" title="3.3 *向量空间"></a>3.3 *向量空间</h2><hr>
<h1 id="4-线性方程组"><a href="#4-线性方程组" class="headerlink" title="4. 线性方程组"></a>4. 线性方程组</h1><p>阶梯型方程组：对线性方程组做初等变换所得到的就是<strong>阶梯型方程组</strong></p>
<ul>
<li>系数矩阵：由未知数的系数所构成的矩阵称为线性方程组的<strong>系数矩阵</strong></li>
<li>线性方程组的系数和常数项所构成的矩阵称为线性方程组的<strong>增广矩阵</strong></li>
</ul>
<h2 id="4-1-消元法解线性方程组"><a href="#4-1-消元法解线性方程组" class="headerlink" title="4.1 消元法解线性方程组"></a>4.1 消元法解线性方程组</h2><ol>
<li><p>就是对方程组的增广矩阵做初等行变换，化为<strong>阶梯型矩阵</strong>，从而得到方程组的解</p>
</li>
<li><p>对增广矩阵化为<strong>行最简型矩阵</strong>，更容易求解</p>
</li>
</ol>
<blockquote>
<p>有无解的判定：</p>
<p>增广矩阵的秩 = 系数矩阵的秩 = 未知量的个数，则方程组 Ax=b 具有<strong>唯一解</strong></p>
<p>增广矩阵的秩 不等于 系数矩阵的秩，则方程组Ax=b<strong>无解</strong>，存在一行，满足系数项全为零，而常数项不为零</p>
</blockquote>
<h2 id="4-2-非齐次线性方程组解的判定"><a href="#4-2-非齐次线性方程组解的判定" class="headerlink" title="4.2 非齐次线性方程组解的判定"></a>4.2 非齐次线性方程组解的判定</h2><ul>
<li>线性方程组 Amn <em> X=b <em>*有解</em></em>的 充要条件 是 r（A，b）= r（A）</li>
<li>当线性方程组 Amn <em> X=b 有解时：<em>*r 为秩，n为系数项数，即未知量的个数</em></em><ul>
<li>若  r（A，b）= r（A）=<strong>r = n</strong>，方程组有<strong>唯一解</strong></li>
<li>若  r（A，b）= r（A）=<strong>r &lt; n</strong>，方 程组有<strong>无穷多解</strong></li>
</ul>
</li>
<li>同理， Amn <em> X =b <em>*无解</em></em>的充要条件是 r（A，b）!=r（A）</li>
</ul>
<h2 id="4-3-齐次线性方程组解的判定"><a href="#4-3-齐次线性方程组解的判定" class="headerlink" title="4.3 齐次线性方程组解的判定"></a>4.3 齐次线性方程组解的判定</h2><p>齐次线性方程组一定满足：r（A，b）=r（A）</p>
<ul>
<li>齐次线性方程组Amn <em> X=0 <em>*只有零解的充要条件是 r（A）= n</em></em></li>
<li>齐次线性方程组Amn <em> X=0 <em>*有非零解的充要条件是 r（A）&lt; n</em></em>（有非零解即为无穷多解）</li>
</ul>
<h2 id="4-4-齐次线性方程组的解的结构"><a href="#4-4-齐次线性方程组的解的结构" class="headerlink" title="4.4 齐次线性方程组的解的结构"></a>4.4 齐次线性方程组的解的结构</h2><p>解向量的概念</p>
<p><strong>若齐次线性方程组有非零解，则它会有无穷多解，这些解组成一个n维向量组，若能求出这个向量组的一个极大无关组，则就能用它来表示它的全部解，这个极大无关组称为齐次线性方程组的基础解系</strong></p>
<p>齐次线性方程组有非零解，则它一定有基础解系。</p>
<ul>
<li><p>定理1：<strong>如果齐次线性方程组Amn <em> X=0 的系数矩阵A的秩 r（A）= r &lt; n，则Amn </em> X=0 的基础解系中有 n-r个解向量</strong></p>
</li>
<li><p><strong>齐次线性方程组的基础解系求解</strong></p>
</li>
<li><p><strong>非齐次线性方程组的基础解系求解</strong></p>
</li>
</ul>
<h2 id="4-5-非齐次线性方程组的解的结构"><a href="#4-5-非齐次线性方程组的解的结构" class="headerlink" title="4.5 非齐次线性方程组的解的结构"></a>4.5 非齐次线性方程组的解的结构</h2><p>非齐次线性方程组的解的结构为：非齐次线性方程组的特解 + 齐次线性方程组的通解。</p>
<hr>
<blockquote>
<p>求线性方程组通解的一般步骤</p>
<p>齐次线性方程组：</p>
<ol>
<li>对于增广矩阵化简为 <strong>行最简型矩阵</strong></li>
<li>判断解的情况并且得到解向量的个数=n-r</li>
<li>通过行最简矩阵得到<strong>自由未知量</strong>，首非零元与自由未知量确定方程，求方程解，得到各个未知量的解，并且得到每一个<strong>基础解系</strong></li>
<li>通解为 各个基础解系的k倍和</li>
</ol>
<p>非齐次线性方程组：</p>
<ol>
<li>步骤与上面基本一致，但是通解为：特解 + 导出组（导出组指的是常数项为0）的基础解系</li>
</ol>
</blockquote>
<hr>
<h1 id="5-矩阵相似与对角化"><a href="#5-矩阵相似与对角化" class="headerlink" title="5. 矩阵相似与对角化"></a>5. 矩阵相似与对角化</h1><h2 id="5-1-特征值与特征向量"><a href="#5-1-特征值与特征向量" class="headerlink" title="5.1 特征值与特征向量"></a>5.1 特征值与特征向量</h2><p>定义1：<strong>设A=（aij）nn为n阶实方阵，如果存在某个非零 r 和某个n维非零列向量 p 满足： Ap=rp，则 r 是A 一个特征值，p是A的属于特征值为r 的一个特征向量</strong></p>
<p>定义2：带参数r的n阶方阵称为A的<strong>特征方阵</strong>；它的行列式称为A的<strong>特征多项式</strong>；|rE-A|=0称为A的<strong>特征方程</strong></p>
<p>求解特征值与特征向量的方法：</p>
<ul>
<li><strong>n阶实方阵的特征值就是它的特征方程的n个根</strong></li>
<li><strong>任意取定一个特征值，其对应特征向量就是相应齐次线性方程组（rE-A）x=0 的所有非零解</strong>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </li>
</ul>
<hr>
<h2 id="5-2-特征值与特征向量的若干结论"><a href="#5-2-特征值与特征向量的若干结论" class="headerlink" title="5.2 特征值与特征向量的若干结论"></a>5.2 特征值与特征向量的若干结论</h2><ol>
<li><p><strong>实方阵的特征值未必是实数，特征向量也未必是实向量</strong></p>
</li>
<li><p>上下三角矩阵的特征值就是它的<strong>全体对角元素</strong></p>
</li>
<li>一个向量p不可能是属于同一个方阵A的不同特征值的特征向量</li>
<li>n阶方阵和它的转置具有相同的特征值</li>
<li>r1  r2  r3 为A的全体特征值则必有：即<strong>特征值之和等于对角线元素之和（迹）</strong>，<strong>特征值之积等于行列式的值</strong></li>
</ol>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}\lambda_{i}=\sum_{i=1}^{n}a_{ii}=tr(A) \qquad \prod_{i=1}^{n}\lambda_{i}=|A|</script><ol>
<li><strong>只要 r 是A的特征值，那么 f(r) 一定是 f(A) 的特征值</strong></li>
</ol>
<hr>
<h3 id="5-2-1-求特征值和特征向量的一般方法"><a href="#5-2-1-求特征值和特征向量的一般方法" class="headerlink" title="5.2.1 求特征值和特征向量的一般方法"></a>5.2.1 求特征值和特征向量的一般方法</h3><p>步骤：</p>
<ol>
<li><p>求出特征值，检查特征值之和是否等于行列式对角线元素之和，即<strong>迹</strong>，特征值之积是否等于行列式的值。</p>
</li>
<li><p>属于特征值的特征向量全体是 …   </p>
</li>
</ol>
<h2 id="5-3-相似矩阵与可对角化的条件"><a href="#5-3-相似矩阵与可对角化的条件" class="headerlink" title="5.3 相似矩阵与可对角化的条件"></a>5.3 相似矩阵与可对角化的条件</h2><p>定义1： A与B是n阶方阵，如果存在一个n阶可逆矩阵P，使得 P-1AP=B，则称A与B相似，记作A~B</p>
<p><strong>相似矩阵具有对称性，传递性，反身性</strong></p>
<p>两矩阵相似的特征：</p>
<ol>
<li>相同的特征值</li>
<li>相同的行列式值</li>
<li>迹相等，即对角线元素之和相同</li>
<li>秩相同</li>
</ol>
<h3 id="5-3-1-矩阵可对角化"><a href="#5-3-1-矩阵可对角化" class="headerlink" title="5.3.1 矩阵可对角化"></a>5.3.1 矩阵可对角化</h3><p><strong>定理3：n阶方阵相似于n阶对角矩阵的充要条件：A有n个线性无关的特征向量</strong></p>
<p><strong>推论：如果n阶矩阵A有n个互不相同的特征值 r1 r2  r3  r4 … rn，则A与对角矩阵 相似，并且对角矩阵的对角线元素为 r1 r2  r3  r4 … rn。</strong></p>
<p>n阶矩阵与对角矩阵相似的充分必要条件是：对于A的每一个n重特征值，齐次线性方程组（rE-A）x=0 的基础解系中恰含n个向量</p>
<h2 id="5-4-向量的内积与正交矩阵"><a href="#5-4-向量的内积与正交矩阵" class="headerlink" title="5.4 向量的内积与正交矩阵"></a>5.4 向量的内积与正交矩阵</h2><h3 id="5-4-1-内积"><a href="#5-4-1-内积" class="headerlink" title="5.4.1 内积"></a>5.4.1 内积</h3><p>概念：两个矩阵的对应元素相乘再相加，得到的一个<strong>数值</strong>，是两个矩阵的内积，记作：[A，B]</p>
<ul>
<li>施瓦茨不等式</li>
</ul>
<p>定义2<strong>：向量的内积开根号 叫做向量的长度，向量的长度用||A||表示</strong>，例如：a=(a1,a2,a3) ， ||a||=根号下[a,a]，</p>
<ul>
<li>若 ||a||=1，称a为单位向量</li>
</ul>
<h3 id="5-4-2-正交向量组"><a href="#5-4-2-正交向量组" class="headerlink" title="5.4.2 正交向量组"></a>5.4.2 正交向量组</h3><p>定义：若[a,b]=0，则向量a，b正交</p>
<p><strong>由非零向量两两正交组成的向量组称为正交向量组</strong></p>
<ul>
<li>正交向量组内每一个ai一定是线性无关的</li>
</ul>
<hr>
<p>施密特正交化：正交化 -&gt; 单位化</p>
<h1 id="6-二次型"><a href="#6-二次型" class="headerlink" title="6. 二次型"></a>6. 二次型</h1><p>含n个变量的 二次齐次多项式称为一个n元二次型，简称二次型</p>
<ul>
<li>令A为一个实对称矩阵，二次型式用矩阵表示为 f=x^T Ax  <ul>
<li>A称为二次型f的矩阵，对称阵A的秩为二次型f的秩</li>
<li>二次型与对称阵具有一一对应的关系，<strong>一个二次型f由其对应的实对称矩阵A唯一确定。当给定了二次型f后，便可以确定其对应的实对称矩阵A</strong><ul>
<li>A的对角线元素为：aii为xi ^2项的<strong>系数</strong></li>
<li>A的其他元素为： aij = aji 为 xij 项的<strong>系数的 1/2</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-1-可逆变换"><a href="#6-1-可逆变换" class="headerlink" title="6.1 可逆变换"></a>6.1 可逆变换</h2><p>若C 是可逆矩阵，x=Cy为可逆线性变换；若C是正交矩阵，则x=Cy为正交线性变换</p>
<p><strong>定义： 如果A，B均为n阶方阵，若存在可逆矩阵C，使得 CT A C =B，则称A与B合同</strong></p>
<ul>
<li>如果A为对称矩阵，AB合同，则B也为对称矩阵</li>
<li>A与B合同，则R（A）=R（B）</li>
<li>合同具有传递性</li>
</ul>
<h2 id="6-2-二次型的标准型"><a href="#6-2-二次型的标准型" class="headerlink" title="6.2 二次型的标准型"></a>6.2 二次型的标准型</h2><p><strong>定义：只含平方项的 二次型称为二次型的标准型</strong></p>
<p>正交变换法化二次型为标准型的方法：</p>
<ol>
<li>写出二次型的矩阵A，求其特征值 </li>
<li>求出特征值对应的特征向量，并且将他们正交单位化</li>
<li>将正交单位化后的特征向量依次作为列向量构成正交矩阵P。</li>
<li>做正交变换 x=Py，得二次型的标准型</li>
</ol>
<blockquote>
<p>正交单位化的时候：</p>
<ol>
<li>如果对应不同的特征值，所以他们正交，直接单位化即可</li>
<li>如果对应相同的特征值，所以要首先正交化，然后再单位化</li>
</ol>
</blockquote>
<h3 id="6-2-1-配方法化二次型为标准型"><a href="#6-2-1-配方法化二次型为标准型" class="headerlink" title="6.2.1 配方法化二次型为标准型"></a>6.2.1 配方法化二次型为标准型</h3><h3 id="6-2-2-初等变换化二次型为标准型"><a href="#6-2-2-初等变换化二次型为标准型" class="headerlink" title="6.2.2 初等变换化二次型为标准型"></a>6.2.2 初等变换化二次型为标准型</h3><h2 id="6-3-正定二次型"><a href="#6-3-正定二次型" class="headerlink" title="6.3 正定二次型"></a>6.3 正定二次型</h2><p>判别方法：f=xT A x正定的充要条件是 矩阵A的特征值都是正数</p>
<p><strong>实对阵矩阵A正定的充要条件是 A的各阶顺序子式都大于0</strong></p>
<hr>
<h1 id="待完善"><a href="#待完善" class="headerlink" title="待完善 ~~~"></a>待完善 ~~~</h1>]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>A星寻路算法详解</title>
    <url>/2023/03/01/A%E6%98%9F%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>@[toc]</p>
<h2 id="三种寻路算法"><a href="#三种寻路算法" class="headerlink" title="三种寻路算法"></a>三种寻路算法</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pqNjY2NmRqZGJiZC9hcnRpY2xlL2RldGFpbHMvMTI2MjA1Nzcw">深度寻路算法：不一定能找到最佳路径，但是寻路快速，只能走直线。<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pqNjY2NmRqZGJiZC9hcnRpY2xlL2RldGFpbHMvMTI2MjY1MTk5">广度寻路算法：一定能找到最短路径，但是开销大，时间慢，只能走直线。<i class="fa fa-external-link-alt"></i></span></li>
<li><strong>A星寻路算法</strong>（常用）：一定能找到最短路径，可以走直线和斜线，而且开销较小，常用于大型地图的寻路</li>
</ul>
<h1 id="A星寻路算法"><a href="#A星寻路算法" class="headerlink" title="A星寻路算法"></a>A星寻路算法</h1><h2 id="A星寻路算法思想"><a href="#A星寻路算法思想" class="headerlink" title="A星寻路算法思想"></a>A星寻路算法思想</h2><blockquote>
<p>引入： 狼吃羊模型。</p>
<p>狼捕猎羊：如果抓到了就加100分；如果狼不动，每分钟减2分；如果狼抓捕时会跑，跑步每分钟减5分；</p>
<p>​     狼会饿 ，饿的时候每分钟减10分。 有一个积分的概念在这里面。结果会发现<strong>狼会站在原地不动</strong>。</p>
<p>​    因为狼直到，抓住羊很困难，跑步时会扣分，饿时会扣分，不动时也会扣分。但是人工智能狼计算出了站着不动时扣分的代价最低，而干其他事代价都高，因此狼会自动选择代价最低的方式，一动不动</p>
<p>​    之后又加了设定：原地不动每分钟也扣分，而且是线性扣分。结果你会发现<strong>狼从一开始就会自杀</strong>。</p>
<p>同理，<strong>自杀是代价最小的选择</strong>（即分数最高，如果你干其他的事，则可能会负分，所以狼会选择自杀）。</p>
</blockquote>
<p>A星寻路算法也引入了这一概念，即通过<strong>计算和量化行走的各个方向的代价</strong>，来<strong>选择最优路径</strong></p>
<ul>
<li><strong><em>公式： f = g + h</em></strong></li>
<li>f： 设定其为<strong>最终评估代价</strong></li>
<li>g：当前点走到下一点的<strong>付出的代价</strong></li>
<li>h：当前点到终点的<strong>预期代价</strong></li>
<li>通过比较各条路线的最终代价，选择<strong>最小代价</strong>，即为合适的路径，也为<strong>最短路径</strong>。</li>
</ul>
<h2 id="A星寻路准备"><a href="#A星寻路准备" class="headerlink" title="A星寻路准备"></a>A星寻路准备</h2><p>地图行列数，方向枚举，地图，辅助地图的设计等在此不描述，具体请看之前我写的前两种寻路算法的博客。<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pqNjY2NmRqZGJiZC9hcnRpY2xlL2RldGFpbHMvMTI2MjY1MTk5P3NwbT0xMDAxLjIwMTQuMzAwMS41NTAy">广度寻路算法<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pqNjY2NmRqZGJiZC9hcnRpY2xlL2RldGFpbHMvMTI2MjA1NzcwP3NwbT0xMDAxLjIwMTQuMzAwMS41NTAy">深度寻路算法<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><strong>记录坐标点的类型</strong>，GetH和GetF函数即为计算各种代价的函数，稍后会介绍。一个重载用来比较当前点是否到达终点</li>
</ul>
<blockquote>
<p>h表示当前点到终点的预期代价，因此我们每次移动一步，都需要求出 h，而h的计算我们可以直接通过数格子来获得，即水平，竖直个有几个格子，这便是<strong>预期的代价</strong><br>g表示走到每一点的代价，因此每走一个方向，记录这个方向的代价， 最后选择代价最小的方向即可，g可以通过遍历八个方向来记录<br>f =g + h</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mypoint</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> row;</span><br><span class="line">	<span class="type">int</span> col;</span><br><span class="line">	<span class="type">int</span> f, g, h;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">return</span> (pos.row == row &amp;&amp; pos.col == col);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetH</span><span class="params">(<span class="type">const</span> Mypoint&amp; Begpos, <span class="type">const</span> Mypoint&amp; Endpos)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">abs</span>(Begpos.col - Endpos.col);<span class="comment">//计算水平差距</span></span><br><span class="line">		<span class="type">int</span> y = <span class="built_in">abs</span>(Begpos.row - Endpos.row);<span class="comment">//计算垂直差距</span></span><br><span class="line">		h = x + y;<span class="comment">//计算总的差距</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetF</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		f = g + h;<span class="comment">//计算f</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>存储位置节点的树结构</strong>，含有构造函数用来构建树节点，<strong>vector数组</strong>存储多个节点：因为一个父亲会有多个孩子的情况。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树结构存储节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">	Mypoint pos;<span class="comment">//当前点坐标</span></span><br><span class="line">	TreeNode* pParent;<span class="comment">//当前点的父节点</span></span><br><span class="line">	vector&lt;TreeNode*&gt; pChild;	<span class="comment">//存储当前点的所有孩子节点</span></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pos = pos;</span><br><span class="line">		pParent = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>判断是否能走的函数</strong>，用于判断地图某个点是否能走，即不为墙，没越界，没走过，则能走。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断某个点能否走</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CanWalk</span><span class="params">(<span class="type">int</span> map[ROW][COL], <span class="type">bool</span> vis[ROW][COL], <span class="type">const</span> Mypoint&amp; pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果越界，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (pos.row &lt; <span class="number">0</span> || pos.col &lt; <span class="number">0</span> || pos.row &gt;= ROW || pos.col &gt;= COL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是墙，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (map[pos.row][pos.col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果已经走过，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (vis[pos.row][pos.col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//否则能走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数据的准备</strong></li>
</ul>
<ol>
<li>起点与终点的坐标</li>
<li>树根节点，用于保存寻路的<strong>树结构</strong></li>
<li>buff数组来记录每一个孩子节点，<strong>用来确定下一步该走的点</strong></li>
<li>vis标记数组，不能重复走</li>
<li>当前点与试探点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//地图，1表示墙，0表示路径</span></span><br><span class="line">	<span class="type">int</span> map[ROW][COL] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//起始点和终点</span></span><br><span class="line">	Mypoint Begpos = &#123; <span class="number">1</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	Mypoint Endpos = &#123; <span class="number">6</span>,<span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//标记有没有走过</span></span><br><span class="line">	<span class="type">bool</span> vis[ROW][COL] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建树根，即根节点</span></span><br><span class="line">	TreeNode* pRoot = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(Begpos);</span><br><span class="line"></span><br><span class="line">	vector&lt;TreeNode*&gt; buff;	<span class="comment">//存储孩子节点的数组</span></span><br><span class="line"></span><br><span class="line">	TreeNode* pCurrent = pRoot;	<span class="comment">//记录当前点</span></span><br><span class="line">	TreeNode* pTemp = <span class="literal">nullptr</span>;	<span class="comment">//试探节点,用于试探下一个位置的点</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> isFindEnd = <span class="literal">false</span>;<span class="comment">//终点标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="A星寻路过程（图例）"><a href="#A星寻路过程（图例）" class="headerlink" title="A星寻路过程（图例）"></a>A星寻路过程（图例）</h2><p>假定<strong>直着走的代价为10，斜着走的代价为14</strong></p>
<ul>
<li><p>首先计算起点位置周围八个方向<strong>付出代价</strong>（蓝色），此代价为<strong>付出的代价 g</strong>。<br><img src="https://img-blog.csdnimg.cn/15215e45fdd948fda712c731eb17c42f.png" alt="在这里插入图片描述"></p>
</li>
<li><p>然后再计算<strong>起点到终点的代价</strong>（如何计算：数格子即可，某个点到终点的格子数，只能行列，不能斜着），此代价为<strong>预期代价h</strong>，可以发现 <strong>最终代价=付出+预期</strong>，可以得到一个<strong>最小的代价点</strong>，即<strong>右下角的斜着的点</strong>。</p>
<p><strong>这个点即是我们下一步要走的点</strong>。<strong>依次类推，在下个点上，再次计算周围代价最小的点，然后再次移动</strong></p>
</li>
</ul>
<hr>
<p>upd： 2023. 2.22 新增一个图<br><img src="https://img-blog.csdnimg.cn/a88609b83bba49f49c4a55de372be256.png" alt="在这里插入图片描述"></p>
<hr>
<ul>
<li><p>注意：标记起始点和每个移动到的点为<strong>已经走过点</strong>，即下一次不会重复移动到这个点。</p>
</li>
<li><p>在移动到的点处（代价最小点），继续遍历八个方向，除了<strong>墙壁</strong>和<strong>已经走过点</strong>，继续计算最终代价，<strong>找到最终代价小的点，移动。</strong><br><img src="https://img-blog.csdnimg.cn/29dbe25e620e46679e0b2e965afed765.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<ul>
<li>注意：如果你移动到了一个死胡同，则必须回退，<strong>如何回退</strong>?<br>我们事先准备了<strong>一个容器vector</strong>名字叫做 buff ，来<strong>存储我们每次遍历的方向的节点</strong>，即我们把每一个方向都创建一个节点，然后<strong>节点入树</strong>，<strong>节点再入容器</strong>，当我们走到死胡同时，<strong>通过找到容器内的最小元素</strong>（即是代价最小点，但是这个点是死胡同），<strong>然后把他删除</strong>，则 ==<strong>再次找一个代价最小点</strong>，<strong>然后移动到它那里去</strong>== 。<br><strong>如果地图没有终点，则可以想到，容器会一直删除，然后为空，此时则退出，没有终点。</strong></li>
</ul>
<hr>
<h2 id="A星寻路代码（完整）"><a href="#A星寻路代码（完整）" class="headerlink" title="A星寻路代码（完整）"></a>A星寻路代码（完整）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ROW = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> COL = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ZXDJ = <span class="number">10</span>;	<span class="comment">//直线代价</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> XXDJ = <span class="number">14</span>;	<span class="comment">//斜线代价</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Dir</span> &#123; p_up, p_down, p_left, p_right, p_lup, p_ldown, p_rup, p_rdown &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mypoint</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> row;</span><br><span class="line">	<span class="type">int</span> col;</span><br><span class="line">	<span class="type">int</span> f, g, h;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">return</span> (pos.row == row &amp;&amp; pos.col == col);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetH</span><span class="params">(<span class="type">const</span> Mypoint&amp; Begpos, <span class="type">const</span> Mypoint&amp; Endpos)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">abs</span>(Begpos.col - Endpos.col);<span class="comment">//计算水平差距</span></span><br><span class="line">		<span class="type">int</span> y = <span class="built_in">abs</span>(Begpos.row - Endpos.row);<span class="comment">//计算垂直差距</span></span><br><span class="line">		h = x + y;<span class="comment">//计算总的差距</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetF</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		f = g + h;<span class="comment">//计算f</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构存储节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">	Mypoint pos;<span class="comment">//当前点坐标</span></span><br><span class="line">	TreeNode* pParent;<span class="comment">//当前点的父节点</span></span><br><span class="line">	vector&lt;TreeNode*&gt; pChild;	<span class="comment">//存储当前点的所有孩子节点</span></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pos = pos;</span><br><span class="line">		pParent = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断某个点能否走</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CanWalk</span><span class="params">(<span class="type">int</span> map[ROW][COL], <span class="type">bool</span> vis[ROW][COL], <span class="type">const</span> Mypoint&amp; pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果越界，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (pos.row &lt; <span class="number">0</span> || pos.col &lt; <span class="number">0</span> || pos.row &gt;= ROW || pos.col &gt;= COL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是墙，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (map[pos.row][pos.col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果已经走过，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (vis[pos.row][pos.col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//否则能走</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//地图，1表示墙，0表示路径</span></span><br><span class="line">	<span class="type">int</span> map[ROW][COL] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//起始点和终点</span></span><br><span class="line">	Mypoint Begpos = &#123; <span class="number">1</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	Mypoint Endpos = &#123; <span class="number">6</span>,<span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//标记有没有走过</span></span><br><span class="line">	<span class="type">bool</span> vis[ROW][COL] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建树根，即根节点</span></span><br><span class="line">	TreeNode* pRoot = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(Begpos);</span><br><span class="line"></span><br><span class="line">	vector&lt;TreeNode*&gt; buff;	<span class="comment">//存储孩子节点的数组</span></span><br><span class="line"></span><br><span class="line">	TreeNode* pCurrent = pRoot;	<span class="comment">//记录当前点</span></span><br><span class="line">	TreeNode* pTemp = <span class="literal">nullptr</span>;	<span class="comment">//试探节点,用于试探下一个位置的点</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> isFindEnd = <span class="literal">false</span>;<span class="comment">//终点标记</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始寻路</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1. 某个点八个方向依次遍历 计算g代价</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//确定试探点的属性</span></span><br><span class="line">			pTemp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pCurrent-&gt;pos);</span><br><span class="line">			<span class="comment">//八个方向进行试探！</span></span><br><span class="line">			<span class="keyword">switch</span> (i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//直线代价</span></span><br><span class="line">			<span class="keyword">case</span> p_up:<span class="comment">//上</span></span><br><span class="line">				pTemp-&gt;pos.row--;</span><br><span class="line">				pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_down:<span class="comment">//下</span></span><br><span class="line">				pTemp-&gt;pos.row++;</span><br><span class="line">				pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_left:<span class="comment">//左</span></span><br><span class="line">				pTemp-&gt;pos.col--;</span><br><span class="line">				pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_right:<span class="comment">//右</span></span><br><span class="line">				pTemp-&gt;pos.col++;</span><br><span class="line">				pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//斜线代价</span></span><br><span class="line">			<span class="keyword">case</span> p_lup:<span class="comment">//左上</span></span><br><span class="line">				pTemp-&gt;pos.row--;</span><br><span class="line">				pTemp-&gt;pos.col--;</span><br><span class="line">				pTemp-&gt;pos.g += XXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_ldown:<span class="comment">//左下</span></span><br><span class="line">				pTemp-&gt;pos.row++;</span><br><span class="line">				pTemp-&gt;pos.col--;</span><br><span class="line">				pTemp-&gt;pos.g += XXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_rup:<span class="comment">//右上</span></span><br><span class="line">				pTemp-&gt;pos.row--;</span><br><span class="line">				pTemp-&gt;pos.col++;</span><br><span class="line">				pTemp-&gt;pos.g += XXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_rdown:<span class="comment">//右下</span></span><br><span class="line">				pTemp-&gt;pos.row++;</span><br><span class="line">				pTemp-&gt;pos.col++;</span><br><span class="line">				pTemp-&gt;pos.g += XXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断他们能不能走，能走的计算h及f 入树  存储在buff数组</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">CanWalk</span>(map, vis, pTemp-&gt;pos))</span><br><span class="line">			&#123;	<span class="comment">//能走</span></span><br><span class="line">				<span class="comment">//计算代价</span></span><br><span class="line">				pTemp-&gt;pos.<span class="built_in">GetH</span>(Begpos, Endpos);<span class="comment">//计算h代价</span></span><br><span class="line">				pTemp-&gt;pos.<span class="built_in">GetF</span>();<span class="comment">//得到最后的f代价，f=g+h </span></span><br><span class="line">				<span class="comment">//把能走的这个点存入树中</span></span><br><span class="line">				pCurrent-&gt;pChild.<span class="built_in">push_back</span>(pTemp);<span class="comment">//pTemp表示的就是下一个能走的点</span></span><br><span class="line">				pTemp-&gt;pParent = pCurrent;<span class="comment">//父子关系确定</span></span><br><span class="line">				<span class="comment">//存入数组</span></span><br><span class="line">				buff.<span class="built_in">push_back</span>(pTemp);</span><br><span class="line">				<span class="comment">//标记这个点走过</span></span><br><span class="line">				vis[pTemp-&gt;pos.row][pTemp-&gt;pos.col] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//不能走则删除pTemp，继续遍历下一个方向的点</span></span><br><span class="line">				<span class="keyword">delete</span> pTemp;</span><br><span class="line">				pTemp = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		遍历完八个方向后，找到最小代价点，并且移动，然后删除</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">auto</span> itMin =  <span class="built_in">min_element</span>(buff.<span class="built_in">begin</span>(), buff.<span class="built_in">end</span>(), [&amp;](TreeNode* p1, TreeNode* p2)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> p1-&gt;pos.f &lt; p2-&gt;pos.f;</span><br><span class="line">			&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//当前点移动到这个最小代价点</span></span><br><span class="line">		pCurrent = *itMin;</span><br><span class="line">		<span class="comment">//删除最小代价节点</span></span><br><span class="line">		buff.<span class="built_in">erase</span>(itMin);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//有没有到达终点</span></span><br><span class="line">		<span class="keyword">if</span> (pCurrent-&gt;pos == Endpos)</span><br><span class="line">		&#123;</span><br><span class="line">			isFindEnd = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//没有终点，自然一直删除节点，则buff为空</span></span><br><span class="line">		<span class="keyword">if</span> (buff.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isFindEnd)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到终点了!\n&quot;</span>;</span><br><span class="line">		<span class="keyword">while</span> (pCurrent)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pCurrent-&gt;pos.row &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pCurrent-&gt;pos.col &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">			pCurrent = pCurrent-&gt;pParent;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到终点!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终点row，col（7，7）：<br><img src="https://img-blog.csdnimg.cn/2f6b0a76593c489ea4ea769344cd20fa.png" alt="在这里插入图片描述"></p>
<p>终点row，col（6，5）<br><img src="https://img-blog.csdnimg.cn/ea18d5c7ee2e41eb820e65e6fd5e172f.png" alt="在这里插入图片描述"></p>
<hr>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>搜索与寻路</tag>
      </tags>
  </entry>
</search>
