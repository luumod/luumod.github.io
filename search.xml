<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A星寻路算法详解</title>
    <url>/2023/03/01/A%E6%98%9F%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>@[toc]</p>
<h2 id="三种寻路算法"><a href="#三种寻路算法" class="headerlink" title="三种寻路算法"></a>三种寻路算法</h2><ul>
<li><a href="https://blog.csdn.net/jj6666djdbbd/article/details/126205770">深度寻路算法：不一定能找到最佳路径，但是寻路快速，只能走直线。</a></li>
<li><a href="https://blog.csdn.net/jj6666djdbbd/article/details/126265199">广度寻路算法：一定能找到最短路径，但是开销大，时间慢，只能走直线。</a></li>
<li><strong>A星寻路算法</strong>（常用）：一定能找到最短路径，可以走直线和斜线，而且开销较小，常用于大型地图的寻路</li>
</ul>
<h1 id="A星寻路算法"><a href="#A星寻路算法" class="headerlink" title="A星寻路算法"></a>A星寻路算法</h1><h2 id="A星寻路算法思想"><a href="#A星寻路算法思想" class="headerlink" title="A星寻路算法思想"></a>A星寻路算法思想</h2><blockquote>
<p>引入： 狼吃羊模型。</p>
<p>狼捕猎羊：如果抓到了就加100分；如果狼不动，每分钟减2分；如果狼抓捕时会跑，跑步每分钟减5分；</p>
<p>​     狼会饿 ，饿的时候每分钟减10分。 有一个积分的概念在这里面。结果会发现<strong>狼会站在原地不动</strong>。</p>
<p>​    因为狼直到，抓住羊很困难，跑步时会扣分，饿时会扣分，不动时也会扣分。但是人工智能狼计算出了站着不动时扣分的代价最低，而干其他事代价都高，因此狼会自动选择代价最低的方式，一动不动</p>
<p>​    之后又加了设定：原地不动每分钟也扣分，而且是线性扣分。结果你会发现<strong>狼从一开始就会自杀</strong>。</p>
<p>同理，<strong>自杀是代价最小的选择</strong>（即分数最高，如果你干其他的事，则可能会负分，所以狼会选择自杀）。</p>
</blockquote>
<p>A星寻路算法也引入了这一概念，即通过<strong>计算和量化行走的各个方向的代价</strong>，来<strong>选择最优路径</strong></p>
<ul>
<li><strong><em>公式： f = g + h</em></strong></li>
<li>f： 设定其为<strong>最终评估代价</strong></li>
<li>g：当前点走到下一点的<strong>付出的代价</strong></li>
<li>h：当前点到终点的<strong>预期代价</strong></li>
<li>通过比较各条路线的最终代价，选择<strong>最小代价</strong>，即为合适的路径，也为<strong>最短路径</strong>。</li>
</ul>
<h2 id="A星寻路准备"><a href="#A星寻路准备" class="headerlink" title="A星寻路准备"></a>A星寻路准备</h2><p>地图行列数，方向枚举，地图，辅助地图的设计等在此不描述，具体请看之前我写的前两种寻路算法的博客。<br><a href="https://blog.csdn.net/jj6666djdbbd/article/details/126265199?spm=1001.2014.3001.5502">广度寻路算法</a><br><a href="https://blog.csdn.net/jj6666djdbbd/article/details/126205770?spm=1001.2014.3001.5502">深度寻路算法</a></p>
<ul>
<li><strong>记录坐标点的类型</strong>，GetH和GetF函数即为计算各种代价的函数，稍后会介绍。一个重载用来比较当前点是否到达终点</li>
</ul>
<blockquote>
<p>h表示当前点到终点的预期代价，因此我们每次移动一步，都需要求出 h，而h的计算我们可以直接通过数格子来获得，即水平，竖直个有几个格子，这便是<strong>预期的代价</strong><br>g表示走到每一点的代价，因此每走一个方向，记录这个方向的代价， 最后选择代价最小的方向即可，g可以通过遍历八个方向来记录<br>f =g + h</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mypoint</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> row;</span><br><span class="line">	<span class="type">int</span> col;</span><br><span class="line">	<span class="type">int</span> f, g, h;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">return</span> (pos.row == row &amp;&amp; pos.col == col);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetH</span><span class="params">(<span class="type">const</span> Mypoint&amp; Begpos, <span class="type">const</span> Mypoint&amp; Endpos)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">abs</span>(Begpos.col - Endpos.col);<span class="comment">//计算水平差距</span></span><br><span class="line">		<span class="type">int</span> y = <span class="built_in">abs</span>(Begpos.row - Endpos.row);<span class="comment">//计算垂直差距</span></span><br><span class="line">		h = x + y;<span class="comment">//计算总的差距</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetF</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		f = g + h;<span class="comment">//计算f</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>存储位置节点的树结构</strong>，含有构造函数用来构建树节点，<strong>vector数组</strong>存储多个节点：因为一个父亲会有多个孩子的情况。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树结构存储节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">	Mypoint pos;<span class="comment">//当前点坐标</span></span><br><span class="line">	TreeNode* pParent;<span class="comment">//当前点的父节点</span></span><br><span class="line">	vector&lt;TreeNode*&gt; pChild;	<span class="comment">//存储当前点的所有孩子节点</span></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pos = pos;</span><br><span class="line">		pParent = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>判断是否能走的函数</strong>，用于判断地图某个点是否能走，即不为墙，没越界，没走过，则能走。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断某个点能否走</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CanWalk</span><span class="params">(<span class="type">int</span> map[ROW][COL], <span class="type">bool</span> vis[ROW][COL], <span class="type">const</span> Mypoint&amp; pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果越界，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (pos.row &lt; <span class="number">0</span> || pos.col &lt; <span class="number">0</span> || pos.row &gt;= ROW || pos.col &gt;= COL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是墙，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (map[pos.row][pos.col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果已经走过，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (vis[pos.row][pos.col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//否则能走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数据的准备</strong></li>
</ul>
<ol>
<li>起点与终点的坐标</li>
<li>树根节点，用于保存寻路的<strong>树结构</strong></li>
<li>buff数组来记录每一个孩子节点，<strong>用来确定下一步该走的点</strong></li>
<li>vis标记数组，不能重复走</li>
<li>当前点与试探点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//地图，1表示墙，0表示路径</span></span><br><span class="line">	<span class="type">int</span> map[ROW][COL] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//起始点和终点</span></span><br><span class="line">	Mypoint Begpos = &#123; <span class="number">1</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	Mypoint Endpos = &#123; <span class="number">6</span>,<span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//标记有没有走过</span></span><br><span class="line">	<span class="type">bool</span> vis[ROW][COL] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建树根，即根节点</span></span><br><span class="line">	TreeNode* pRoot = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(Begpos);</span><br><span class="line"></span><br><span class="line">	vector&lt;TreeNode*&gt; buff;	<span class="comment">//存储孩子节点的数组</span></span><br><span class="line"></span><br><span class="line">	TreeNode* pCurrent = pRoot;	<span class="comment">//记录当前点</span></span><br><span class="line">	TreeNode* pTemp = <span class="literal">nullptr</span>;	<span class="comment">//试探节点,用于试探下一个位置的点</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> isFindEnd = <span class="literal">false</span>;<span class="comment">//终点标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="A星寻路过程（图例）"><a href="#A星寻路过程（图例）" class="headerlink" title="A星寻路过程（图例）"></a>A星寻路过程（图例）</h2><p>假定<strong>直着走的代价为10，斜着走的代价为14</strong></p>
<ul>
<li><p>首先计算起点位置周围八个方向<strong>付出代价</strong>（蓝色），此代价为<strong>付出的代价 g</strong>。<br><img src="https://img-blog.csdnimg.cn/15215e45fdd948fda712c731eb17c42f.png" alt="在这里插入图片描述"></p>
</li>
<li><p>然后再计算<strong>起点到终点的代价</strong>（如何计算：数格子即可，某个点到终点的格子数，只能行列，不能斜着），此代价为<strong>预期代价h</strong>，可以发现 <strong>最终代价=付出+预期</strong>，可以得到一个<strong>最小的代价点</strong>，即<strong>右下角的斜着的点</strong>。</p>
<p><strong>这个点即是我们下一步要走的点</strong>。<strong>依次类推，在下个点上，再次计算周围代价最小的点，然后再次移动</strong></p>
</li>
</ul>
<hr>
<p>upd： 2023. 2.22 新增一个图<br><img src="https://img-blog.csdnimg.cn/a88609b83bba49f49c4a55de372be256.png" alt="在这里插入图片描述"></p>
<hr>
<ul>
<li><p>注意：标记起始点和每个移动到的点为<strong>已经走过点</strong>，即下一次不会重复移动到这个点。</p>
</li>
<li><p>在移动到的点处（代价最小点），继续遍历八个方向，除了<strong>墙壁</strong>和<strong>已经走过点</strong>，继续计算最终代价，<strong>找到最终代价小的点，移动。</strong><br><img src="https://img-blog.csdnimg.cn/29dbe25e620e46679e0b2e965afed765.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<ul>
<li>注意：如果你移动到了一个死胡同，则必须回退，<strong>如何回退</strong>?<br>我们事先准备了<strong>一个容器vector</strong>名字叫做 buff ，来<strong>存储我们每次遍历的方向的节点</strong>，即我们把每一个方向都创建一个节点，然后<strong>节点入树</strong>，<strong>节点再入容器</strong>，当我们走到死胡同时，<strong>通过找到容器内的最小元素</strong>（即是代价最小点，但是这个点是死胡同），<strong>然后把他删除</strong>，则 ==<strong>再次找一个代价最小点</strong>，<strong>然后移动到它那里去</strong>== 。<br><strong>如果地图没有终点，则可以想到，容器会一直删除，然后为空，此时则退出，没有终点。</strong></li>
</ul>
<hr>
<h2 id="A星寻路代码（完整）"><a href="#A星寻路代码（完整）" class="headerlink" title="A星寻路代码（完整）"></a>A星寻路代码（完整）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ROW = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> COL = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ZXDJ = <span class="number">10</span>;	<span class="comment">//直线代价</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> XXDJ = <span class="number">14</span>;	<span class="comment">//斜线代价</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Dir</span> &#123; p_up, p_down, p_left, p_right, p_lup, p_ldown, p_rup, p_rdown &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mypoint</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> row;</span><br><span class="line">	<span class="type">int</span> col;</span><br><span class="line">	<span class="type">int</span> f, g, h;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">return</span> (pos.row == row &amp;&amp; pos.col == col);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetH</span><span class="params">(<span class="type">const</span> Mypoint&amp; Begpos, <span class="type">const</span> Mypoint&amp; Endpos)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">abs</span>(Begpos.col - Endpos.col);<span class="comment">//计算水平差距</span></span><br><span class="line">		<span class="type">int</span> y = <span class="built_in">abs</span>(Begpos.row - Endpos.row);<span class="comment">//计算垂直差距</span></span><br><span class="line">		h = x + y;<span class="comment">//计算总的差距</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetF</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		f = g + h;<span class="comment">//计算f</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构存储节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">	Mypoint pos;<span class="comment">//当前点坐标</span></span><br><span class="line">	TreeNode* pParent;<span class="comment">//当前点的父节点</span></span><br><span class="line">	vector&lt;TreeNode*&gt; pChild;	<span class="comment">//存储当前点的所有孩子节点</span></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pos = pos;</span><br><span class="line">		pParent = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断某个点能否走</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CanWalk</span><span class="params">(<span class="type">int</span> map[ROW][COL], <span class="type">bool</span> vis[ROW][COL], <span class="type">const</span> Mypoint&amp; pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果越界，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (pos.row &lt; <span class="number">0</span> || pos.col &lt; <span class="number">0</span> || pos.row &gt;= ROW || pos.col &gt;= COL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是墙，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (map[pos.row][pos.col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果已经走过，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (vis[pos.row][pos.col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//否则能走</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//地图，1表示墙，0表示路径</span></span><br><span class="line">	<span class="type">int</span> map[ROW][COL] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//起始点和终点</span></span><br><span class="line">	Mypoint Begpos = &#123; <span class="number">1</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	Mypoint Endpos = &#123; <span class="number">6</span>,<span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//标记有没有走过</span></span><br><span class="line">	<span class="type">bool</span> vis[ROW][COL] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建树根，即根节点</span></span><br><span class="line">	TreeNode* pRoot = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(Begpos);</span><br><span class="line"></span><br><span class="line">	vector&lt;TreeNode*&gt; buff;	<span class="comment">//存储孩子节点的数组</span></span><br><span class="line"></span><br><span class="line">	TreeNode* pCurrent = pRoot;	<span class="comment">//记录当前点</span></span><br><span class="line">	TreeNode* pTemp = <span class="literal">nullptr</span>;	<span class="comment">//试探节点,用于试探下一个位置的点</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> isFindEnd = <span class="literal">false</span>;<span class="comment">//终点标记</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始寻路</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1. 某个点八个方向依次遍历 计算g代价</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//确定试探点的属性</span></span><br><span class="line">			pTemp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pCurrent-&gt;pos);</span><br><span class="line">			<span class="comment">//八个方向进行试探！</span></span><br><span class="line">			<span class="keyword">switch</span> (i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//直线代价</span></span><br><span class="line">			<span class="keyword">case</span> p_up:<span class="comment">//上</span></span><br><span class="line">				pTemp-&gt;pos.row--;</span><br><span class="line">				pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_down:<span class="comment">//下</span></span><br><span class="line">				pTemp-&gt;pos.row++;</span><br><span class="line">				pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_left:<span class="comment">//左</span></span><br><span class="line">				pTemp-&gt;pos.col--;</span><br><span class="line">				pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_right:<span class="comment">//右</span></span><br><span class="line">				pTemp-&gt;pos.col++;</span><br><span class="line">				pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//斜线代价</span></span><br><span class="line">			<span class="keyword">case</span> p_lup:<span class="comment">//左上</span></span><br><span class="line">				pTemp-&gt;pos.row--;</span><br><span class="line">				pTemp-&gt;pos.col--;</span><br><span class="line">				pTemp-&gt;pos.g += XXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_ldown:<span class="comment">//左下</span></span><br><span class="line">				pTemp-&gt;pos.row++;</span><br><span class="line">				pTemp-&gt;pos.col--;</span><br><span class="line">				pTemp-&gt;pos.g += XXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_rup:<span class="comment">//右上</span></span><br><span class="line">				pTemp-&gt;pos.row--;</span><br><span class="line">				pTemp-&gt;pos.col++;</span><br><span class="line">				pTemp-&gt;pos.g += XXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_rdown:<span class="comment">//右下</span></span><br><span class="line">				pTemp-&gt;pos.row++;</span><br><span class="line">				pTemp-&gt;pos.col++;</span><br><span class="line">				pTemp-&gt;pos.g += XXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断他们能不能走，能走的计算h及f 入树  存储在buff数组</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">CanWalk</span>(map, vis, pTemp-&gt;pos))</span><br><span class="line">			&#123;	<span class="comment">//能走</span></span><br><span class="line">				<span class="comment">//计算代价</span></span><br><span class="line">				pTemp-&gt;pos.<span class="built_in">GetH</span>(Begpos, Endpos);<span class="comment">//计算h代价</span></span><br><span class="line">				pTemp-&gt;pos.<span class="built_in">GetF</span>();<span class="comment">//得到最后的f代价，f=g+h </span></span><br><span class="line">				<span class="comment">//把能走的这个点存入树中</span></span><br><span class="line">				pCurrent-&gt;pChild.<span class="built_in">push_back</span>(pTemp);<span class="comment">//pTemp表示的就是下一个能走的点</span></span><br><span class="line">				pTemp-&gt;pParent = pCurrent;<span class="comment">//父子关系确定</span></span><br><span class="line">				<span class="comment">//存入数组</span></span><br><span class="line">				buff.<span class="built_in">push_back</span>(pTemp);</span><br><span class="line">				<span class="comment">//标记这个点走过</span></span><br><span class="line">				vis[pTemp-&gt;pos.row][pTemp-&gt;pos.col] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//不能走则删除pTemp，继续遍历下一个方向的点</span></span><br><span class="line">				<span class="keyword">delete</span> pTemp;</span><br><span class="line">				pTemp = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		遍历完八个方向后，找到最小代价点，并且移动，然后删除</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">auto</span> itMin =  <span class="built_in">min_element</span>(buff.<span class="built_in">begin</span>(), buff.<span class="built_in">end</span>(), [&amp;](TreeNode* p1, TreeNode* p2)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> p1-&gt;pos.f &lt; p2-&gt;pos.f;</span><br><span class="line">			&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//当前点移动到这个最小代价点</span></span><br><span class="line">		pCurrent = *itMin;</span><br><span class="line">		<span class="comment">//删除最小代价节点</span></span><br><span class="line">		buff.<span class="built_in">erase</span>(itMin);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//有没有到达终点</span></span><br><span class="line">		<span class="keyword">if</span> (pCurrent-&gt;pos == Endpos)</span><br><span class="line">		&#123;</span><br><span class="line">			isFindEnd = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//没有终点，自然一直删除节点，则buff为空</span></span><br><span class="line">		<span class="keyword">if</span> (buff.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isFindEnd)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到终点了!\n&quot;</span>;</span><br><span class="line">		<span class="keyword">while</span> (pCurrent)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pCurrent-&gt;pos.row &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pCurrent-&gt;pos.col &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">			pCurrent = pCurrent-&gt;pParent;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到终点!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终点row，col（7，7）：<br><img src="https://img-blog.csdnimg.cn/2f6b0a76593c489ea4ea769344cd20fa.png" alt="在这里插入图片描述"></p>
<p>终点row，col（6，5）<br><img src="https://img-blog.csdnimg.cn/ea18d5c7ee2e41eb820e65e6fd5e172f.png" alt="在这里插入图片描述"></p>
<hr>
]]></content>
      <tags>
        <tag>搜索与寻路</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo与github搭建个人博客</title>
    <url>/2023/03/02/hexo%E4%B8%8Egithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="0-前置内容"><a href="#0-前置内容" class="headerlink" title="0. 前置内容"></a>0. 前置内容</h1><ol>
<li><strong>git 的下载</strong>： 官网下载较慢，这边推荐阿里镜像下载：</li>
</ol>
<p><a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">阿里镜像下载 git</a></p>
<p>往下滑选择接近当前日期的最新版本  2.39.2 windows</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124lpsb.png" alt=""></p>
<p>选择 2.39.2 -64 的exe下载，大概有 50Mb大小</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124lsc8.png" alt=""></p>
<p>下载好后，直接<strong>一直点下一步即可</strong>。如果你了解过git，则可以按照自己的习惯下载，这不重要。</p>
<ol>
<li><strong>Nodejs下载</strong></li>
</ol>
<p>直接百度搜索 Nodejs，<a href="https://nodejs.org/en/">Nodejs下载</a> </p>
<p>选择 18.14.2 的 LTS版本下载</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124luej.png" alt=""></p>
<h1 id="2-hexo创建个人博客"><a href="#2-hexo创建个人博客" class="headerlink" title="2. hexo创建个人博客"></a>2. hexo创建个人博客</h1><p>hexo是什么？</p>
<ul>
<li><p>正如hexo的首页所显示的，它是一款非常快速，简介，高效的博客框架平台，我们可以利用hexo快速生成博客网站的模板，然后部署为我们自己的博客网站。</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124lxlr.png" alt=""></p>
</li>
</ul>
<p>直接进入操作：</p>
<ol>
<li><strong>在任意盘符中新建 hexo 文件夹</strong>，这里我创建在了F盘</li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/02/124m59v.png" alt=""></p>
<ol>
<li><strong>打开hexo文件夹，空白的地方右键，选择 Git Bash Here</strong> ，即我们使用 git 环境创建 hexo的blog模板（必须提前安装好 git），打开后如下图所示：<strong>/ f / hexo表示当前操作位置在 F盘的 hexo文件夹中</strong></li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/02/124m6dn.png" alt=""></p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124mb6h.png" alt=""></p>
<ol>
<li><strong>在 git窗口中依次输入以下命令</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd blog</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>全部输入完成后，hexo文件夹中便会生成一个 blog 子文件夹，并且blog文件夹里面包含有很多信息：</p>
<p><img src="https://great.wzznft.com/i/2023/03/02/1282mhg.png" alt=""></p>
<p>关于这些文件夹，做一个简单的介绍：</p>
<ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：生成文章的一些模板</li>
<li>source：用来存放你的文章</li>
<li>themes：主题</li>
</ul>
<p>然后输入这两条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s </span><br></pre></td></tr></table></figure>
<p>完成后会显示如下内容，则说明<strong>配置成功</strong>!</p>
<p><img src="C:\Users\woshishuaige\AppData\Roaming\Typora\typora-user-images\image-20230302232027120.png" alt="image-20230302232027120"></p>
<p>在  git 中输入 Ctrl+C 即可关闭hexo s的内容。</p>
<p>打开浏览器，在浏览器输入 <strong>localhost:4000</strong> 即可进入你的<strong>初始默认博客</strong></p>
<p>它长这样：</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/12e7hdk.png" alt=""></p>
<p>注意：这只是一个<strong>离线版本的博客</strong> ，只能你自己看见，因此我们还需要 GitHub或者 gittee提供的 ssh功能将他变为对外开放的。</p>
<h1 id="3-GitHub创建仓库"><a href="#3-GitHub创建仓库" class="headerlink" title="3. GitHub创建仓库"></a>3. GitHub创建仓库</h1><ol>
<li>首先注册一个GitHub的仓库，然后在<strong>个人主页中选择 new 新建仓库</strong></li>
</ol>
<p>注意： 仓库名称的<strong>前半部分与你的用户名一致</strong>，即 lummod，<strong>后半部分 为  .git.io 固定格式</strong>（忽略红色警告，因为我已经创建过了！），可以选择一个readme为说明文件（随便），然后<strong>点击创建仓库</strong></p>
<p><img src="https://tudingtu.cn/i/2023/03/02/12idvsn.png" alt=""></p>
<ol>
<li>回到 git bash黑窗口中，<strong>输入以下两个命令</strong>（逐条）：</li>
</ol>
<p>yourname改为你的<strong>GitHub的用户名</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br></pre></td></tr></table></figure>
<p>youremail改为你的<strong>注册GitHub时的邮箱</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
<p>一定不要输入错，这样github才能检查到这个用户属于你</p>
<ol>
<li><strong>创建 ssh，输入命令，然后一直回车</strong></li>
</ol>
<p>youremail改为你的<strong>注册GitHub时的邮箱</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
<p>之后会提示你已完成 ssh的创建，在文件中找到这个路径</p>
<p><img src="https://great.wzznft.com/i/2023/03/02/12lqlrh.png" alt=""></p>
<p>记住这两个文件</p>
<ol>
<li>在 GitHub的 Setting里面，找到 SSH keys，<strong>把 id_rsa.pub 里面的内容全部复制到 key 进去</strong>，title随便写一个就行</li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/02/12mxnrn.png" alt=""></p>
<p>操作完成后，就成功了。</p>
<h1 id="4-hexo部署到GitHub"><a href="#4-hexo部署到GitHub" class="headerlink" title="4. hexo部署到GitHub"></a>4. hexo部署到GitHub</h1><ol>
<li>在 blog文件夹下面找到 <strong>_config.yml 文件</strong>，这是属于 你的博客的<strong>配置文件</strong>，<strong>点进入一看就知道了，你可以在这里面直接修改 姓名，内容，等用户的信息</strong>。双击打开它（vscode或者其他文本编辑器，记事本都可以）</li>
</ol>
<p><img src="C:\Users\woshishuaige\AppData\Roaming\Typora\typora-user-images\image-20230302233921035.png" alt="image-20230302233921035"></p>
<ol>
<li>先找一下有没有以下这段内容（我也忘记了是我添加的还是自带的），<strong>如果自带则一定是空的，则修改为如下所示，如果没有，则直接复制下面内容到 文档的末尾：</strong></li>
</ol>
<p><strong>user表示你的GitHub的用户名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line"># deploy:</span><br><span class="line">#   type: &#x27;&#x27;</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/username/username.github.io.git</span><br><span class="line">  branch: gh-pages</span><br><span class="line">  # message: Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>说明：类型是 git，远程 ssh连接是 你的 repo输入项，branch 输入gh-pages。</strong></p>
<ol>
<li>完成后，保存文件并且退出，在 git bash中输入以下命令：</li>
</ol>
<p><strong>表示安装 git部署命令工具</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<ol>
<li>最后输入以下三行命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。<br><code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写<br><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p>
<p><strong>如果是在离线端即 localhost:4000端测试你的博客，则只需要 hexo  g + hexo s 即可，无需 hexo d</strong></p>
<ol>
<li>输入完成后会出现一堆内容，不用管他<strong>，只要最后内容如下所示，</strong>就表示成功了！</li>
</ol>
<p><img src="C:\Users\woshishuaige\AppData\Roaming\Typora\typora-user-images\image-20230302234912902.png" alt="image-20230302234912902"></p>
<p>然后你就可以在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username.github.io  # https://username.github.io</span><br></pre></td></tr></table></figure>
<p><strong>访问到你的博客了，其中username是你GitHub用户名，这个网站不是离线的，其他人都可以访问到！！！</strong></p>
]]></content>
      <tags>
        <tag>实用技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/01/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>第一篇文章</title>
    <url>/2023/03/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="我的个人博客"><a href="#我的个人博客" class="headerlink" title="我的个人博客"></a>我的个人博客</h1>]]></content>
  </entry>
  <entry>
    <title>线性代数知识点总结</title>
    <url>/2023/03/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-行列式"><a href="#1-行列式" class="headerlink" title="1. 行列式"></a>1. 行列式</h1><p>行列式的定义：n*n个数字排成n行n列，叫做n阶行列式。</p>
<p>行列式的项数：</p>
<ol>
<li>2阶行列式有2项</li>
<li>3阶行列式有6项</li>
<li>4阶行列式有24项</li>
</ol>
<h2 id="1-1-余子式与代数余子式"><a href="#1-1-余子式与代数余子式" class="headerlink" title="1.1 余子式与代数余子式"></a>1.1 余子式与代数余子式</h2><p>余子式：关于一个k阶子式的余子式，是A去掉了这个k阶子式所在的行与列之后得到的（n－k）×（n－k）矩阵的行列式。</p>
<p>代数余子式：元素aₒₑi的代数余子式与该元素本身没什么关系，只与该元素的位置有关。</p>
<p><strong>行列式按行展开</strong></p>
<ul>
<li>行列式的值D = 任意一行（列）元素<em>自己的<em>*代数余子式</em></em>之和</li>
</ul>
<hr>
<p><strong>异乘变零定理</strong></p>
<ul>
<li>某行元素与另一行元素的代数余子式乘积之和=0</li>
</ul>
<hr>
<p>拉普拉斯定理（k阶子式）</p>
<ul>
<li>k=2<ul>
<li>2阶子式：取任意两行两列，交界的元素就是2阶子式</li>
<li>余子式：两行两列之外（剩余）的元素就是余子式</li>
<li>代数余子式：（-1）^（行1+行2+列1+列2）*余子式</li>
</ul>
</li>
</ul>
<p>拉普拉斯展开定理</p>
<ul>
<li>n阶行列式中，任意取定k行，由k行元素组成的所有<strong>k阶子式</strong>与<strong>代数余子式</strong>的乘积之和=行列式的值（D）</li>
</ul>
<hr>
<p>行列式相乘：（同阶行列式）三阶行列式：</p>
<ul>
<li><p>第一行</p>
<ul>
<li>第一行元素*第一列元素，元素对应先相乘再相加</li>
<li>第一行元素*第二列元素，…</li>
<li>第一行元素*第三列元素，… </li>
</ul>
</li>
<li><p>第二行</p>
<ul>
<li>第二行元素*第一列元素，…</li>
<li>第二行元素*第二列元素，…</li>
<li>第二行元素*第三列元素，… </li>
</ul>
</li>
<li><p>第三行</p>
<ul>
<li>第三行元素*第一列元素，…</li>
<li>第三行元素*第二列元素，…</li>
<li>第三行元素*第三列元素，… </li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-2-行列式计算"><a href="#1-2-行列式计算" class="headerlink" title="1.2 行列式计算"></a>1.2 行列式计算</h2><ul>
<li>化成上下三角</li>
<li><p>按行展开</p>
</li>
<li><p>制造<strong>行和</strong>：如图所示行列式</p>
</li>
</ul>
<script type="math/tex; mode=display">
\left|\begin{matrix}
    x & a & a \\
    a & x & a \\
    a & a & x 
   \end{matrix} \right|-> 
   (x+2a)\left|\begin{matrix}
    1 & a & a \\
    1 & x & a \\
    1 & a & x 
   \end{matrix} \right| ->
   (x+2a) \left|\begin{matrix}
    1 & 0 & 0 \\
    1 & x & 0 \\
    1 & 0 & x 
   \end{matrix} \right|(用第一列乘-a加到后两列去，形成下三角求和)</script><ul>
<li><p>加边法：不能改变原行列式的值</p>
</li>
<li><p>范德蒙德行列式：[<a href="https://baike.baidu.com/item/范德蒙行列式/6081288?fromtitle=范德蒙德行列式&amp;fromid=15995336&amp;fr=aladdin">范德蒙行列式_百度百科 (baidu.com)</a>]</p>
</li>
<li><strong>反对称行列式</strong><ul>
<li>主对角线全为零 aii=-aii  aii=0</li>
<li>对角线对称位置对应成<strong>相反数</strong> aij=-aji</li>
<li>如果是<strong>奇数阶</strong>，则D=0（利用转置性质）</li>
</ul>
</li>
<li><strong>对称行列式</strong><ul>
<li>主对角线元素没有要求</li>
<li>对角线对称位置对应成<strong>相等</strong> aij=aji</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-3-克莱姆法则"><a href="#1-3-克莱姆法则" class="headerlink" title="1.3 克莱姆法则"></a>1.3 克莱姆法则</h2><p><strong>方程的个数等于未知量的个数</strong></p>
<ul>
<li>n个方程，n个未知量 </li>
<li><p>D !=0 ： <strong>Xi= Di/D</strong>  </p>
</li>
<li><p><strong>Di 表示的是把系数行列式中第 i 列的元素用 常数项列 替代</strong></p>
</li>
</ul>
<p>定理与推论：</p>
<ul>
<li>定理1：系数行列式D不等于0，则方程组有唯一解，解为：x1=D1/D,x2=D2/D ….<ul>
<li>推论1：线性方程组<strong>无解或者有多组不同的解</strong>，<strong>系数行列式D=0</strong></li>
</ul>
</li>
</ul>
<ul>
<li>定理2：齐次线性方程组的系数行列式 <strong>D!=0</strong>，则齐次线性方程组<strong>只有零解</strong><ul>
<li>齐次线性方程组有非零解的<strong>充要条件</strong> &lt;==&gt; D=0</li>
</ul>
</li>
</ul>
<p>简单来说： </p>
<ol>
<li>D!=0 ，只有零解</li>
<li>D=0，有非零解</li>
</ol>
<hr>
<h1 id="2-矩阵"><a href="#2-矩阵" class="headerlink" title="2. 矩阵"></a>2. 矩阵</h1><h2 id="2-1-矩阵的运算"><a href="#2-1-矩阵的运算" class="headerlink" title="2.1 矩阵的运算"></a>2.1 矩阵的运算</h2><h3 id="2-1-1-加法运算"><a href="#2-1-1-加法运算" class="headerlink" title="2.1.1 加法运算"></a>2.1.1 加法运算</h3><ul>
<li><p>同型矩阵才能相加减</p>
</li>
<li><p>对应行对应列的元素相加即可</p>
</li>
</ul>
<h3 id="2-1-2-数乘运算"><a href="#2-1-2-数乘运算" class="headerlink" title="2.1.2 数乘运算"></a>2.1.2 数乘运算</h3><ul>
<li>把矩阵的每一个元素都乘以k</li>
<li>矩阵的加减法与矩阵的数乘运算统称为<strong>矩阵的线性运算</strong></li>
</ul>
<h3 id="2-1-3-矩阵的乘法"><a href="#2-1-3-矩阵的乘法" class="headerlink" title="2.1.3 矩阵的乘法"></a>2.1.3 矩阵的乘法</h3><p>定义： 设A=(aij)m<em>s， B=(bij)s </em> n ,则C=(cij)m*n=AB</p>
<ul>
<li>只有当左边矩阵A的行数等于右边矩阵B的列数才能做乘法运算。</li>
<li><p>相乘后，结果矩阵的行数等于左边矩阵A的行数，列数等于右边矩阵B的列数。</p>
</li>
<li><p>矩阵cij的元素等于矩阵A的第i行与矩阵B第j列元素相乘后相加。</p>
</li>
<li><p>矩阵乘法与普通乘法运算规则不同</p>
</li>
<li>若矩阵满足AB=BA，则A和B是可交换的，仅当A和B可交换时，才满足交换律，结合律等数学公式</li>
</ul>
<h3 id="2-1-4-矩阵的幂运算"><a href="#2-1-4-矩阵的幂运算" class="headerlink" title="2.1.4 矩阵的幂运算"></a>2.1.4 矩阵的幂运算</h3><ul>
<li>将k个Aij连乘即为A的k次幂</li>
</ul>
<h2 id="2-2-矩阵的转置"><a href="#2-2-矩阵的转置" class="headerlink" title="2.2 矩阵的转置"></a>2.2 矩阵的转置</h2><ul>
<li>将矩阵Aij转换为Aji，即行列互换即为A的转置</li>
<li>（AB）的转置 = B转置*A转置</li>
<li>A的转置等于A，则A是对称矩阵</li>
<li>A的转置等于-A，则A是反对称矩阵</li>
</ul>
<h2 id="2-3-方阵的行列式"><a href="#2-3-方阵的行列式" class="headerlink" title="2.3 方阵的行列式"></a>2.3 方阵的行列式</h2><ul>
<li>N阶方阵的所有元素（Aij）n*n 按照原来的位置构成的的行列式，称为方阵A的行列式，记作 |A|或者 detA</li>
<li>方阵行列式：是一个数；方阵：是一个数表</li>
<li>方阵行列式的性质</li>
<li>A的n阶方阵，若|A|!=0，则A为非奇异矩阵，当 |A|=0，则A为奇异矩阵</li>
</ul>
<h2 id="2-4-伴随矩阵"><a href="#2-4-伴随矩阵" class="headerlink" title="2.4 伴随矩阵"></a>2.4 伴随矩阵</h2><ul>
<li>A=（aij）n<em>n 是n阶方阵，则行列式 |A|中的每个元素aij的<em>*代数余子式</em></em>Aij所构成的矩阵称为矩阵A的伴随矩阵</li>
<li><strong>A*在（i，j）上的位置元素等于 A在 （j，i）上的位置的元素的代数余子式！！！！！！！</strong></li>
<li><p>伴随的一般求法：</p>
<ul>
<li>二阶矩阵的伴随： 对角线元素互换，反对角线添负号</li>
<li>三阶矩阵的伴随：将矩阵<strong>转置后</strong>求<strong>代数余子式</strong></li>
</ul>
</li>
<li><p>A是n阶方阵，A<em>是A的伴随矩阵，则满足： AA </em>=A *A=|A|E</p>
</li>
</ul>
<h2 id="2-5-逆矩阵"><a href="#2-5-逆矩阵" class="headerlink" title="2.5 逆矩阵"></a>2.5 逆矩阵</h2><ul>
<li>对于n阶方阵A，存在一个n阶方阵B，使得AB=BA=E，则称A是<strong>可逆矩阵</strong>，B是A的<strong>逆矩阵</strong>。记作A-1=B</li>
<li>单位矩阵E是可逆的，它的逆矩阵等于自身，零矩阵不是可逆矩阵</li>
</ul>
<h3 id="2-5-1-逆矩阵性质"><a href="#2-5-1-逆矩阵性质" class="headerlink" title="2.5.1 逆矩阵性质"></a>2.5.1 逆矩阵性质</h3><ul>
<li>若方阵A可逆，则A的<strong>逆矩阵是唯一</strong>的： 若B，C都是A 的逆矩阵，则AB=AC=E，B=BE=B(AC)=C(AB)=CE，所以 A=B</li>
<li>AB=E，则AB均可逆，A-1=B，B-1=A，判断A是不是B的逆矩阵：判断AB=E</li>
<li><strong>方阵A可逆，则|A|!=0，且|A-1|=1/|A|</strong>，<strong>判断A是否可逆，则仅需判断 |A|！=0</strong> ，|A|！=0 &lt;==&gt; A可逆</li>
<li>方阵A可逆，则A-1也可逆，则（A-1）-1=A</li>
<li>方阵A可逆，且k！=0，则 （kA）-1= 1/k *（A-1）</li>
<li>方阵A可逆，则A转置也可逆，（A转置）-1=（A-1）转置</li>
<li>AB是同阶可逆矩阵，AB也可逆，则（AB）-1=B-1* A-1</li>
</ul>
<h3 id="2-5-2-逆矩阵的求法"><a href="#2-5-2-逆矩阵的求法" class="headerlink" title="2.5.2 逆矩阵的求法"></a>2.5.2 逆矩阵的求法</h3><ul>
<li>根据伴随矩阵（求低阶方阵逆矩阵） <strong>若A是非奇异矩阵（|A|不等于0，则A是可逆的），则A-1=1/|A| * A伴随</strong></li>
</ul>
<h3 id="2-5-3-逆矩阵的应用"><a href="#2-5-3-逆矩阵的应用" class="headerlink" title="2.5.3 逆矩阵的应用"></a>2.5.3 逆矩阵的应用</h3><ul>
<li>对于一个线性方程组： A是系数矩阵，B是常系数矩阵，X是未知数矩阵，因此线性方程组用矩阵表示为AX=B，<strong>因此求线性方程组的解，可以转换为求相应矩阵的解</strong></li>
</ul>
<h2 id="2-6-矩阵的初等变换"><a href="#2-6-矩阵的初等变换" class="headerlink" title="2.6 矩阵的初等变换"></a>2.6 矩阵的初等变换</h2><p>性质</p>
<ol>
<li>交换矩阵的 第 i 行（列）与第 j 行（列）</li>
<li>非零常数 k 乘以 矩阵的第 i 行（列）</li>
<li>矩阵的第 j 行乘以 k倍 加到第 i 行上去</li>
</ol>
<p>矩阵的初等行或者列变换统称为 <strong>矩阵的初等变换</strong></p>
<ul>
<li>矩阵A经过有限次初等变换变成B，则A与B<strong>等价</strong><ul>
<li>反身性</li>
<li>对称性</li>
<li>传递性</li>
</ul>
</li>
<li>矩阵的左上角为一个<strong>单位矩阵</strong>，其余元素都是零，则该矩阵为<strong>标准型矩阵</strong><ul>
<li>任何一个非奇异矩阵，经过有限次初等行变换都能变成<strong>单位矩阵 E</strong> </li>
<li>推论：<strong>矩阵A可逆的充要条件使它与单位矩阵E等价</strong></li>
</ul>
</li>
</ul>
<p>行变换转换为标准型矩阵的一般步骤:</p>
<ol>
<li>行变换 转换为 <strong>行阶梯型矩阵</strong></li>
<li>行阶梯形矩阵 转换为 <strong>行最简</strong></li>
<li>行最简 列变换转换为<strong>标准型</strong></li>
</ol>
<p><strong>单位矩阵的行数等于行阶梯非零行的行数</strong></p>
<hr>
<h3 id="2-6-1-初等矩阵"><a href="#2-6-1-初等矩阵" class="headerlink" title="2.6.1 初等矩阵"></a>2.6.1 初等矩阵</h3><p>三种初等变换：</p>
<ol>
<li>交换第 i 行 与第 j 行</li>
<li>非零常数乘以 第 i 行</li>
<li>第 j 行乘以k 加到第 i 行上去</li>
</ol>
<p>性质：</p>
<ol>
<li>初等矩阵都是可逆矩阵，且其逆矩阵也是同类型的初等矩阵</li>
<li>初等矩阵的转置仍是同类型的初等矩阵</li>
<li>对一个矩阵A施行一次<strong>初等行变换等于对 A左乘一个m阶单位矩阵</strong>；对矩阵A施行<strong>一次初等列变换相当于对A右乘一个n阶单位矩阵</strong></li>
</ol>
<h2 id="2-7-初等变换的应用"><a href="#2-7-初等变换的应用" class="headerlink" title="2.7 初等变换的应用"></a>2.7 初等变换的应用</h2><h3 id="2-7-1-求逆矩阵"><a href="#2-7-1-求逆矩阵" class="headerlink" title="2.7.1 求逆矩阵"></a>2.7.1 求逆矩阵</h3><ul>
<li><strong>对矩阵 A 与 E做相同的初等变换等于对矩阵A 做初等行变换化为单位矩阵E时，E就变成了A的逆矩阵A-1</strong>（单位矩阵E乘以任何矩阵A，都等于矩阵A本身）</li>
</ul>
<script type="math/tex; mode=display">
(A,E)->(E,A^{-1})</script><p>初等列变换也是同理</p>
<h3 id="2-1-2-求解矩阵方程"><a href="#2-1-2-求解矩阵方程" class="headerlink" title="2.1.2 求解矩阵方程"></a>2.1.2 求解矩阵方程</h3><p>在矩阵A，B，C均可逆的前提下：</p>
<ol>
<li>AX=B，则 X=A-1B</li>
<li>XA=B，则 X=BA-1</li>
<li>AXB=C，则 X=A-1CB-1 </li>
</ol>
<ul>
<li>对矩阵 A 与 E做相同的初等变换等于对矩阵A 做初等行变换化为单位矩阵E时，E就变成了A的逆矩阵A-1</li>
</ul>
<script type="math/tex; mode=display">
(A,B)-^{初等行变换}->(E,A^{-1}B)</script><p>初等列变换也是同理</p>
<hr>
<h2 id="2-9-行最简矩阵与矩阵的秩"><a href="#2-9-行最简矩阵与矩阵的秩" class="headerlink" title="2.9 行最简矩阵与矩阵的秩"></a>2.9 行最简矩阵与矩阵的秩</h2><h3 id="2-9-1-行最简矩阵"><a href="#2-9-1-行最简矩阵" class="headerlink" title="2.9.1 行最简矩阵"></a>2.9.1 行最简矩阵</h3><p>行阶梯形矩阵：</p>
<ol>
<li>零行位于所有非零行的下面。</li>
<li>首非零元前面零的个数一定逐行严格增加</li>
</ol>
<p><strong>行最简型矩阵：</strong></p>
<ol>
<li>行阶梯形矩阵经过初等行变换使得 <strong>每一行的首非零元全部变为1，且他们所在列的其他元素都是 0</strong>，则成这样的矩阵为 <strong>行最简型矩阵</strong></li>
</ol>
<h3 id="2-9-2-矩阵的秩"><a href="#2-9-2-矩阵的秩" class="headerlink" title="2.9.2 矩阵的秩"></a>2.9.2 矩阵的秩</h3><p>定义：在矩阵A中，<strong>不为零子式的最高阶数称为A的秩</strong>，r（A）=min（m，n），则A为满秩矩阵，否则为降秩矩阵</p>
<p>性质：</p>
<ul>
<li>任意矩阵A与秩满足： 0&lt;=r(A)&lt;=min(m,n)</li>
<li><p>矩阵A可逆，则|A|不为零，则与 r（A）=n 形成<strong>充分必要条件</strong>，矩阵A为<strong>满秩矩阵</strong></p>
<ul>
<li><strong>n阶方阵可逆的充要条件：r(A)=n</strong></li>
</ul>
</li>
<li><p><strong>行阶梯形矩阵的秩等于它非零行的行数或者首非零元的个数</strong></p>
</li>
</ul>
<p>求矩阵秩的一般方法：<strong>用初等变换将矩阵转换为阶梯型矩阵</strong></p>
<p>关于秩的相关结论：</p>
<ol>
<li>矩阵A的 n 阶子式全为0，则 r(A)&lt;n</li>
<li>矩阵A的 n 阶子式全不为0，则 r(A)&gt;=n</li>
<li>若矩阵A与B等价，则 r(A)=r(B)</li>
<li>若矩阵Q，P可逆，则 r(PA)=r(AQ)=r(PAQ)=r(A)</li>
</ol>
<h3 id="2-9-3-分块矩阵"><a href="#2-9-3-分块矩阵" class="headerlink" title="2.9.3 分块矩阵"></a>2.9.3 分块矩阵</h3><hr>
<h1 id="3-向量组的线性相关性"><a href="#3-向量组的线性相关性" class="headerlink" title="3. 向量组的线性相关性"></a>3. 向量组的线性相关性</h1><p>向量的线性运算</p>
<p><strong>线性方程组的向量形式： a1x1+a2x2+a3x3+ … a4x4=B，借助向量可以讨论线性方程组</strong></p>
<h2 id="3-1-向量组的线性关系"><a href="#3-1-向量组的线性关系" class="headerlink" title="3.1 向量组的线性关系"></a>3.1 向量组的线性关系</h2><h3 id="3-1-1-线性组合与线性表示"><a href="#3-1-1-线性组合与线性表示" class="headerlink" title="3.1.1 线性组合与线性表示"></a>3.1.1 线性组合与线性表示</h3><p>定义：设 n维向量组 a1，a2，a3 ，B</p>
<ol>
<li><p>若k1，k2，k3为任意一组常数，则称 k1a1+k2a2+k3a3…+k4a4为向量组 a1+a2+a3的一个<strong>线性组合</strong></p>
</li>
<li><p>若k1，k2，k3为任意一组常数，使得 B=k1a1+k2a2+k3a3+…knan成立，则称B可由向· 量组<strong>线性表示</strong></p>
</li>
</ol>
<p><strong>向量B是否可由a1,a2,a3,an线性表示的方法：判断线性方程组k1a1+k2a2+knan是否有解</strong></p>
<h3 id="3-1-2-线性相关与线性无关"><a href="#3-1-2-线性相关与线性无关" class="headerlink" title="3.1.2 线性相关与线性无关"></a>3.1.2 线性相关与线性无关</h3><ol>
<li>若存在一组<strong>不全为零</strong>的数 k1,k2,k3,kn 使得 k1a1+k2a2+…+knan =0 成立，则称a1,a2,a3是<strong>线性相关</strong>的</li>
<li>当且仅当 k1,k2,k3,kn <strong>全为零</strong> 使得 k1a1+k2a2+…+knan =0 成立，则称a1,a2,a3是<strong>线性无关</strong>的</li>
</ol>
<p>简单来说：</p>
<ol>
<li><strong>线性相关：有非零解</strong></li>
<li><strong>线性无关：只有零解</strong></li>
</ol>
<p><strong>判断一个向量组的线性关系的方法：</strong></p>
<ol>
<li>令 k1a1+k2a2+…+knan =0，求出 k1,k2,k3的值</li>
<li><strong>如果全为零：线性无关；不全为零：线性相关</strong></li>
</ol>
<hr>
<h3 id="3-1-3-线性相关性结论-重要"><a href="#3-1-3-线性相关性结论-重要" class="headerlink" title="3.1.3 线性相关性结论(重要)"></a>3.1.3 线性相关性结论(重要)</h3><ul>
<li><strong>s个n维 即n*s形式的矩阵：</strong>  线性方程组<strong>线性相关的充要条件是齐次线性方程组有非零解</strong>，<strong>线性无关的充要条件是齐次线性方程组只有零解</strong><ul>
<li><strong>n个n维 即方阵：向量组线性相关的充要条件是行列式的值为0；线性无关的充要条件是行列式的值不为0.</strong></li>
<li><strong>向量组所含向量的个数大于维数，向量组一定线性相关</strong></li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>方阵形式：直接判断行列式的值是否为零，线性相关D为0，线性无关D不为0</li>
<li>行数大于列数的矩阵：判断齐次线性方程组的解，线性相关有非零解，线性无关只有零解</li>
<li>列数大于行数的矩阵：向量个数大于维数，一定线性相关</li>
</ol>
</blockquote>
<ul>
<li>向量组 a1  a2  am线性<strong>相关</strong>的充分必要条件是：其中至少有一个向量可由其余m -1 个向量线性表示<ul>
<li>向量组 a1  a2  am线性<strong>无关</strong>的充分必要条件是：其中每一个向量都不能由其余m -1 个向量线性表示</li>
</ul>
</li>
<li>若向量组 a1  a2  am线性无关，而向量组 a1  a2  a3 B线性相关，<strong>则 B可由 a1  a2  a3 线性表示，且表达式唯一</strong></li>
<li>若部分线性相关，则整个向量组也线性相关<ul>
<li>若整体线性无关，则任意一个部分也线性无关</li>
</ul>
</li>
<li>如果n维向量组 a1  a2  an线性无关，则在每一个向量上都添加 m 个分量，得到的 <strong>n+m 维接长的向量组也线性无关</strong><ul>
<li>如果n维向量组 a1  a2  an线性相关，则在每一个向量上都减去 m 个分量，得到的 <strong>n-m 维截断的向量组也线性相关</strong></li>
</ul>
</li>
</ul>
<h2 id="3-2-向量组的秩"><a href="#3-2-向量组的秩" class="headerlink" title="3.2 向量组的秩"></a>3.2 向量组的秩</h2><h3 id="3-2-1-向量组的极大无关组"><a href="#3-2-1-向量组的极大无关组" class="headerlink" title="3.2.1 向量组的极大无关组"></a>3.2.1 向量组的极大无关组</h3><p>定义：设向量组T： a1 ,  a2 , a3 … an 中有一部分向量组 a1  a2   a3   ar （r&lt;n）满足</p>
<ol>
<li>a1 a2 a3  ar<strong>线性无关</strong></li>
<li>在向量组T中除去（1-r）任取一个向量 ai，<strong>满足 a1 a2  a3 ar，ai 线性相关</strong>，则称 a1  a2  a3  ar是向量组T的一个<strong>极大线性无关组</strong>。简称为极大无关组</li>
</ol>
<p>根据上节的结论:</p>
<blockquote>
<p>若向量组 a1  a2  am线性无关，而向量组 a1  a2  a3 B线性相关，<strong>则 B可由 a1  a2  a3 线性表示，且表达式唯一</strong></p>
</blockquote>
<p>可得：<strong>向量组T中任意向量 ai 都可由 a1  a2   a3   ar线性表示</strong></p>
<p>极大无关组不一定是唯一的，只含零向量的向量组没有极大无关组</p>
<hr>
<p>定义2：设有两个向量组1，2，向量组2中的每一个元素都可由向量组1线性表示，则<strong>称向量组2可由向量组1线性表示</strong>，否则称不可线性表示。</p>
<ul>
<li>若两个向量组1和2可以<strong>互相</strong>线性表示，则称他们<strong>等价</strong></li>
</ul>
<p>定理：</p>
<ul>
<li><strong>若向量组1可以由向量组2线性表示，且向量组1的元素个数大于向量组2的元素个数，则向量组1线性相关</strong></li>
</ul>
<h3 id="3-2-2-向量组的秩的定义"><a href="#3-2-2-向量组的秩的定义" class="headerlink" title="3.2.2 向量组的秩的定义"></a>3.2.2 向量组的秩的定义</h3><p>定义： 向量组T的极大无关组所包含向量的个数，称为向量组的的秩</p>
<p>定理：</p>
<ul>
<li>向量组 a1 a2  as<strong>线性无关</strong>的充要条件是 r(a1 a2 as)=s，即<strong>它的秩等于它所包含的向量的个数</strong></li>
<li>相互等价的向量组的秩相等</li>
<li><strong>如果两个向量组的秩相等，且其中一个向量组可由另一个线性表示，则两个向量组等价</strong></li>
</ul>
<blockquote>
<ol>
<li>秩的个数等于向量的个数，线性无关</li>
<li>秩的个数小于向量的个数，线性相关</li>
</ol>
</blockquote>
<p>行向量组与列向量组：</p>
<ul>
<li>行向量组的秩为<strong>行秩</strong>，列向量组的秩为<strong>列秩</strong></li>
<li><strong>行秩=列秩=矩阵的秩</strong></li>
</ul>
<p><strong>求向量组极大无关组的方法：先将列向量组构成矩阵A，然后对A实行初等行变换，把A化为行最简型矩阵，由行最简型矩阵列之间的关系，确定原向量组间的线性关系，从而确定极大无关组。</strong></p>
<h2 id="3-3-向量空间"><a href="#3-3-向量空间" class="headerlink" title="3.3 *向量空间"></a>3.3 *向量空间</h2><hr>
<h1 id="4-线性方程组"><a href="#4-线性方程组" class="headerlink" title="4. 线性方程组"></a>4. 线性方程组</h1><p>阶梯型方程组：对线性方程组做初等变换所得到的就是<strong>阶梯型方程组</strong></p>
<ul>
<li>系数矩阵：由未知数的系数所构成的矩阵称为线性方程组的<strong>系数矩阵</strong></li>
<li>线性方程组的系数和常数项所构成的矩阵称为线性方程组的<strong>增广矩阵</strong></li>
</ul>
<h2 id="4-1-消元法解线性方程组"><a href="#4-1-消元法解线性方程组" class="headerlink" title="4.1 消元法解线性方程组"></a>4.1 消元法解线性方程组</h2><ol>
<li><p>就是对方程组的增广矩阵做初等行变换，化为<strong>阶梯型矩阵</strong>，从而得到方程组的解</p>
</li>
<li><p>对增广矩阵化为<strong>行最简型矩阵</strong>，更容易求解</p>
</li>
</ol>
<blockquote>
<p>有无解的判定：</p>
<p>增广矩阵的秩 = 系数矩阵的秩 = 未知量的个数，则方程组 Ax=b 具有<strong>唯一解</strong></p>
<p>增广矩阵的秩 不等于 系数矩阵的秩，则方程组Ax=b<strong>无解</strong>，存在一行，满足系数项全为零，而常数项不为零</p>
</blockquote>
<h2 id="4-2-非齐次线性方程组解的判定"><a href="#4-2-非齐次线性方程组解的判定" class="headerlink" title="4.2 非齐次线性方程组解的判定"></a>4.2 非齐次线性方程组解的判定</h2><ul>
<li>线性方程组 Amn <em> X=b <em>*有解</em></em>的 充要条件 是 r（A，b）= r（A）</li>
<li>当线性方程组 Amn <em> X=b 有解时：<em>*r 为秩，n为系数项数，即未知量的个数</em></em><ul>
<li>若  r（A，b）= r（A）=<strong>r = n</strong>，方程组有<strong>唯一解</strong></li>
<li>若  r（A，b）= r（A）=<strong>r &lt; n</strong>，方 程组有<strong>无穷多解</strong></li>
</ul>
</li>
<li>同理， Amn <em> X =b <em>*无解</em></em>的充要条件是 r（A，b）!=r（A）</li>
</ul>
<h2 id="4-3-齐次线性方程组解的判定"><a href="#4-3-齐次线性方程组解的判定" class="headerlink" title="4.3 齐次线性方程组解的判定"></a>4.3 齐次线性方程组解的判定</h2><p>齐次线性方程组一定满足：r（A，b）=r（A）</p>
<ul>
<li>齐次线性方程组Amn <em> X=0 <em>*只有零解的充要条件是 r（A）= n</em></em></li>
<li>齐次线性方程组Amn <em> X=0 <em>*有非零解的充要条件是 r（A）&lt; n</em></em>（有非零解即为无穷多解）</li>
</ul>
<h2 id="4-4-齐次线性方程组的解的结构"><a href="#4-4-齐次线性方程组的解的结构" class="headerlink" title="4.4 齐次线性方程组的解的结构"></a>4.4 齐次线性方程组的解的结构</h2><p>解向量的概念</p>
<p><strong>若齐次线性方程组有非零解，则它会有无穷多解，这些解组成一个n维向量组，若能求出这个向量组的一个极大无关组，则就能用它来表示它的全部解，这个极大无关组称为齐次线性方程组的基础解系</strong></p>
<p>齐次线性方程组有非零解，则它一定有基础解系。</p>
<ul>
<li><p>定理1：<strong>如果齐次线性方程组Amn <em> X=0 的系数矩阵A的秩 r（A）= r &lt; n，则Amn </em> X=0 的基础解系中有 n-r个解向量</strong></p>
</li>
<li><p><strong>齐次线性方程组的基础解系求解</strong></p>
</li>
<li><p><strong>非齐次线性方程组的基础解系求解</strong></p>
</li>
</ul>
<h2 id="4-5-非齐次线性方程组的解的结构"><a href="#4-5-非齐次线性方程组的解的结构" class="headerlink" title="4.5 非齐次线性方程组的解的结构"></a>4.5 非齐次线性方程组的解的结构</h2><p>非齐次线性方程组的解的结构为：非齐次线性方程组的特解 + 齐次线性方程组的通解。</p>
<hr>
<blockquote>
<p>求线性方程组通解的一般步骤</p>
<p>齐次线性方程组：</p>
<ol>
<li>对于增广矩阵化简为 <strong>行最简型矩阵</strong></li>
<li>判断解的情况并且得到解向量的个数=n-r</li>
<li>通过行最简矩阵得到<strong>自由未知量</strong>，首非零元与自由未知量确定方程，求方程解，得到各个未知量的解，并且得到每一个<strong>基础解系</strong></li>
<li>通解为 各个基础解系的k倍和</li>
</ol>
<p>非齐次线性方程组：</p>
<ol>
<li>步骤与上面基本一致，但是通解为：特解 + 导出组（导出组指的是常数项为0）的基础解系</li>
</ol>
</blockquote>
<hr>
<h1 id="5-矩阵相似与对角化"><a href="#5-矩阵相似与对角化" class="headerlink" title="5. 矩阵相似与对角化"></a>5. 矩阵相似与对角化</h1><h2 id="5-1-特征值与特征向量"><a href="#5-1-特征值与特征向量" class="headerlink" title="5.1 特征值与特征向量"></a>5.1 特征值与特征向量</h2><p>定义1：<strong>设A=（aij）nn为n阶实方阵，如果存在某个非零 r 和某个n维非零列向量 p 满足： Ap=rp，则 r 是A 一个特征值，p是A的属于特征值为r 的一个特征向量</strong></p>
<p>定义2：带参数r的n阶方阵称为A的<strong>特征方阵</strong>；它的行列式称为A的<strong>特征多项式</strong>；|rE-A|=0称为A的<strong>特征方程</strong></p>
<p>求解特征值与特征向量的方法：</p>
<ul>
<li><strong>n阶实方阵的特征值就是它的特征方程的n个根</strong></li>
<li><strong>任意取定一个特征值，其对应特征向量就是相应齐次线性方程组（rE-A）x=0 的所有非零解</strong>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </li>
</ul>
<hr>
<h2 id="5-2-特征值与特征向量的若干结论"><a href="#5-2-特征值与特征向量的若干结论" class="headerlink" title="5.2 特征值与特征向量的若干结论"></a>5.2 特征值与特征向量的若干结论</h2><ol>
<li><p><strong>实方阵的特征值未必是实数，特征向量也未必是实向量</strong></p>
</li>
<li><p>上下三角矩阵的特征值就是它的<strong>全体对角元素</strong></p>
</li>
<li>一个向量p不可能是属于同一个方阵A的不同特征值的特征向量</li>
<li>n阶方阵和它的转置具有相同的特征值</li>
<li>r1  r2  r3 为A的全体特征值则必有：即<strong>特征值之和等于对角线元素之和（迹）</strong>，<strong>特征值之积等于行列式的值</strong></li>
</ol>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}\lambda_{i}=\sum_{i=1}^{n}a_{ii}=tr(A) \qquad \prod_{i=1}^{n}\lambda_{i}=|A|</script><ol>
<li><strong>只要 r 是A的特征值，那么 f(r) 一定是 f(A) 的特征值</strong></li>
</ol>
<hr>
<h3 id="5-2-1-求特征值和特征向量的一般方法"><a href="#5-2-1-求特征值和特征向量的一般方法" class="headerlink" title="5.2.1 求特征值和特征向量的一般方法"></a>5.2.1 求特征值和特征向量的一般方法</h3><p>步骤：</p>
<ol>
<li><p>求出特征值，检查特征值之和是否等于行列式对角线元素之和，即<strong>迹</strong>，特征值之积是否等于行列式的值。</p>
</li>
<li><p>属于特征值的特征向量全体是 …   </p>
</li>
</ol>
<h2 id="5-3-相似矩阵与可对角化的条件"><a href="#5-3-相似矩阵与可对角化的条件" class="headerlink" title="5.3 相似矩阵与可对角化的条件"></a>5.3 相似矩阵与可对角化的条件</h2><p>定义1： A与B是n阶方阵，如果存在一个n阶可逆矩阵P，使得 P-1AP=B，则称A与B相似，记作A~B</p>
<p><strong>相似矩阵具有对称性，传递性，反身性</strong></p>
<p>两矩阵相似的特征：</p>
<ol>
<li>相同的特征值</li>
<li>相同的行列式值</li>
<li>迹相等，即对角线元素之和相同</li>
<li>秩相同</li>
</ol>
<h3 id="5-3-1-矩阵可对角化"><a href="#5-3-1-矩阵可对角化" class="headerlink" title="5.3.1 矩阵可对角化"></a>5.3.1 矩阵可对角化</h3><p><strong>定理3：n阶方阵相似于n阶对角矩阵的充要条件：A有n个线性无关的特征向量</strong></p>
<p><strong>推论：如果n阶矩阵A有n个互不相同的特征值 r1 r2  r3  r4 … rn，则A与对角矩阵 相似，并且对角矩阵的对角线元素为 r1 r2  r3  r4 … rn。</strong></p>
<p>n阶矩阵与对角矩阵相似的充分必要条件是：对于A的每一个n重特征值，齐次线性方程组（rE-A）x=0 的基础解系中恰含n个向量</p>
<h2 id="5-4-向量的内积与正交矩阵"><a href="#5-4-向量的内积与正交矩阵" class="headerlink" title="5.4 向量的内积与正交矩阵"></a>5.4 向量的内积与正交矩阵</h2><h3 id="5-4-1-内积"><a href="#5-4-1-内积" class="headerlink" title="5.4.1 内积"></a>5.4.1 内积</h3><p>概念：两个矩阵的对应元素相乘再相加，得到的一个<strong>数值</strong>，是两个矩阵的内积，记作：[A，B]</p>
<ul>
<li>施瓦茨不等式</li>
</ul>
<p>定义2<strong>：向量的内积开根号 叫做向量的长度，向量的长度用||A||表示</strong>，例如：a=(a1,a2,a3) ， ||a||=根号下[a,a]，</p>
<ul>
<li>若 ||a||=1，称a为单位向量</li>
</ul>
<h3 id="5-4-2-正交向量组"><a href="#5-4-2-正交向量组" class="headerlink" title="5.4.2 正交向量组"></a>5.4.2 正交向量组</h3><p>定义：若[a,b]=0，则向量a，b正交</p>
<p><strong>由非零向量两两正交组成的向量组称为正交向量组</strong></p>
<ul>
<li>正交向量组内每一个ai一定是线性无关的</li>
</ul>
<hr>
<p>施密特正交化：正交化 -&gt; 单位化</p>
<h1 id="6-二次型"><a href="#6-二次型" class="headerlink" title="6. 二次型"></a>6. 二次型</h1><p>含n个变量的 二次齐次多项式称为一个n元二次型，简称二次型</p>
<ul>
<li>令A为一个实对称矩阵，二次型式用矩阵表示为 f=x^T Ax  <ul>
<li>A称为二次型f的矩阵，对称阵A的秩为二次型f的秩</li>
<li>二次型与对称阵具有一一对应的关系，<strong>一个二次型f由其对应的实对称矩阵A唯一确定。当给定了二次型f后，便可以确定其对应的实对称矩阵A</strong><ul>
<li>A的对角线元素为：aii为xi ^2项的<strong>系数</strong></li>
<li>A的其他元素为： aij = aji 为 xij 项的<strong>系数的 1/2</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-1-可逆变换"><a href="#6-1-可逆变换" class="headerlink" title="6.1 可逆变换"></a>6.1 可逆变换</h2><p>若C 是可逆矩阵，x=Cy为可逆线性变换；若C是正交矩阵，则x=Cy为正交线性变换</p>
<p><strong>定义： 如果A，B均为n阶方阵，若存在可逆矩阵C，使得 CT A C =B，则称A与B合同</strong></p>
<ul>
<li>如果A为对称矩阵，AB合同，则B也为对称矩阵</li>
<li>A与B合同，则R（A）=R（B）</li>
<li>合同具有传递性</li>
</ul>
<h2 id="6-2-二次型的标准型"><a href="#6-2-二次型的标准型" class="headerlink" title="6.2 二次型的标准型"></a>6.2 二次型的标准型</h2><p><strong>定义：只含平方项的 二次型称为二次型的标准型</strong></p>
<p>正交变换法化二次型为标准型的方法：</p>
<ol>
<li>写出二次型的矩阵A，求其特征值 </li>
<li>求出特征值对应的特征向量，并且将他们正交单位化</li>
<li>将正交单位化后的特征向量依次作为列向量构成正交矩阵P。</li>
<li>做正交变换 x=Py，得二次型的标准型</li>
</ol>
<blockquote>
<p>正交单位化的时候：</p>
<ol>
<li>如果对应不同的特征值，所以他们正交，直接单位化即可</li>
<li>如果对应相同的特征值，所以要首先正交化，然后再单位化</li>
</ol>
</blockquote>
<h3 id="6-2-1-配方法化二次型为标准型"><a href="#6-2-1-配方法化二次型为标准型" class="headerlink" title="6.2.1 配方法化二次型为标准型"></a>6.2.1 配方法化二次型为标准型</h3><h3 id="6-2-2-初等变换化二次型为标准型"><a href="#6-2-2-初等变换化二次型为标准型" class="headerlink" title="6.2.2 初等变换化二次型为标准型"></a>6.2.2 初等变换化二次型为标准型</h3><h2 id="6-3-正定二次型"><a href="#6-3-正定二次型" class="headerlink" title="6.3 正定二次型"></a>6.3 正定二次型</h2><p>判别方法：f=xT A x正定的充要条件是 矩阵A的特征值都是正数</p>
<p><strong>实对阵矩阵A正定的充要条件是 A的各阶顺序子式都大于0</strong></p>
<hr>
<h1 id="待完善"><a href="#待完善" class="headerlink" title="待完善 ~~~"></a>待完善 ~~~</h1>]]></content>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
</search>
