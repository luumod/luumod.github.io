<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/01/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo<i class="fa fa-external-link-alt"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation<i class="fa fa-external-link-alt"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting<i class="fa fa-external-link-alt"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub<i class="fa fa-external-link-alt"></i></span>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
  </entry>
  <entry>
    <title>STL源码学习（2） - 迭代器概念与traits编程技法</title>
    <url>/2023/03/07/STL%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A6%82%E5%BF%B5%E4%B8%8Etraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="1-迭代器设计思维"><a href="#1-迭代器设计思维" class="headerlink" title="1. 迭代器设计思维"></a>1. 迭代器设计思维</h1><p>STL的中心思想：将数据容器与算法分离开，彼此独立设计，再以一剂黏着剂将二者撮合在一起。</p>
<p>如何设计出这样的黏着剂呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个迭代器和一个搜索对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first != last &amp;&amp; *first != value) ++first;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find算法的源码揭示了 <strong>容器 算法与迭代器之间的合作关系</strong></p>
<hr>
<h2 id="1-1-制作List及其迭代器"><a href="#1-1-制作List及其迭代器" class="headerlink" title="1.1 制作List及其迭代器"></a>1.1 制作List及其迭代器</h2><p>来为list设计一个迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ mylist.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MT_LIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT_LIST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ListNode</span>(T val, ListNode* pnext = <span class="literal">nullptr</span>)</span><br><span class="line">		:_data(val), _next(pnext) &#123;&#125;</span><br><span class="line">	<span class="function">T <span class="title">value</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_data; &#125;</span><br><span class="line">	<span class="function">ListNode* <span class="title">next</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_next; &#125; <span class="comment">//关键函数</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> T&amp; val)<span class="type">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_data!=val; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T _data;</span><br><span class="line">	ListNode* _next;	<span class="comment">//next指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">List</span>() :_front(<span class="literal">nullptr</span>), _end(<span class="literal">nullptr</span>), _size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="comment">//单链表尾插</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_end</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ListNode&lt;T&gt;* pNew = <span class="keyword">new</span> ListNode&lt;T&gt;&#123; value &#125;;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_end-&gt;_next = pNew;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_end = pNew;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//单链表头插</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert_front</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ListNode&lt;T&gt;* pNew = <span class="keyword">new</span> <span class="built_in">ListNode</span>&lt;T&gt;(value);</span><br><span class="line">		pNew-&gt;_next = <span class="keyword">this</span>-&gt;_front;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_front = pNew;</span><br><span class="line">		<span class="keyword">this</span>-&gt;_size++;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_size == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;_end = <span class="keyword">this</span>-&gt;_front;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历链表</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(std::ostream&amp; out=std::cout)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ListNode&lt;T&gt;* temp = <span class="keyword">this</span>-&gt;_front;</span><br><span class="line">		<span class="keyword">while</span> (temp!=<span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			out &lt;&lt; temp-&gt;<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			temp = temp-&gt;_next;</span><br><span class="line">		&#125;</span><br><span class="line">		out &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">ListNode&lt;T&gt;* <span class="title">front</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_front; &#125;</span><br><span class="line">	<span class="function">ListNode&lt;T&gt;* <span class="title">end</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_end; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ListNode&lt;T&gt;* _end;</span><br><span class="line">	ListNode&lt;T&gt;* _front;</span><br><span class="line">	<span class="type">size_t</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !MT_LIST</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ mylist-iter.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_LIST_ITER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_LIST_ITER</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylist.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Node&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListIter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ListIter</span>&lt;Node&gt;(Node* p = <span class="literal">NULL</span>)</span><br><span class="line">		:_ptr(p) &#123;&#125;</span><br><span class="line">	Node&amp; <span class="keyword">operator</span>*()<span class="type">const</span> &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">	Node* <span class="keyword">operator</span>-&gt;()<span class="type">const</span> &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line">	ListIter&amp; <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//前置++</span></span><br><span class="line">		_ptr = _ptr-&gt;<span class="built_in">next</span>(); <span class="comment">//! 暴露了ListNode的next函数</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListIter <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//后置++</span></span><br><span class="line">		ListIter temp = *<span class="keyword">this</span>;</span><br><span class="line">		++* <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ListIter&amp; lhs)<span class="type">const</span> &#123; <span class="keyword">return</span> _ptr == lhs._ptr; &#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ListIter&amp; lhs)<span class="type">const</span> &#123; <span class="keyword">return</span> _ptr != lhs._ptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node* _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ main</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylist-iter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	传入后first和last调用ListIter类的重载的!=运算符。</span></span><br><span class="line"><span class="comment">	但是*first得到的是ListNode&lt;T&gt;类型的值，因此为了比较与T类型的值还需要进行操作：</span></span><br><span class="line"><span class="comment">		1. 直接在外部添加针对ListNode&lt;T&gt;和T的!=的重载运算符</span></span><br><span class="line"><span class="comment">		2. 在ListNode&lt;T&gt;内添加重载!=的运算符</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span> (first != last &amp;&amp; *first != value) ++first;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ListNode&lt;T&gt;&amp; pnode, <span class="type">const</span> T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pnode.<span class="built_in">value</span>() != val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	List&lt;<span class="type">int</span>&gt; mlist;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		mlist.<span class="built_in">insert_front</span>(i);</span><br><span class="line">		mlist.<span class="built_in">insert_end</span>(i + <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	mlist.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	ListIter&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">beg</span>(mlist.<span class="built_in">front</span>());</span><br><span class="line">	ListIter&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; end;</span><br><span class="line">	ListIter&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; Iter;</span><br><span class="line">	Iter = <span class="built_in">find</span>(beg, end, <span class="number">11</span>);</span><br><span class="line">	<span class="keyword">if</span> (Iter == end) std::cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;找到了! &quot;</span> &lt;&lt; Iter-&gt;<span class="built_in">value</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>为了实现一个针对 List的迭代器，我们暴露了太多关于 List 的细节：</p>
<ol>
<li>在制作beg和end迭代器的时候，我们<strong>暴露了 ListNode 这个一个类</strong>。</li>
<li>在 Find 的时候，我们<strong>暴露了 ++ 运算符的关于 ListNode类的 next操作</strong>。</li>
</ol>
<p>ListNode作为一个内部节点，<strong>应该完全隐藏起来才对</strong>。</p>
<p>这时 List 的迭代器的一个雏形，通过往下的学习，我们将逐步解决这些问题。</p>
<hr>
<h2 id="1-2-迭代器的相应型别"><a href="#1-2-迭代器的相应型别" class="headerlink" title="1.2 迭代器的相应型别"></a>1.2 迭代器的相应型别</h2><p>在运用迭代器的时候，我们很可能会用到迭代器的<strong>相应型别</strong>，</p>
<p><strong>迭代器所指之物的型别便是相应型别</strong></p>
<p>获得<strong>《迭代器相应型别》 的型别</strong>：</p>
<p>利用 function template的<strong>参数推导机制</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_temp</span><span class="params">(Iter it,T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//it: int* ; t: int</span></span><br><span class="line">	T tmp; <span class="comment">//tmp: int</span></span><br><span class="line">    <span class="comment">//func：</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func_temp</span>(val, *val);<span class="comment">//val: int* ;  *val: int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(&amp;a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>把func函数全部功能全部放入func_temp中，在func_temp通过template参数推导自动获得了 <strong>型别T</strong></p>
<p><strong>这样T 就是迭代器所指之物的型别</strong></p>
<p>但是迭代器的相应型别不只是所指之物的型别，<strong>相应的型别有五种</strong>，但是并非任何情况下都能使用这个<strong>template参数推导</strong>来取得。</p>
<hr>
<h2 id="1-3-Traits编程技巧"><a href="#1-3-Traits编程技巧" class="headerlink" title="1.3 Traits编程技巧"></a>1.3 Traits编程技巧</h2><p>迭代器所指对象的型别称为 该迭代器的 <strong>value type</strong>。</p>
<p>template参数推导无法处理作为返回值的 value type，如果解决这个问题？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mystu</span></span><br><span class="line">&#123;</span><br><span class="line">	T* ptr;</span><br><span class="line">	<span class="built_in">Mystu</span>(T* ptr = <span class="literal">NULL</span>) :<span class="built_in">ptr</span>(ptr) &#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*()<span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">func2</span><span class="params">(T ite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//T的型别是 ite的型别即 Mystu&lt;int&gt; 但是作为返回值的类型是什么呢？</span></span><br><span class="line">	<span class="keyword">return</span> *ite;<span class="comment">//解引用获得其值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<strong>内嵌类型声明</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mystu</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;	<span class="comment">//内嵌型别</span></span><br><span class="line">	T* ptr;</span><br><span class="line">	<span class="built_in">Mystu</span>(T* ptr = <span class="literal">NULL</span>) :<span class="built_in">ptr</span>(ptr) &#123;&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*()<span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">func2</span><span class="params">(T ite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//T的型别是 ite的型别即 Mystu&lt;int&gt; 但是作为返回值的类型是什么呢？</span></span><br><span class="line">	<span class="keyword">return</span> *ite;<span class="comment">//解引用获得其值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mystu&lt;<span class="type">int</span>&gt; b&#123; <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">10</span>&#125; &#125;;</span><br><span class="line">	std::cout&lt;&lt;<span class="built_in">func2</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键做法：</p>
<ol>
<li>在类中 需要对 T 参数进行typedef。</li>
<li>在作为返回值的地方必须使用 typename 作为修饰，然后返回T的型别</li>
</ol>
<p><strong>关键词typename告诉编译器这是一个 Mystu&lt; T &gt;::value_type的型别</strong></p>
<hr>
<p>但是如果不是 <strong>类类型</strong>，就无法使用上述的<strong>定义内嵌类型</strong>的形式</p>
<p>原生指针就不是类，因此无法定义内嵌型别。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* c = <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">10</span> &#125;;</span><br><span class="line">std::cout&lt;&lt;<span class="built_in">func2</span>(c);	<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
<p>你会发现，就会报错，<strong>没有匹配的函数</strong>，因为<strong>原生指针不是类，无法定义内嵌类型</strong></p>
<p>但是STL提供了一种方法可以使得原生指针作为一种特殊情况被一般化。</p>
<p><strong>偏特化！</strong></p>
<p>萃取迭代器的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3. 萃取迭代器的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> <span class="comment">//普通类型</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//如果 T 有自己的value_type 那么通过这个traits，萃取出来的value_type 就是T的value_type</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;T&gt;::<span class="function">value_type <span class="title">func3</span><span class="params">(T ite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *ite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们会发现，他不和上面的内嵌型别是一样的吗，而且返回值还写复杂了，有什么用呢？</p>
<p>我们再写一个针对iterator_traits的偏特化版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// traits的特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这时候，你就会发现，这条语句竟然成功了，并且返回 10作为返回值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* c = <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">10</span> &#125;;</span><br><span class="line">std::cout&lt;&lt;<span class="built_in">func3</span>(c);	<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>
<p>这是因为 c作为一个普通的指针，<strong>我们传入 func3 函数之后，函数察觉到了 这是一个原生指针，因此调用 iterator_traits的原生指针T* 的偏特化版本，使得可以接受一个原生指针</strong></p>
<p>解决 参数是 const 类型的原生指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* d = <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">20</span> &#125;;</span><br><span class="line">std::cout&lt;&lt;<span class="built_in">func3</span>(d);	<span class="comment">//OK but 我们返回的仍然是const int 类型的值</span></span><br></pre></td></tr></table></figure>
<p>如果我们返回一个 非 const，则可以针对const 指针再来一个偏特化版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// traits的特化版本 const版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​    这样函数的返回值就是一个 非const，即去除了 参数的 const属性。</p>
<p>traits 所扮演的特性是 <strong>特性萃取机</strong>的角色，<strong>萃取各个迭代器的相应型别</strong>，要使得 特性萃取机能够有效的工作，每一个迭代器都应该以<strong>内嵌类型定义</strong>的形式定义出<strong>相应的型别</strong>。</p>
<hr>
<p>迭代器一共有五种<strong>相应型别</strong>：</p>
<ol>
<li><strong>value_type</strong></li>
<li><strong>difference_type</strong></li>
<li><strong>pointer</strong></li>
<li><strong>reference</strong></li>
<li><strong>iterator_catagoly</strong></li>
</ol>
<p><strong>为你的迭代器定义这五种相应型别。</strong></p>
<hr>
<h3 id="1-3-1-value-type"><a href="#1-3-1-value-type" class="headerlink" title="1.3.1 value_type"></a>1.3.1 value_type</h3><p>value_type是指<strong>迭代器的所指对象</strong>的相应型别。如上节所示，value_type 是任何STL容器的设计基础。</p>
<h3 id="1-3-2-deference-type"><a href="#1-3-2-deference-type" class="headerlink" title="1.3.2 deference_type"></a>1.3.2 deference_type</h3><p>deference_type用来表示表示<strong>两个迭代器之间的距离</strong>，可以用来表示一个容器的最大容量。</p>
<p>count函数用来返回等于val值的个数，因此如果一个<strong>泛型算法具有计数的功能</strong>，其返回值就必须使用deference_type类型的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::deference_type deference_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//count算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;T&gt;::<span class="function">deference_type <span class="title">count</span><span class="params">(Iter beg, Iter end, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;T&gt;::deference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; beg != end; ++beg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*beg == val)n++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们刚才自己写的 List就可以来测试一下：</p>
<p>只需要在<strong>List 的类中加上</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type</span><br></pre></td></tr></table></figure>
<p>ptrdiff_t 是 一个 int64类型的值，用于统计。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::difference_type difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//针对原生指针的偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对原生指针const的偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::difference_type _count(Iter beg, Iter end, <span class="type">const</span> T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::difference_type n = <span class="number">0</span>;<span class="comment">//n: ptrdiff_t</span></span><br><span class="line">	<span class="keyword">for</span> (; beg != end; ++beg)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*beg == val)</span><br><span class="line">			++n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	List&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p.<span class="built_in">insert_end</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	p.<span class="built_in">insert_end</span>(<span class="number">5</span>);</span><br><span class="line">	p.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	ListIter&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">beg</span>(p.<span class="built_in">front</span>());</span><br><span class="line">	ListIter&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; end;</span><br><span class="line">	ListIter&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; Iter;</span><br><span class="line">	<span class="keyword">auto</span> ppp =  _count(beg, end, <span class="number">5</span>);</span><br><span class="line">	std::cout &lt;&lt; ppp &lt;&lt; std::endl;	<span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="1-3-3-reference-和-pointer"><a href="#1-3-3-reference-和-pointer" class="headerlink" title="1.3.3 reference 和 pointer"></a>1.3.3 reference 和 pointer</h3><p>代表迭代器所指对象的<strong>引用与指针类型</strong>，实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">const</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="1-3-4-iterator-category"><a href="#1-3-4-iterator-category" class="headerlink" title="1.3.4 iterator_category"></a>1.3.4 iterator_category</h3><p>首先来看迭代器的五种类型：</p>
<ol>
<li>Input iterator：只读迭代器</li>
<li>Output iterator：只写迭代器</li>
<li>Forward iterator：可读可写迭代器</li>
<li>Bidirectional iterator：双向移动迭代器</li>
<li>Random Access iterator：<strong>前四种迭代器都支持一种指针运算（++或者—），而此迭代器支持所有的指针运算。</strong></li>
</ol>
<p><strong>这五种迭代器自上而下呈加强状态，即功能越来越强。</strong></p>
<p>要对某种迭代器提供一种<strong>准确的定义</strong>，对另一种<strong>强化的迭代器</strong>提供另一种定义，这样才能使得效率最大化。</p>
<p>举例：如何设计 <strong>Advance函数</strong></p>
<p>advance函数的含义是传入两个参数，并且<strong>将第一个参数的迭代器 前进 n个位置。</strong></p>
<p>如何针对指定的迭代器类型来选择合适的实现功能呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于只读迭代器：Input 可读可写迭代器：Forward 都是这样的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator Iter, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (n--) ++Iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于双向迭代器：Bidirectional </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Bidirectional, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(Bidirectional Iter, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (n--) ++Iter;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (n++) --Iter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于随机迭代器：Random</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(RandomIterator Iter, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Iter += n;<span class="comment">//随机迭代器支持任意的指针运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们写出了每种迭代器的<strong>最佳的选择</strong>，那么我们怎么确定一个最终的执行函数呢？</p>
<p>难道要设计几个函数判断其是为<strong>只读型迭代器</strong>还是<strong>双向迭代器</strong>还是<strong>随机迭代器</strong>？</p>
<p>但是这样每次在执行advanc的时候都执行一次<strong>选择哪个版本的判断，太影响效率了</strong>，我们最好在编译期间就能判断执行哪个版本，我们可以使用<strong>重载函数的机制来实现</strong>。</p>
<p><strong>我们让这三个函数同名，并且加上第三个参数，第三个参数为迭代器类型，使得traits可以根据第三个参数的类型来推断出执行哪个函数</strong>。</p>
<p>因此第三个参数一定是一个 <strong>类</strong> 类型，我们使用以下方式来解决：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//五个标记类型</span></span><br><span class="line"><span class="comment">//五个标记类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Input_Iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Output_Iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Forward_Iterator_tag</span>: <span class="keyword">public</span> Input_Iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bidirectional_Iterator_tag</span>: <span class="keyword">public</span> Forward_Iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Random_Iterator_tag</span>:<span class="keyword">public</span> Bidirectional_Iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于只读迭代器：Input 可读可写迭代器：Forward 都是这样的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> _advance(InputIterator Iter, Distance n,Input_Iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (n--) ++Iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于可读可写迭代器:直接调用Input</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> _advance(InputIterator Iter, Distance n, Forward_Iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	_advance(Iter,n, <span class="built_in">Input_Iterator_tag</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于双向迭代器：Bidirectional </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Bidirectional, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> _advance(Bidirectional Iter, Distance n,Bidirectional_Iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (n--) ++Iter;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (n++) --Iter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于随机迭代器：Random</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(RandomIterator Iter, Distance n,Random_Iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Iter += n;<span class="comment">//随机迭代器支持任意的指针运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建<strong>五种迭代器标记</strong>，他们只作为标记使用，在实际的_advance中无需参数的名称，根据是哪一个型别，编译器可以推断出使用哪一个版本。</p>
<p>对于最终的执行函数，我们只需要来 traits萃取迭代器的类型即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//iterator_category函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::<span class="function">iterator_category <span class="title">iterator_category</span><span class="params">(<span class="type">const</span> Iter&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iter&gt;::iteratr_category category;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">category</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::iterator_category iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//原指针的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Random_Iterator_tag iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//const指针的偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> Random_Iterator_tag iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//执行函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator,<span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; it, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_advance(it, n, <span class="built_in">iterator_category</span>(it));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于advance函数来说，InputIterator作为其函数参数类型的名字是合理的。</p>
<p><strong>因为STL的命名规则是 以函数所能接受的最低阶迭代器类型作为其迭代器参数的类型名称</strong></p>
<hr>
<h3 id="1-3-5-迭代器标签"><a href="#1-3-5-迭代器标签" class="headerlink" title="1.3.5 迭代器标签"></a>1.3.5 迭代器标签</h3><p>上面描述的五个迭代器的标签，不仅可以促成<strong>函数重载机制与traits萃取的功效</strong></p>
<p>而且通过继承，我们不必再写多个 标签的函数。</p>
<p>distance的函数是计算两个迭代器之间的距离：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type  </span><br><span class="line">	_distance(InputIterator beg, InputIterator end, Input_Iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (beg != end)</span><br><span class="line">	&#123;</span><br><span class="line">		++beg;</span><br><span class="line">		++n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;RandomIterator&gt;::difference_type</span><br><span class="line">	_distance(RandomIterator beg, RandomIterator end, Random_Iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//直接计算差距</span></span><br><span class="line">	<span class="keyword">return</span> end - beg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function">	<span class="title">distance</span><span class="params">(InputIterator beg, InputIterator end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category;</span><br><span class="line">	_distance(beg, end, <span class="built_in">category</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需处理两个迭代器类型即可，即InputIterator和RandomIterator</p>
<p>因为 其他的迭代器都可由 InputIterator 完全替代，通过继承我们可以直接指定他们的默认_distance 函数就是 InputIterator的 _distance函数。</p>
]]></content>
      <categories>
        <category>源码剖析</category>
      </categories>
      <tags>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法例题与讲解（2）</title>
    <url>/2023/03/06/%E8%B4%AA%E5%BF%83%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="P1478-陶陶摘苹果（升级版）"><a href="#P1478-陶陶摘苹果（升级版）" class="headerlink" title="P1478 陶陶摘苹果（升级版）"></a>P1478 陶陶摘苹果（升级版）</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE0Nzg=">P1478 陶陶摘苹果（升级版）<i class="fa fa-external-link-alt"></i></span></p>
<p>直接将摘苹果所需要的力气按照从到大排序即可。</p>
<p>那么这样，<strong>摘的最轻松的苹果不摘白不摘</strong>，摘它这么轻松，干嘛不摘。</p>
<p>如果遇到了 <strong>足够力气摘得苹果，但是高度够不到，不摘不就好了</strong>，又不损失什么，反正我们是按照花费得力气排序的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;apple[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.y&lt;b.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;apple[i].x&gt;&gt;apple[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(apple+<span class="number">1</span>,apple+<span class="number">1</span>+n,comp);</span><br><span class="line">    <span class="type">int</span> sum=a+b;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (apple[i].x&lt;=sum &amp;&amp; apple[i].y&lt;=m)</span><br><span class="line">        &#123;</span><br><span class="line">            m-=apple[i].y;</span><br><span class="line">            ans+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P5019-NOIP2018-提高组-铺设道路"><a href="#P5019-NOIP2018-提高组-铺设道路" class="headerlink" title="P5019 [NOIP2018 提高组] 铺设道路"></a>P5019 [NOIP2018 提高组] 铺设道路</h1><hr>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDUwMTk=">P5019 [NOIP2018 提高组] 铺设道路<i class="fa fa-external-link-alt"></i></span></p>
<p>这是一种很重要的贪心问题！</p>
<p>处理连续的一段区间，让这个区间里的数字做一些操作。</p>
<p>常见的这类问题有：</p>
<ol>
<li>这段区间的每个值都减少 1，直到为0为止，操作的区间的数字不能是0</li>
<li>发牌，每次从区间中发出一些牌，只能连续的发，不能跳跃，求出发完所有牌的最小发牌次数</li>
</ol>
<p>总结为一类问题：<strong>求 操作每个元素都不为零 的一段区间，使得整个序列所有的元素都为0的最少操作次数，每次操作只能操作一段区间</strong></p>
<p>回到这题：贪心算法如何求解？</p>
<p>可以注意到如果第 i 个的元素大于第 i-1 个位置的元素，<strong>则对 i 和 i-1 位置的操作次数一定是 nums[i] 减去 nums[i-1]</strong></p>
<p>即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i]&gt;nums[i<span class="number">-1</span>]) ans+=nums[i]-nums[i<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>注意到 ： i 位置的元素一定比 i-1 位置的元素大，因此无论如何你一定要 对 i 位置的元素操作为0，所以对 i 位置的元素操作相当于免费操作了 i -1 位置的元素。</p>
<p>类似于如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 2 5 3 5 </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 0 2 3 5</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 0 2 1 3</span><br></pre></td></tr></table></figure>
<p>最后遍历完整个序列之后，ans+ =nums[1]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 </span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]&lt;nums[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=nums[i+<span class="number">1</span>]-nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans+nums[<span class="number">1</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1208-USACO1-3-混合牛奶-Mixing-Milk"><a href="#P1208-USACO1-3-混合牛奶-Mixing-Milk" class="headerlink" title="P1208 [USACO1.3]混合牛奶 Mixing Milk"></a>P1208 [USACO1.3]混合牛奶 Mixing Milk</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEyMDg=">P1208 [USACO1.3]混合牛奶 Mixing Milk<i class="fa fa-external-link-alt"></i></span></p>
<p>贪心思路：直接按照牛奶的<strong>单价</strong>进行排序，如果<strong>单价有一样的，则按照 量多的在前面</strong></p>
<p>很明显，量多的并且单价还便宜的一定是最优的。</p>
<p>因此直接AC：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,p;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.a&lt;b.a) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.a==b.a) <span class="keyword">return</span> a.p&gt;b.p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;node[i].a&gt;&gt;node[i].p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node+<span class="number">1</span>,node+<span class="number">1</span>+m,comp);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (node[i].p&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            n-=node[i].p;<span class="comment">//购买了p个</span></span><br><span class="line">            ans+=node[i].a*node[i].p;<span class="comment">//p种的总成本</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans+=node[i].a*n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1094-NOIP2007-普及组-纪念品分组"><a href="#P1094-NOIP2007-普及组-纪念品分组" class="headerlink" title="P1094 [NOIP2007 普及组] 纪念品分组"></a>P1094 [NOIP2007 普及组] 纪念品分组</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwOTQ=">P1094 [NOIP2007 普及组] 纪念品分组<i class="fa fa-external-link-alt"></i></span></p>
<p>很典型的贪心问题：要使得组的数量尽可能少，则组内两个纪念品一定是一个<strong>尽量可能小，一个尽量可能大</strong></p>
<p>这样才满足<strong>一个组的利用率达到最高</strong></p>
<p><strong>即寻找 小于等于最大价值之和的 能够提供最大价值的两个纪念品</strong></p>
<p>则我们<strong>单价</strong>进行排序，<strong>左边尽量小</strong> 和 <strong>右边尽量大</strong> 的在 满足不大于最大价值<strong>限制</strong>的情况下，要组成一组，</p>
<p>如果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (s左 + s右 &gt; limit)</span><br><span class="line">&#123;</span><br><span class="line">	I右--  </span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">	I左++</span><br><span class="line">	I右--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则这样遍历完一遍后，整个序列中满足条件的<strong>两个最优的纪念品就分好了</strong>，则其他的就只能单独一组！</p>
<p>贪心算法的证明， 某大佬的解答：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvaGVpZG91ZG91L3NvbHV0aW9uLXAxMDk0">题解 P1094 【纪念品分组】 - heidoudou 的博客 - 洛谷博客 (luogu.com.cn)<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="type">bool</span> fg[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums+<span class="number">1</span>,nums+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[l]+nums[r]&gt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//不能分组</span></span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            fg[l]=<span class="literal">true</span>,fg[r]=<span class="literal">true</span>;</span><br><span class="line">            r--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dbg(fg,n);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fg[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题训练</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法例题与讲解（1）</title>
    <url>/2023/03/05/%E8%B4%AA%E5%BF%83%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="P2240-部分背包问题"><a href="#P2240-部分背包问题" class="headerlink" title="P2240  部分背包问题"></a>P2240  部分背包问题</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIyNDA=">P2240 【深基12.例1】部分背包问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<i class="fa fa-external-link-alt"></i></span></p>
<p>有点像01背包，但是又不是，01背包的物品的是不能再分的，而本题的物品是可以<strong>再分的</strong>，因此我们可以根据某个物品的<strong>部分重量和单位价值</strong>算出它的<code>部分最大价值</code>来作为我们选择的物品。</p>
<ol>
<li>首先计算<strong>单位价值</strong> = 总价值 / 总重量</li>
<li>按照贪心的思想，则单位价值大的一定是越优的，因此<strong>排序</strong>，单位价值大的排在前面。</li>
<li>按照单位价值排好序的顺序一个一个物品选，若背包的剩余容量不够则取某个物品的<code>部分最大价值</code>，然后退出即可。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,T;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> w,v,pro;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.pro&gt;b.pro)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;node[i].w&gt;&gt;node[i].v;</span><br><span class="line">        node[i].pro=node[i].v/node[i].w;	<span class="comment">//计算单位价值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node+<span class="number">1</span>,node+<span class="number">1</span>+n,cmp);<span class="comment">//按照单位价值排序</span></span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> temp=T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp&gt;=node[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=node[i].v;</span><br><span class="line">            temp-=node[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans+=(temp*node[i].pro);<span class="comment">//取最大部分价值</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,ans);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1223-排队接水"><a href="#P1223-排队接水" class="headerlink" title="P1223 排队接水"></a>P1223 排队接水</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEyMjM=">排队接水<i class="fa fa-external-link-alt"></i></span></p>
<p> 排队接水：一列人排成一队，接水的人有个<strong>接水的时间</strong>，而其他人都要<strong>等</strong>这个人接完水，然后再轮流接水，已经接完水的就完成任务了，即不需要算在排队等接水的人当中了。</p>
<p>我们要计算n个人的平均接水时间，因此需要把<strong>当前人接水的时间 * 后面等待的总人数</strong></p>
<p>因此我们可以总结出：<strong>最先接水的一定是接水所需时间最少的</strong>。为什么？</p>
<ul>
<li>如果你的接水时间是 1000 ，那么除这个人之外的9个人就需要等待 9 * 1000的时间。</li>
<li>如果你的接水时间是 10 ，那么除这个人之外的9个人就需要等待 9 * 10 的时间。</li>
</ul>
<p><strong>很显然按照接水时间短的先接水的这种做法一定是最优的。</strong></p>
<p>那么就直接按照时间排序即可，然后计算 平均的等待时间，最后再除以一次总人数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N],presum[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num,val;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.val&lt;b.val) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.val==b.val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.num&lt;b.num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        node[i].num=i;</span><br><span class="line">        cin&gt;&gt;node[i].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node+<span class="number">1</span>,node+<span class="number">1</span>+n,comp);<span class="comment">// 按照接水的时间排序，如果时间相等，则按序号</span></span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=(n-i)*node[i].val;<span class="comment">//后面的每个人都需要等这个时间</span></span><br><span class="line">        cout&lt;&lt;node[i].num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,ans/n);<span class="comment">//最后再计算平均值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1   </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1803-凌乱的yyy-线段覆盖"><a href="#P1803-凌乱的yyy-线段覆盖" class="headerlink" title="P1803 凌乱的yyy / 线段覆盖"></a>P1803 凌乱的yyy / 线段覆盖</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE4MDM=">P1803 凌乱的yyy / 线段覆盖<i class="fa fa-external-link-alt"></i></span></p>
<p>这道题其实就是贪心的经典问题：<strong>给出任务的开始和结束时间，求总共能完成的任务的最大数量</strong></p>
<p>贪心思路：</p>
<ul>
<li><strong>结束时间早的一定是最优的（在此不给出证明）</strong></li>
</ul>
<p>过程如下；</p>
<ol>
<li><p>因此把每个任务按照结束时间排序，结束时间早的是最优的。</p>
</li>
<li><p>按照结束时间<strong>早正序</strong>排序，如果下一个任务的开始时间在上一个任务的进行过程中，则说明还没有完成上一个任务，因此跳过这个任务，<strong>只能是下一个任务的开始时间最差的等于上一个任务的结束时间</strong></p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s,e;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.e&lt;=b.e) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;node[i].s&gt;&gt;node[i].e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束时间最早</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fg=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(node+<span class="number">1</span>,node+<span class="number">1</span>+n,comp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">1</span>)<span class="comment">//第一个一定是可以的</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            fg=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (node[i].s&gt;=node[fg].e)	<span class="comment">//如果下一个任务的开始在上一个任务的结束，则可以</span></span><br><span class="line">            &#123;</span><br><span class="line">                fg=i;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1090-NOIP2004-提高组-合并果子"><a href="#P1090-NOIP2004-提高组-合并果子" class="headerlink" title="P1090 [NOIP2004 提高组] 合并果子"></a>P1090 [NOIP2004 提高组] 合并果子</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwOTA=">P1090 [NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G<i class="fa fa-external-link-alt"></i></span></p>
<p>题目让我们求合并两堆的最小花费的总和， 因此我们很容易想到<strong>最小的两堆一起合并一定是最优的</strong></p>
<p><strong>我们便可以想到直接排序即可，花费小的在前面，然后前两个合并成一个，然后再把这个合并的放进去再排序，最后知道这个队列只有一个元素为止，因此我们每次所统计的两堆的和就是最后的答案。</strong></p>
<p>这道题目的思想是很容易的。</p>
<p>但是如何做到 <strong>将两堆取出来合并后的值再放回去</strong> ？ 我们可以想到 堆排序。</p>
<p>进而想到堆排序的一个应用：<strong>优先队列</strong></p>
<p>我们要制造 <strong>小顶堆</strong>，即堆顶元素是最小的，然后取出堆的前两个元素，合并后再<strong>插入堆</strong></p>
<p>优先队列C++：<code>priority_queue</code>小顶堆形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q;</span><br></pre></td></tr></table></figure>
<p>大顶堆形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;int&gt; q;</span><br></pre></td></tr></table></figure>
<p>因此就解决了，当然你也可以<strong>手写堆</strong>，包含构建<strong>初始堆和堆的调整过程</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        q.<span class="built_in">push</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">size</span>()==<span class="number">1</span>)<span class="comment">//特判</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;q.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num1=q.<span class="built_in">top</span>();	<span class="comment">//取出最小的</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> num2=q.<span class="built_in">top</span>();	<span class="comment">//取出第二小的</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> sum=num1+num2;</span><br><span class="line">        ans+=sum;<span class="comment">//注意统计res</span></span><br><span class="line">        q.<span class="built_in">push</span>(sum);	<span class="comment">//合并后再插入堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P3817-小A的糖果"><a href="#P3817-小A的糖果" class="headerlink" title="P3817 小A的糖果"></a>P3817 小A的糖果</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MTc=">P3817 小A的糖果<i class="fa fa-external-link-alt"></i></span></p>
<p>让我们求 在相邻的两个盒子的总数不超过 m 的情况下，至少需要吃的数量。</p>
<p>貌似我们可以进行排序？ 从小到大，然后从左往右吃</p>
<p><strong>不可以</strong></p>
<p>我们注意到盒子是有先后顺序的，因此不能够改变位置（当然如果你会排序的做法则当我没说）</p>
<p>我们就直接贪心即可：</p>
<ol>
<li>从左往右遍历，如果当前的盒子 i 的数量 + 后一个盒子 i+1 的数量 超过了规定 m，则我们一定需要在这两个中吃糖果，如何吃呢？<ol>
<li>如果我们选择吃 i ，则 我们只会改变 i+1着一种情况，即 【i，i+1】是一组</li>
<li>但是如果我们吃 i+1，则我们不仅改变了【i，i+1】这一组，还可能改变 【 i+1，i+2】下一组，<strong>因此吃后面的一定是最优的（求最少的吃的数量）</strong></li>
</ol>
</li>
<li>遍历到后面的每个 i 盒子的时候，它的 i -1个位置的盒子数量 一定被上一种情况吃了。但是我们的第 1 个盒子怎么办呢，它可没有前一个？<ol>
<li>我们直接错一下位即可， <strong>让0（实际不存在，从1开始）号盒子 与 1 号成一组，然后我们吃后面的，这样不就吃到 1 号盒子了吗</strong></li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=i<span class="number">-1</span>,b=i;	<span class="comment">//从0开始，则保证了1号也能作为第二个盒子</span></span><br><span class="line">        <span class="keyword">if</span> (nums[a]+nums[b]&gt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//尽量吃第二个</span></span><br><span class="line">            ans+=nums[a]+nums[b]-m;<span class="comment">//两个的总数 - 规定 = 这组中要吃的数量</span></span><br><span class="line">            nums[b]=m-nums[a];	<span class="comment">//全部吃第二个盒子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="P1106-删数问题"><a href="#P1106-删数问题" class="headerlink" title="P1106 删数问题"></a>P1106 删数问题</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDExMDY=">P1106 删数问题<i class="fa fa-external-link-alt"></i></span></p>
<p>在序列中删除 k 位后能够组成的最小的数。</p>
<p>貌似很简单？ </p>
<p><strong>直接从左往右，碰到一个 i 位置元素如果比 i-1 位置的元素大 ，则删除 i 位置的元素？</strong></p>
<p><strong>错误的</strong>！！</p>
<p>示例：</p>
<p>1 5 9 8 (2) ，删除两个，按照上面的思路，则删除 5 和 9，最后得到 18，但是实际上 15是最优的（删后两个）</p>
<p>1 2 6 5 9 7 （3），删除三个，按照上面的思路，则删除 2 6 和 9，得到了 1 5 7，但是实际上只要 2没被删除则其他的都比这个小。</p>
<p>那么怎么删呢？ 观察一下<strong>式子</strong>，<strong>定义：比两边都大，则此位置为山峰</strong></p>
<p>1 5 9(山峰) 8(山峰)  ：删除<strong>山峰</strong>，得到 1 5</p>
<p><strong>为什么 8 也是山峰，9比8大啊，因为我们提前删除了9，因此 8 的前面是 5。</strong></p>
<p>1 2 6(山峰) 5 9(山峰) 7(山峰)：删除山峰，得到 1 2 5</p>
<p><strong>答案：我们删除山峰位置的元素，则最后的数一定是最小的</strong></p>
<hr>
<p>实际上山峰在此题只需要表示为：<strong>比后面的数大即可</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Write code here</span></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s);<span class="comment">//原始长度</span></span><br><span class="line">    <span class="keyword">while</span> (k--)<span class="comment">//需要删除 k 个元素，每次循环一次则一定删除一个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i]&gt;s[i+<span class="number">1</span>]) <span class="comment">//如果比后面的数字大，则删除 i 位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//后面的位置元素依次覆盖过来，模拟删除 i 位置元素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;len<span class="number">-1</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    s[j]=s[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len--; <span class="comment">//s长度减1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;len &amp;&amp; s[i]==<span class="string">&#x27;0&#x27;</span>) i++;<span class="comment">//处理前导0，记录前0的数量</span></span><br><span class="line">    <span class="keyword">if</span> (i==len) <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);<span class="comment">//如果前0的数量等于s的长度，则整个都是0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//否则从i位置开始（忽略前0），直到最后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;s[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> one 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>刷题训练</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习(4) - git在服务器上的操作</title>
    <url>/2023/03/05/git%E5%AD%A6%E4%B9%A0-4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="1-协议"><a href="#1-协议" class="headerlink" title="1. 协议"></a>1. 协议</h1><p>Git使用四种协议来<strong>传输数据</strong>：</p>
<ol>
<li>本地传输</li>
<li>SSH协议</li>
<li>Git协议</li>
<li>HTTP协议</li>
</ol>
<h2 id="1-1-本地协议"><a href="#1-1-本地协议" class="headerlink" title="1.1 本地协议"></a>1.1 本地协议</h2><p>其实就是硬盘上的另一个目录，其中团队的每个成员都对一个<strong>共享的文件系统具有访问权</strong>。</p>
<p>如果你使用一个共享的文件系统，就可以在<strong>一个本地文件系统中克隆仓库，推送和获取</strong>。克隆的时候只需要将远程仓库的路径作为 URL 使用，比如下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone F:/code/git/Git-test</span><br><span class="line">Cloning into &#x27;Git-test&#x27;...</span><br><span class="line">done.</span><br></pre></td></tr></table></figure>
<p>这样我们就在<strong>本地的文件夹创建了一个具有本地协议的远程仓库</strong></p>
<p>也可以使用<code>file://</code> 的前缀：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone file://F:/code/git/Git-test</span><br><span class="line">Cloning into &#x27;Git-test&#x27;...</span><br><span class="line">remote: Enumerating objects: 35, done.</span><br><span class="line">remote: Counting objects: 100% (35/35), done.</span><br><span class="line">remote: Compressing objects: 100% (25/25), done.</span><br><span class="line">remote: Total 35 (delta 9), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Receiving objects: 100% (35/35), done.</span><br><span class="line">Resolving deltas: 100% (9/9), done.</span><br></pre></td></tr></table></figure>
<p>两种方式的不同：</p>
<ol>
<li>直接使用路径：Git会尝试以<strong>硬链接或者直接复制它文件</strong>。</li>
<li>如果使用file:// ：Git会调用它平时通过<strong>网络来传输数据的工序</strong>，效率相对较低。</li>
</ol>
<p>使用 <code>file://</code> 前缀的主要原因是当你需要一个<strong>不包含无关引用或对象的干净仓库副本</strong>的时候 — 一般指从其他版本控制系统导入的</p>
<hr>
<p>把本地的仓库添加作为你的远程仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add local_proj F:/code/git/Git-test/Git-test</span><br></pre></td></tr></table></figure>
<p>查看所有的远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">local_proj</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<p>现在我们就由 <code>local_proj</code> 和<code>origin</code>两个远程仓库了</p>
<h2 id="1-2-SSH协议"><a href="#1-2-SSH协议" class="headerlink" title="1.2 SSH协议"></a>1.2 SSH协议</h2><p>SSH协议是Git中最常用的协议。</p>
<p>SSH 也是唯一一个<strong>同时支持读写操作的网络协议</strong>，另外两个协议（HTTP和Git）通常是只读的，执行写操作一定是SSH协议。</p>
<p>SSH 同时也是一个验证授权的网络协议；而因为其普遍性，一般架设和使用都很容易。</p>
<p>SSH协议的使用我们都已经很熟悉了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone ssh://git@github.com:luumod/Git-test.git</span><br></pre></td></tr></table></figure>
<p>便可以把我们的GitHub上的仓库克隆到我们的本地。</p>
<p>可以省略<code>ssh://</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:luumod/Git-test.git</span><br></pre></td></tr></table></figure>
<p>通过 SSH 进行访问是安全的 — 所有数据传输都是加密和授权的。</p>
<p>最后，和 Git 及本地协议一样，SSH 也很高效，会在传输之前尽可能压缩数据。</p>
<h2 id="1-3-Git协议"><a href="#1-3-Git协议" class="headerlink" title="1.3 Git协议"></a>1.3 Git协议</h2><p>这是一个包含在 Git 软件包中的特殊守护进程。</p>
<p>打算支持 Git 协议的仓库，需要先创建 <code>git-daemon-export-ok</code> 文件 — 它是协议进程提供仓库服务的必要条件 — 但除此之外该服务没有什么安全措施。</p>
<p>要么所有人都能克隆 Git 仓库，要么谁也不能。</p>
<p>Git协议是最快的<strong>传输协议</strong>，对一个不需要对读操作进行授权的项目来说，架设Git协议是一个不错的选择。</p>
<p>Git 协议消极的一面是缺少授权机制。用 Git 协议作为访问项目的唯一方法通常是不可取的。一般的做法是，同时提供 SSH 接口，让几个开发者拥有推送（写）权限，其他人通过 <code>git://</code> 拥有只读权限。 Git 协议可能也是最难架设的协议。它要求有单独的守护进程，需要定制 — 我们将在本章的 “Gitosis” 一节详细介绍它的架设 — 需要设定 <code>xinetd</code> 或类似的程序，而这些工作就没那么轻松了。该协议还要求防火墙开放 9418 端口，而企业级防火墙一般不允许对这个非标准端口的访问。大型企业级防火墙通常会封锁这个少见的端口。</p>
<h2 id="1-4-HTTP-S协议"><a href="#1-4-HTTP-S协议" class="headerlink" title="1.4 HTTP/S协议"></a>1.4 HTTP/S协议</h2><p>HTTP或者HTTPS协议具有非常高的<strong>简洁性</strong>。</p>
<p>我们把Git的裸仓库文件放在http的根目录下，配置一个特定的 <code>post-update</code>挂钩就可以实现</p>
<ol>
<li>配置 <code>post-update</code>挂钩</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd .git</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mv hooks/post-update.sample hooks/post-update</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ chmod a+x hooks/post-update</span><br></pre></td></tr></table></figure>
<p><code>mv</code>命令是把source文件改名为 dest，即<code>post-update.sample</code>改为<code>post-update</code></p>
<p><code>chmod a+x</code>是指all所有人都可以x执行excu 这个<code>post-update</code></p>
<p>在你向仓库推送的时候，<code>post-update</code>会执行：    <code>git update-server-info</code>来确保通过 HTTP 的获取和克隆正常工作。</p>
<p>之后我们便可以通过HTTP来克隆仓库了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone http://example.com/gitproject.git</span><br></pre></td></tr></table></figure>
<p>通过 HTTP 进行推送操作也是可能的，不过这种做法不太常见，并且牵扯到复杂的 WebDAV 设定。</p>
<h1 id="2-服务器上部署Git"><a href="#2-服务器上部署Git" class="headerlink" title="2. 服务器上部署Git"></a>2. 服务器上部署Git</h1><p>首先把现有仓库导出为<strong>裸仓库</strong>，即一个不含当前工作目录的仓库：</p>
<p>使用 <code>--bare</code> ，裸仓库的目录名以 <code>.git</code>结尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone --bare Git-test Git-test.git</span><br><span class="line">Cloning into bare repository &#x27;Git-test.git&#x27;...</span><br><span class="line">done.</span><br></pre></td></tr></table></figure>
<p><code>clone</code>其实就是 相当于 <code>git init</code> 和<code>git fetch</code></p>
<p>先由它建立一个空目录，而之后传输数据对象的操作并无任何输出，只是悄悄在幕后执行。</p>
<p><strong>它仅取出 Git 仓库的必要原始数据，存放在该目录中，而不会另外创建工作目录。</strong></p>
<p>有了裸仓库的副本后，剩下的就是把它放到服务器上并设定相关协议。假设一个域名为 <code>git.example.com</code> 的服务器已经架设好，并可以通过 SSH 访问，我们打算把所有 Git 仓库储存在 <code>/opt/git</code> 目录下。只要把裸仓库复制过去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ scp -r my_project.git user@git.example.com:/opt/git</span><br></pre></td></tr></table></figure>
<p>现在，所有对该服务器有 SSH 访问权限，并可读取 <code>/opt/git</code> 目录的用户都可以用下面的命令克隆该项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone user@git.example.com:/opt/git/my_project.git</span><br></pre></td></tr></table></figure>
<p>如果某个 SSH 用户对 <code>/opt/git/my_project.git</code> 目录有写权限，那他就有推送权限。如果到该项目目录中运行 <code>git init</code> 命令，并加上 <code>--shared</code> 选项，那么 Git 会自动修改该仓库目录的组权限为可写（译注：实际上 <code>--shared</code> 可以指定其他行为，只是默认为将组权限改为可写并执行 <code>g+sx</code>，所以最后会得到 <code>rws</code>。）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh user@git.example.com</span><br><span class="line">$ cd /opt/git/my_project.git</span><br><span class="line">$ git init --bare --shared</span><br></pre></td></tr></table></figure>
<p>由此可见，根据现有的 Git 仓库创建一个裸仓库，然后把它放上你和同事都有 SSH 访问权的服务器是多么容易。现在已经可以开始在同一项目上密切合作了。</p>
<p>值得注意的是，这的的确确是架设一个少数人具有连接权的 Git 服务的全部 — 只要在服务器上加入可以用 SSH 登录的帐号，然后把裸仓库放在大家都有读写权限的地方。一切都准备停当，无需更多。</p>
<p>下面的几节中，你会了解如何扩展到更复杂的设定。这些内容包含如何避免为每一个用户建立一个账户，给仓库添加公共读取权限，架设网页界面，使用 Gitosis 工具等等。然而，只是和几个人在一个不公开的项目上合作的话，仅仅是一个 SSH 服务器和裸仓库就足够了，记住这点就可以了。</p>
<h1 id="3-SSH公钥的创建"><a href="#3-SSH公钥的创建" class="headerlink" title="3. SSH公钥的创建"></a>3. SSH公钥的创建</h1><p>查看是否有SSH公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">id_rsa  id_rsa.pub  known_hosts  known_hosts.old</span><br></pre></td></tr></table></figure>
<p>有 <code>.pub</code> 后缀的文件就是公钥，另一个文件则是密钥。</p>
<p>如果没有，则使用下面的命令来创建 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /Users/schacon/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local</span><br></pre></td></tr></table></figure>
<p>它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。</p>
<p>现在，所有做过这一步的用户都得把它们的公钥给你或者 Git 服务器的管理员（假设 SSH 服务被设定为使用公钥机制）。他们只需要复制 <code>.pub</code> 文件的内容然后发邮件给管理员。</p>
]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习（3）- Git分支的操作管理与工作流程</title>
    <url>/2023/03/04/git%E5%AD%A6%E4%B9%A0-3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章首发于：<a href="https://helloylh.com">My Blog</a>  欢迎大佬们前来逛逛</p>
<h1 id="1-Git分支的概念"><a href="#1-Git分支的概念" class="headerlink" title="1. Git分支的概念"></a>1. Git分支的概念</h1><p>在Git提交的时候，会保存一个<strong>指向文件快照的指针</strong>，包含本次提交的作者等相关信息。</p>
<p>同时也包含多个指向文件内容快照的父指针。</p>
<p>我们首先创建三个文件，然后执行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;my first project&#x27;</span><br></pre></td></tr></table></figure>
<p>暂存操作会对每一个文件计算<strong>校验和</strong>（即第一章中提到的 SHA-1 哈希字串），然后把当前版本的<strong>文件快照保存到 Git 仓库中</strong>（Git 使用 blob 类型的对象存储这些快照）</p>
<p>此时Git仓库中的五个对象:</p>
<ol>
<li>三个 blob 类型的对象</li>
<li>一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象；</li>
<li>以及一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 <strong>commit 对象</strong>。</li>
</ol>
<p><strong>Git 的分支 本质上就是指向一个commit对象的可变指针</strong></p>
<p>Git使用master作为分支的<strong>默认名字</strong>，并且<strong>master始终指向你最后一次提交的对象</strong>，他会自己更新</p>
<hr>
<p>使用Git创建一个新的分支：叫做testing</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch testing</span><br></pre></td></tr></table></figure>
<p><strong>则testing 会和 master一样，一起指向 最后一次提交的commit对象，testing 不会覆盖 master</strong></p>
<p>Git如何知道你在哪个分支上工作的呢？</p>
<ul>
<li>Git有一个HEAD指针：<strong>指向你正在工作中的本地分支的指针</strong></li>
</ul>
<p>运行<code>git branch</code> 之后我们仅仅是创建了一个分支，但是<strong>实际工作分支仍然是默认的master，即我们的HEAD指针指向master</strong>，<strong>我们可以使用下面的命令切换分支</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout testing</span><br></pre></td></tr></table></figure>
<p><strong>这样我们的HEAD指针就指向了 testing分支</strong></p>
<hr>
<p>此时我们<strong>再次提交</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;second pro&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>此时我们的工作分支testing 和HEAD指针会指向我们最新的这次提交，而master分支指向的是之前的提交。</strong></p>
<p>即我们的每次提交只会改变当前工作分支与 HEAD指针，其他分支保存的仍是之前的历史版本</p>
<p>如果此时我们输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<p>则我们现在的工作目录是master分支，HEAD指针也指向master。</p>
<p><strong>这就是实现了在历史版本中切换的目的！也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</strong></p>
<hr>
<p>此时我们在master分支中进行提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;three pro&#x27;</span><br></pre></td></tr></table></figure>
<p>就会产生如下效果：</p>
<p>我们的这次提交 与 上一次的 second pro 处于同一层中，即在树结构中他们的父节点都是之前master和HEAD所在的位置，即之前的节点拥有了两个父节点</p>
<blockquote>
<p>由于 Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。</p>
</blockquote>
<p><strong>Git 在每次提交时都记录了祖先信息</strong></p>
<h1 id="2-分支的新建与合并"><a href="#2-分支的新建与合并" class="headerlink" title="2. 分支的新建与合并"></a>2. 分支的新建与合并</h1><h2 id="2-1-新建与切换分支"><a href="#2-1-新建与切换分支" class="headerlink" title="2.1 新建与切换分支"></a>2.1 新建与切换分支</h2><p>首先我们已经有了几次的提交信息</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/6xm60on.png" alt=""></p>
<p><strong>现在我们接到了一个需求：我们需要实现一个新的功能，则我们需要创建一个新的分支</strong></p>
<p>新建一个分支并且切换到该分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b iss53</span><br></pre></td></tr></table></figure>
<p>相当于执行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch iss53</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout iss53</span><br></pre></td></tr></table></figure>
<p><strong>相当于 master 和 iss53 两个指针同时指向了最新的一次提交，并且当前HEAD指针指向 iss53 分支</strong></p>
<p><img src="https://tudingtu.cn/i/2023/03/04/ozoq8b.png" alt=""></p>
<p>然后我们开始实现这个功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim xxxx</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;new question&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>此时我们正在完成 iss53 分支的功能扩展</strong>，则此时分支如下所示：</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/p0yxd5.png" alt=""></p>
<hr>
<p>此时我们突然接到了一个紧急电话（<strong>注意：iss53 功能并没有完成，但是这个严重错误的优先级非常高</strong>）！！！ 我们的原来的<strong>某个分支版本上出现了一个严重错误，需要紧急修改</strong></p>
<p>假设其在master分支上（当前仍在iss53分支）则我们需要切换到 master 分支上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<p><strong>然后我们需要创建一个分支来解决这个严重错误。</strong>我们新建并切换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b hotfix</span><br></pre></td></tr></table></figure>
<p>然后我们解决这个严重错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim xxx</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add xxx</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;solve error&#x27;</span><br></pre></td></tr></table></figure>
<p>我们便解决了这个问题，并且提交了，此时的分支如下所示：</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/p3y6g6.png" alt=""></p>
<p>注意：此时我们HEAD工作目录指向的是 hotfix（即解决了这个重大错误的分支）</p>
<p>我们需要合并到原始的master分支中：</p>
<p>要合并我们需要首先回到master中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<h2 id="2-2-合并分支"><a href="#2-2-合并分支" class="headerlink" title="2.2 合并分支"></a>2.2 合并分支</h2><p>关于<strong>合并</strong>我们使用<code>git merge</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge hotfix</span><br></pre></td></tr></table></figure>
<p>注意：此时我们执行的是 <strong>Fast—forword合并</strong>，即<strong>如果分支的直接父节点是原来的需要合并到的版本，则会直接把master移动到hotfix分支上</strong></p>
<p>如下图所示：</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/p6efhh.png" alt=""></p>
<h2 id="2-3-删除分支"><a href="#2-3-删除分支" class="headerlink" title="2.3 删除分支"></a>2.3 删除分支</h2><p>既然我们已经解决了 这个严重错误，并且我们也完成合并了，那<strong>么这个 hotfix显然没用了，直接删除这个分支即可：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d hotfix</span><br></pre></td></tr></table></figure>
<p>则我们继续回到 iss53 来完成这一功能（<strong>之前说了，iss53并没有完成，只是 hotfix的优先级高</strong>）</p>
<p>则切换分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout iss53</span><br></pre></td></tr></table></figure>
<p>经过一顿操作后，我们终于完成 iss53 的功能扩展，并且提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ...</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;终于完成！&#x27;</span><br></pre></td></tr></table></figure>
<p>则此时分支图如下所示：</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/p9esz9.png" alt=""></p>
<p><strong>则最终我们再把这个 扩展 功能与我们的master进行合并：</strong></p>
<p>首先切换到master</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge iss53</span><br></pre></td></tr></table></figure>
<p>合并后，分支图如下所示：</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/payozr.png" alt=""></p>
<p>注意我们的此次合并不同于刚才的严重错误 的合并，刚才<strong>master是 解决严重父亲的直接父节点，因此合并就是父节点移动到孩子节点。</strong></p>
<p><strong>但是此次合并的是同一祖先节点的不同兄弟节点，因此我们 采用两个分支与它们的最近公共祖先 三者一起进行合并</strong>，最终合并为 C6，并且master指向它。然后删除 iss53 分支即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d iss53</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-管理分支"><a href="#3-管理分支" class="headerlink" title="3. 管理分支"></a>3. 管理分支</h1><ol>
<li>列出当前所有分支：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch </span><br></pre></td></tr></table></figure>
<p>其中带星号的表示的是当前<strong>工作分支</strong></p>
<ol>
<li>查看各个分支的<strong>最后一个提交对象的信息</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure>
<p>显示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &#x27;iss53&#x27;</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure>
<ol>
<li>显示<strong>已经与当前分支合并</strong>的分支：<strong>也就是说哪些分支是当前分支的直接上游。</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch --merged</span><br></pre></td></tr></table></figure>
<p>​    未合并的分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果我们把已经与当前分支合并的分支，如 iss53（功能如上节所示），则 在<code>--merge</code> 时会显示，则我们可以轻松的删除它： <code>git branch -d</code></p>
</li>
<li><p>如果我们的 <code>--no-merged</code> 时有任何分支，如testing，则我们<strong>无法删除它</strong>。</p>
<ul>
<li><strong>因为 Git 判断 iss53已经与master合并了，则master 已经包含了iss53的所有功能，则删除也无妨；testing尚未与 master合并，如果贸然删除可能会丢失数据，因此 Git 在删除 testing 此时会报错。</strong></li>
<li>强制删除： <code>-D</code></li>
</ul>
</li>
</ul>
<h1 id="4-分支开发的工作流程"><a href="#4-分支开发的工作流程" class="headerlink" title="4. 分支开发的工作流程"></a>4. 分支开发的工作流程</h1><h2 id="4-1-长期分支"><a href="#4-1-长期分支" class="headerlink" title="4.1 长期分支"></a>4.1 长期分支</h2><p>即把master分支 放在一个<strong>比较稳定的即将发布的版本中</strong>，然后如果添加什么功能，则直接创建新的分支，这些新的分支是master的<strong>平行分支</strong>，即是master分支的平行的孩子们。</p>
<p>如果要合并分支，则可以随时 把这些功能分支合并到 master 分支中，<strong>即master指向的对象直接指向当前 这个功能的分支上，类似于上面的 解决重大错误的 分支的合并的合并策略。</strong></p>
<p>如下图所示：</p>
<p><img src="https://great.wzznft.com/i/2023/03/04/qik47c.png" alt=""></p>
<p>你可以用这招<strong>维护不同层次的稳定性</strong>。</p>
<blockquote>
<p>某些大项目还会有个 <code>proposed</code>（建议）或 <code>pu</code>（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入 <code>next</code> 或 <code>master</code> 的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。再次说明下，使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。</p>
</blockquote>
<h2 id="4-2-特性分支"><a href="#4-2-特性分支" class="headerlink" title="4.2 特性分支"></a>4.2 特性分支</h2><p>一个特性分支是指<strong>一个短期的，用来实现单一特性或与其相关工作的分支</strong>。</p>
<p>在Git 中创建分支是非常轻松的，因此特性分支使用非常普遍</p>
<p><strong>特性分支的流程：</strong></p>
<ol>
<li>工作目录在<code>master</code>中，干到C1的时候，突然出现了一个问题，则转到<code>iss91</code>解决这个问题</li>
<li>在 <code>iss91</code> 中 干到C6的时候，发现 貌似有更好的办法 <code>iss91v2</code> 可以解决这个问题，则在合适的位置 C4进行另一个方法分支的解决</li>
<li>做到 C8的时候，突然没思路了，则先写会的，即先把<code>master</code>中其他的完成，转移到<code>master</code>完成到 C10之后， <code>iss91v2</code> 突然有思路了，则继续回到完成C11，之后提交 <code>iss91v2</code></li>
<li>但是此时又冒出个奇妙的想法，因此 <code>dumbidea</code>在master中测试一下，做个实验。</li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/04/7duaea2.png" alt=""></p>
<p>最后我们便得到了合并后的分支：</p>
<ol>
<li><code>dumabidea</code> 它出色的完成了功能，可以作为master的下一个版本</li>
<li>使用<code>iss91v2</code>然后抛弃了<code>iss91</code>版本</li>
<li>最后两个分支合。</li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/04/qpnjzg.png" alt=""></p>
<h1 id="5-远程分支"><a href="#5-远程分支" class="headerlink" title="5. 远程分支"></a>5. 远程分支</h1><p>如果你有一个本地分支 需要和别人分享， <code>git push (远程仓库名) (分支名)</code> 来推送到远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>Git 自动把 <code>master</code> 分支名扩展为 <code>refs/heads/master:refs/heads/master</code></p>
<p><strong>即取出我在本地的master分支，推送到远程仓库的master分支上去。</strong></p>
<p>运行下面实现相同的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master:master</span><br></pre></td></tr></table></figure>
<p><strong>你可以把本地分支推送到某个命名不同的远程分支</strong>：</p>
<p>若想把远程分支叫作 <code>ylh</code>，可以用 <code>git push origin master:ylh</code> 来推送数据。</p>
<p>其他人想要再次从服务器上获取数据时，他们将得到一个新的远程分支 <code>origin/master</code>，并指向服务器上 <code>master</code> 所指向的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch master</span><br></pre></td></tr></table></figure>
<p><strong>如果要把该远程分支的内容合并到当前分支</strong>，可以运行 <code>git merge origin/master</code>。如果想要一份自己的 <code>master</code> 来开发，<strong>可以在远程分支的基础上分化出一个新的分支来：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b master2 origin/master</span><br></pre></td></tr></table></figure>
<p>这会切换到新建的 <code>master2</code> 本地分支，其内容同远程分支 <code>origin/master</code> 一致，这样你就可以在里面继续开发了。</p>
<p><strong>删除远程分支</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin :master</span><br></pre></td></tr></table></figure>
<p>记住我们不久前见过的 <code>git push [远程名] [本地分支]:[远程分支]</code> 语法，如果省略 <code>[本地分支]</code>，那就等于是在说“在这里提取空白然后把它变成<code>[远程分支]</code>”。</p>
<h1 id="6-分支衍和"><a href="#6-分支衍和" class="headerlink" title="6. 分支衍和"></a>6. 分支衍和</h1><p>一个分支中的修改整合到另一个分支中有两种方法：</p>
<ol>
<li>merge：合并</li>
<li>rebase：衍和</li>
</ol>
<p><strong>最容易的整合方式： merge命令。</strong></p>
<hr>
<p>什么是<strong>衍和</strong>？</p>
<p>在<code>merge</code> 的时候，我们会把<strong>两个对象快照和他们的最近公共最先 三者进行一次合并</strong>。</p>
<p>而现在我们可以把<strong>其中一个对象快照里的变化在另一个对象中重新再打一遍</strong>。在 Git 里，这种操作叫做<em>衍合（rebase）</em>。有了 <code>rebase</code> 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。</p>
<ol>
<li>首先<strong>在C3的exp</strong>中执行下面的命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure>
<p>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 <code>experiment</code>）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 <code>master</code>）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 <code>experiment</code> 的提交历史，使它成为 <code>master</code> 分支的直接下游，如图 3-29 所示：</p>
<p><strong>总结：C3的exp 现在 衍和到了 C3’ 的位置</strong></p>
<p><img src="https://great.wzznft.com/i/2023/03/04/svqd3m.png" alt=""></p>
<ol>
<li>然后再执行一次 <strong>平行合并</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge exp</span><br></pre></td></tr></table></figure>
<p>就形成了如下的分支图：</p>
<p><img src="https://tudingtu.cn/i/2023/03/04/sxhqzq.png" alt=""></p>
<p>虽然最后与 <code>merge</code>整合得到的结果没有任何区别，但衍合能产生一个<strong>更为整洁</strong>的提交历史。</p>
<hr>
<p><strong>衍和的复杂版本：</strong></p>
<p>把<code>server</code>的分支包含进来，在<code>master</code>上进行一次衍和操作：<code>git rebase [主分支] [特性分支]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase master server</span><br></pre></td></tr></table></figure>
<p>使用 <code>--onto</code>：取出client分支，找出client与server的最近<strong>公共祖先</strong>，然后此LCA在 <code>master</code>上做一次<strong>衍和操作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase --onto master server client</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。</strong></p>
]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习（2） - 基本命令操作总结</title>
    <url>/2023/03/03/git%E5%AD%A6%E4%B9%A0-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-创建-git仓库"><a href="#1-创建-git仓库" class="headerlink" title="1 创建 git仓库"></a>1 创建 git仓库</h1><h2 id="1-1-从现有工作目录中初始化新仓库"><a href="#1-1-从现有工作目录中初始化新仓库" class="headerlink" title="1.1 从现有工作目录中初始化新仓库"></a>1.1 从现有工作目录中初始化新仓库</h2><p>需要到你需要用git管理的项目中输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>便会创建一个空的git项目，<strong>并且当前目录下会出现一个名为 .git 的目录</strong>， Git 需要的数据和资源都存放在这个目录中，不过我们目前只是初始化所有的文件与目录</p>
<ol>
<li>告诉 git在这个目录中有几个文件需要版本控制。我使用了几个cpp的文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add *.cpp</span><br></pre></td></tr></table></figure>
<p>还可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;initial project version&#x27;</span><br></pre></td></tr></table></figure>
<p>你已经得到了一个实际维护着若干文件的 Git 仓库。</p>
<h2 id="1-2-从现有仓库克隆"><a href="#1-2-从现有仓库克隆" class="headerlink" title="1.2 从现有仓库克隆"></a>1.2 从现有仓库克隆</h2><p>克隆某个开源项目的git仓库，可以使用 git clone 命令</p>
<p>例如克隆一份Ruby语言的 Git 代码仓库 ticgit可以使用下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:schacon/ticgit.git</span><br></pre></td></tr></table></figure>
<p>这表示在当前文件夹下新建一个ticgit，其中包含一个  .git 的文件夹，<strong>用于保存下载下来的所有版本记录</strong>，然后从中取出最新版本的文件拷贝。</p>
<p><strong>修改克隆的名字</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:schacon/ticgit.git myticgit</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://great.wzznft.com/i/2023/03/03/w5knrj.png" alt=""></p>
<p>在克隆的时候，我们可以选择不同的<strong>数据传输协议</strong>，在我们的例子中选择的是 <strong>ssh传输协议</strong>，你还可以有<code>https://</code>开头或者<code>user@server:/path.git</code>传输协议</p>
<p><img src="https://tudingtu.cn/i/2023/03/03/w69pwj.png" alt=""></p>
<h1 id="2-记录仓库更新"><a href="#2-记录仓库更新" class="headerlink" title="2. 记录仓库更新"></a>2. 记录仓库更新</h1><p>当我们创建了git存储库后，我们便可以在<strong>工作目录</strong>对这写文件进行更新。</p>
<p>在工作目录中的文件无非有两种状态：</p>
<ol>
<li>已跟踪：已跟踪的文件是指本来就被纳入版本控制管理的文件，<strong>在上次快照中有它们的记录</strong>，工作一段时间后，它们的状态可能是<strong>未更新，已修改或者已放入暂存区</strong>。<strong>在克隆获取库后，工作目录的所有文件都是已跟踪的。</strong></li>
<li>未跟踪：其他所有的文件都是未跟踪的，即他们既没有快照，也没有放入暂存区。在修改后 git才会把他们表示为已修改的，然后放到暂存区准备提交更新。</li>
</ol>
<h2 id="2-1-查看跟踪状态"><a href="#2-1-查看跟踪状态" class="headerlink" title="2.1 查看跟踪状态"></a>2.1 查看跟踪状态</h2><p>输入下面的命令来查看当前工作目录的文件<strong>处于什么状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>出现的情况：</p>
<ol>
<li>当前工作目录很干净，所有<strong>已跟踪</strong>文件在上次提交后都未被更改过。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<ol>
<li>现在让我们修改一下，比如添加一个文件（<strong>注意：需要在git克隆的仓库内执行</strong>）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim README</span><br></pre></td></tr></table></figure>
<p>然后随便输入一些内容保存退出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>会出现：<strong>Untracked files ，即未跟踪状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>
<p><strong>表示我们的README 处于Untracked files即未跟踪状态</strong></p>
<blockquote>
<p>未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，因而不用担心把临时文件什么的也归入版本管理。</p>
</blockquote>
<h2 id="2-2-跟踪新文件"><a href="#2-2-跟踪新文件" class="headerlink" title="2.2 跟踪新文件"></a>2.2 跟踪新文件</h2><p>跟踪我们上面新建的 README文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure>
<p>当我们再次 <code>git status</code>，会发现它处于：</p>
<p><strong>Changes to be committed，即未提交状态，它这时已经被跟踪了，但是没有提交。</strong>即处于<code>暂存状态</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   README</span><br></pre></td></tr></table></figure>
<p>其实 <code>git add</code> 的作用就是<strong>将一个文件放入暂存区域中，并且把所有未跟踪的文件或者目录变为已跟踪状态。</strong></p>
<blockquote>
<p>这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等</p>
</blockquote>
<h2 id="2-3-暂存已修改的文件"><a href="#2-3-暂存已修改的文件" class="headerlink" title="2.3 暂存已修改的文件"></a>2.3 暂存已修改的文件</h2><p>我们修改一个<strong>已经存在于历史版本的文件</strong>：README.mkd</p>
<p>忽略上面的内容，我们会看到这样的状态：<strong>Changes not staged for commit</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   README.mkd</span><br></pre></td></tr></table></figure>
<p> 表示已经跟踪的文件发生了修改，但是还没有放在暂存区里。</p>
<p>要暂存这次更新，则需要执行<code>git add</code>（看上节关于git add的讲解）命令。</p>
<p>现在我们运行此命令把 README.mkd放到<strong>暂存区</strong>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add README.mkd</span><br></pre></td></tr></table></figure>
<p>再次status其状态得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   README</span><br><span class="line">        modified:   README.mkd</span><br></pre></td></tr></table></figure>
<p>两个文件都被放在<strong>暂存区</strong>了，提交后便会被更新到仓库中</p>
<hr>
<p>注意：如果此时你又想<strong>修改一个已经被放在暂存区的文件</strong>，则修改后会发现，出现了两个相同的文件，<strong>一个已跟踪并且放在暂存区，而另一个已跟踪未在暂存区。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   README</span><br><span class="line">        modified:   README.mkd</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   README.mkd</span><br></pre></td></tr></table></figure>
<p>这是因为 git只会暂存 执行<code>git add</code>后的文件，因此此时需要重新 输入此命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add README.mkd</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   README</span><br><span class="line">        modified:   README.mkd</span><br></pre></td></tr></table></figure>
<h2 id="2-4-忽略某些文件"><a href="#2-4-忽略某些文件" class="headerlink" title="2.4 忽略某些文件"></a>2.4 忽略某些文件</h2><p>我们不想让某些文件被纳入git的管理，即他们<strong>根本不用出现在未跟踪状态下</strong></p>
<p>我们创建或者修改一下 .gitignore 文件即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim .gitignore</span><br></pre></td></tr></table></figure>
<p>修改后，查看文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.gem</span><br><span class="line">*.swp</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br><span class="line">*.log</span><br><span class="line">*.tmp</span><br><span class="line">*.pid</span><br><span class="line">rdoc/</span><br><span class="line">pkg/</span><br></pre></td></tr></table></figure>
<ol>
<li><code>*.gem</code> <code>*.swp</code> <code>*.[oa]</code> 表示我们要忽略以 gem  swp  o a 等后缀的文件</li>
<li><code>~</code> 表示 一些文件的副本，或者其他文件</li>
<li><code>rdoc/</code> 表示的是一个 <strong>文件夹</strong>，因为它的末尾是  /</li>
</ol>
<p>要养成一开始就设置好 <code>.gitignore</code> 文件的习惯，以免将来误提交这类无用的文件。（可以对一些模式<strong>取反</strong>，表示的就是忽略他们之外的文件或者目录）</p>
<h2 id="2-5-查看已暂存或者未暂存的更新"><a href="#2-5-查看已暂存或者未暂存的更新" class="headerlink" title="2.5 查看已暂存或者未暂存的更新"></a>2.5 查看已暂存或者未暂存的更新</h2><p>查看<strong>具体修改了什么地方</strong>，可以使用下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<p>运行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/README b/README</span><br><span class="line">index e31a6eb..0a7d6e9 100644</span><br><span class="line">--- a/README</span><br><span class="line">+++ b/README</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> 你好!6</span><br><span class="line"> 6666</span><br><span class="line"> hjhhhh</span><br><span class="line">+我修改了一行</span><br></pre></td></tr></table></figure>
<p>前面的 + 号表示我们<strong>添改</strong>了这一行的内容，- 号则表示我们<strong>删改</strong>了一行信息</p>
<p><strong>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改了之后还没有暂存起来的变化</strong></p>
<hr>
<p>查看已经暂存的文件与上次提交的文件的差异：</p>
<p>首先把README先 放入暂存区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add README</span><br></pre></td></tr></table></figure>
<p>运行如下命令：即可查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure>
<p>简单总结：</p>
<ol>
<li><code>git diff</code>：查看某个文件还<strong>没有被暂存起来的改动</strong>，其实就是显示你当前修改了什么内容，与在暂存区的内容做比较。<strong>暂存前后的变化</strong></li>
<li><code>git diff --cached</code>：查看某个文件<strong>已经被暂存和上一次提交时的文件的内容差异</strong>。<strong>已经暂存的变化</strong></li>
</ol>
<h2 id="2-6-提交更新"><a href="#2-6-提交更新" class="headerlink" title="2.6 提交更新"></a>2.6 提交更新</h2><p>首先检查有没有修改了但是没有被暂存的，因为<strong>提交只会提交暂存区的</strong></p>
<p>检查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add xxx # 如果还存在未暂存的目标</span><br></pre></td></tr></table></figure>
<p>检查完成后，输入<strong>提交命令：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>
<p><strong>这时就会出现一个文本编辑器，并且输入本次提交的说明</strong></p>
<p>我的出现了 vscode，可以按照下列的命令进行修改默认哪个编辑器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.editor xxxxx</span><br></pre></td></tr></table></figure>
<p>默认的提交信息包括最后一次<code>git status</code>显示的信息</p>
<blockquote>
<p>如果觉得这还不够，可以用 <code>-v</code> 选项将修改差异的每一行都包含到注释中来。</p>
</blockquote>
<p>退出编辑器时，Git 会丢掉注释行，<strong>将说明内容和本次更新提交到仓库。</strong></p>
<p>在空行输入提交信息：保存后退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">learning git use  </span><br></pre></td></tr></table></figure>
<p>接着就会提示你提交成功！并且显示当前是在哪个分支（master）提交的，本次提交的完整 <strong>SHA-1 校验和</strong>是什么（<code>582f005</code>），以及在本次提交中，有<strong>多少文件修订过</strong>，<strong>多少行添改和删改过</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[master 582f005] learning git use</span><br><span class="line"> 3 files changed, 10 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
</blockquote>
<p>使用 <code>-m</code> 快速添加提交信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m 我要学习</span><br><span class="line"> </span><br><span class="line">[master f949baa] 我要学习</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>
<h2 id="2-7-跳过暂存"><a href="#2-7-跳过暂存" class="headerlink" title="2.7 跳过暂存"></a>2.7 跳过暂存</h2><p>使用下面的命令可以将修改的文件无需放入暂存区，即无需使用<code>git add</code>的命令，可以<strong>直接 提交</strong>。</p>
<p>修改了一个文件之后，执行下面的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure>
<p>即在commit的时候添加一个  <code>-a</code>  2.</p>
<p>实现快速修改提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a -m 跳过暂存</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[master 042500c] 跳过暂存</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>
<h2 id="2-8-移除文件"><a href="#2-8-移除文件" class="headerlink" title="2.8 移除文件"></a>2.8 移除文件</h2><p>从 Git 中移除某个不想要的文件，即从<strong>已经暂存的区域移除某个文件</strong>。</p>
<p><strong>输入以下命令，来删除暂存区的文件，并且直接把它从工作目录中删除，连未跟踪区域都别留下。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm xxx</span><br></pre></td></tr></table></figure>
<p>相当于直接删除这个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        deleted:    README</span><br></pre></td></tr></table></figure>
<p>如果要删除一个<strong>已经放在暂存区</strong>的文件，则必须<strong>强制删除</strong>，输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm -f xxx </span><br></pre></td></tr></table></figure>
<p>只从暂存区删除，<strong>即删除跟踪，但是不删除其本身</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm --cached xxx</span><br></pre></td></tr></table></figure>
<p>此命令删除所有 <code>log/</code> 目录下扩展名为 <code>.log</code> 的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm log/\*.log</span><br></pre></td></tr></table></figure>
<p>删除当前目录及其子目录中所有 <code>~</code> 结尾的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm \*~</span><br></pre></td></tr></table></figure>
<h2 id="2-9-移动文件"><a href="#2-9-移动文件" class="headerlink" title="2.9 移动文件"></a>2.9 移动文件</h2><p>我们想要把一个文件README.txt 改为 README ，可以使用下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv README.txt README </span><br></pre></td></tr></table></figure>
<p><code>mv</code> 表示 把文件从README.txt 改为 README</p>
<p>实际上执行了三条语句是等价的：<strong>注意README.txt一定是在暂存区域内</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv README.txt README</span><br><span class="line">git rm README.txt</span><br><span class="line">git add README</span><br></pre></td></tr></table></figure>
<ol>
<li>mv命令把README.txt 改为 README，但是此时<strong>README.txt仍在暂存区</strong>，并且<strong>README在未暂存区</strong></li>
<li><strong>删除暂存区的README.txt</strong></li>
<li><strong>把README放入暂存区</strong></li>
</ol>
<p>实际上 <code>git mv file_from file_to</code> 便可以表示这一过程，无需写三条</p>
<h1 id="3-查看提交历史"><a href="#3-查看提交历史" class="headerlink" title="3. 查看提交历史"></a>3. 查看提交历史</h1><p>演示: 首先运行命令获取项目库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/schacon/simplegit-progit.git</span><br></pre></td></tr></table></figure>
<p>在此项目中运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>会出现以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>
<p><code>git log</code> 会按<strong>提交时间</strong>列出所有的更新，<strong>最近的更新排在最上面</strong></p>
<p>每次更新都有一个 SHA-1 校验和，作者姓名电子邮箱，提交时间与<strong>提交说明</strong></p>
<hr>
<p>使用 <code>-p</code> 显示每次提交的内容差异 <code>-2</code>只显示最近两次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -p -2</span><br></pre></td></tr></table></figure>
<hr>
<p>使用<code>--word-diff</code>获取<strong>单词层面</strong>的变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -p --word-diff</span><br></pre></td></tr></table></figure>
<hr>
<p>使用<code>-stat</code> 显示简要的<strong>增改行数统计</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure>
<p>每个提交都列出了修改过的文件，以及其中添加和移除的行数，并在最后列出所有增减行数小计。</p>
<hr>
<p><code>--pretty</code> 可以指定使用完全不同于默认格式的方式展示提交历史</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --pretty=xxx</span><br></pre></td></tr></table></figure>
<p>xxx可以为：oneline，short，full，fuller</p>
<p><code>format</code> 定制显示的格式，相当于debug</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选项	 说明</span><br><span class="line">%H	提交对象（commit）的完整哈希字串</span><br><span class="line">%h	提交对象的简短哈希字串</span><br><span class="line">%T	树对象（tree）的完整哈希字串</span><br><span class="line">%t	树对象的简短哈希字串</span><br><span class="line">%P	父对象（parent）的完整哈希字串</span><br><span class="line">%p	父对象的简短哈希字串</span><br><span class="line">%an	作者（author）的名字</span><br><span class="line">%ae	作者的电子邮件地址</span><br><span class="line">%ad	作者修订日期（可以用 -date= 选项定制格式）</span><br><span class="line">%ar	作者修订日期，按多久以前的方式显示</span><br><span class="line">%cn	提交者(committer)的名字</span><br><span class="line">%ce	提交者的电子邮件地址</span><br><span class="line">%cd	提交日期</span><br><span class="line">%cr	提交日期，按多久以前的方式显示</span><br><span class="line">%s	提交说明</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><code>log</code> 的后面参数的其他选择</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选项	说明</span><br><span class="line">-p	按补丁格式显示每个更新之间的差异。</span><br><span class="line">--word-diff	按 word diff 格式显示差异。</span><br><span class="line">--stat	显示每次更新的文件修改统计信息。</span><br><span class="line">--shortstat	只显示 --stat 中最后的行数修改添加移除统计。</span><br><span class="line">--name-only	仅在提交信息后显示已修改的文件清单。</span><br><span class="line">--name-status	显示新增、修改、删除的文件清单。</span><br><span class="line">--abbrev-commit	仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</span><br><span class="line">--relative-date	使用较短的相对时间显示（比如，“2 weeks ago”）。</span><br><span class="line">--graph	显示 ASCII 图形表示的分支合并历史。</span><br><span class="line">--pretty	使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</span><br><span class="line">--oneline	`--pretty=oneline --abbrev-commit` 的简化用法</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><code>--since 和 --until</code> 对<strong>时间作出限制</strong></p>
<p>显示最近两周的提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --since=2.weeks</span><br></pre></td></tr></table></figure>
<p>其他选择:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选项	说明</span><br><span class="line">-(n)	仅显示最近的 n 条提交</span><br><span class="line">--since, --after	仅显示指定时间之后的提交。</span><br><span class="line">--until, --before	仅显示指定时间之前的提交。</span><br><span class="line">--author	仅显示指定作者相关的提交。</span><br><span class="line">--committer	仅显示指定提交者相关的提交。</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="4-撤销操作"><a href="#4-撤销操作" class="headerlink" title="4. 撤销操作"></a>4. 撤销操作</h1><h2 id="4-1-修改最后一次操作"><a href="#4-1-修改最后一次操作" class="headerlink" title="4.1 修改最后一次操作"></a>4.1 修改最后一次操作</h2><p>如果在提交后，发现提交信息写错了，或者漏掉几个文件没有加，则可以这样修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<hr>
<p>如果还没有暂存文件就提交了，则可以这样操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit # 提交了</span><br><span class="line">git add file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<p>上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p>
<h2 id="4-2-取消暂存中的文件"><a href="#4-2-取消暂存中的文件" class="headerlink" title="4.2 取消暂存中的文件"></a>4.2 取消暂存中的文件</h2><p>我们有多个文件还未暂存，但是我们<strong>不小心一次性全部放入暂存了</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>但是我们想一个一个放，不能一次性放入，因此我们使用这两条命令（git status显示的内容有说明）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure>
<p>HEAD表示上一个版本 HEAD^ HEAD^^  …. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git store --staged file</span><br></pre></td></tr></table></figure>
<h2 id="4-3-取消对文件的修改"><a href="#4-3-取消对文件的修改" class="headerlink" title="4.3 取消对文件的修改"></a>4.3 取消对文件的修改</h2><p>我们<strong>不想对这个文件进行修改了</strong>，让他回到一开始的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- benchmarks.rb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可能已经意识到了，这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过来重写了此文件。所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。如果只是想回退版本，同时保留刚才的修改以便将来继续工作，可以用下章介绍的 stashing 和分支来处理，应该会更好些。</p>
</blockquote>
<h1 id="5-远程管理仓库"><a href="#5-远程管理仓库" class="headerlink" title="5. 远程管理仓库"></a>5. 远程管理仓库</h1><p> 管理远程仓库的工作，包括<strong>添加远程库</strong>，<strong>移除废弃的远程库</strong>，<strong>管理各式远程库分支</strong>，<strong>定义是否跟踪这些分支</strong></p>
<h2 id="5-1-查看当前远程库"><a href="#5-1-查看当前远程库" class="headerlink" title="5.1 查看当前远程库"></a>5.1 查看当前远程库</h2><p>查看当前配置有哪些远程库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>
<p>注意：<strong>默认存在一个 origin的远程库</strong>，Git 默认使用这个名字来标识你所克隆的原始仓库。</p>
<p>显示原始仓库的<strong>克隆地址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote --v</span><br></pre></td></tr></table></figure>
<p>如果有多个远程仓库，此命令将全部列出。</p>
<h2 id="5-2-添加远程仓库"><a href="#5-2-添加远程仓库" class="headerlink" title="5.2 添加远程仓库"></a>5.2 添加远程仓库</h2><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add pb  git://github.com/paulboone/ticgit.git</span><br></pre></td></tr></table></figure>
<p>添加了一个 远程仓库  名称为 pb</p>
<p><strong>pb代表的就是远程仓库的地址</strong></p>
<p>抓取仓库地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch pb</span><br></pre></td></tr></table></figure>
<p>Paul 的主干分支（master）已经完全可以在本地访问了，对应的名字是 <code>pb/master</code>，你可以将它合并到自己的某个分支，或者切换到这个分支，看看有些什么有趣的更新。</p>
<h2 id="5-3-从远程仓库抓取数据"><a href="#5-3-从远程仓库抓取数据" class="headerlink" title="5.3 从远程仓库抓取数据"></a>5.3 从远程仓库抓取数据</h2><p>使用下面的命令从<strong>远程仓库抓取数据到本地</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch &lt;remote-name&gt;</span><br></pre></td></tr></table></figure>
<p>此命令从<strong>远程仓库中拉取所有你本地仓库中还没有的数据</strong>。</p>
<hr>
<p>抓取从你上次克隆这个仓库以来，别人上传到此仓库中的所有更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure>
<p>有一点很重要，需要记住，<strong>fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支</strong>，只有当你确实准备好了，才能手工合并。</p>
<h2 id="5-4-推送数据到远程仓库"><a href="#5-4-推送数据到远程仓库" class="headerlink" title="5.4 推送数据到远程仓库"></a>5.4 推送数据到远程仓库</h2><p>项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push [remote-name] [branch-name]</span><br></pre></td></tr></table></figure>
<p>把本地的branch分支推送到远程 remote 服务器上</p>
<h2 id="5-5-查看远程仓库信息"><a href="#5-5-查看远程仓库信息" class="headerlink" title="5.5 查看远程仓库信息"></a>5.5 查看远程仓库信息</h2><p>命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show [remote-name]</span><br></pre></td></tr></table></figure>
<p>查看某个远程仓库的信息</p>
<p>它友善地告诉你如果是在 <strong>master 分支</strong>，就可以用 <code>git pull</code> 命令抓取数据合并到本地。</p>
<p>另外还列出了所有<strong>处于跟踪状态中的远端分支</strong>。</p>
<h2 id="5-6-远程仓库的删除与重命名"><a href="#5-6-远程仓库的删除与重命名" class="headerlink" title="5.6 远程仓库的删除与重命名"></a>5.6 远程仓库的删除与重命名</h2><p>修改某个远程仓库在本地的名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rename pb pbnewname</span><br></pre></td></tr></table></figure>
<p>对远程仓库的重命名，也会使对应的分支名称发生变化。</p>
<p>删除对应的远程仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm pbname</span><br></pre></td></tr></table></figure>
<h1 id="6-打标签"><a href="#6-打标签" class="headerlink" title="6. 打标签"></a>6. 打标签</h1><p>在某一时间点上打上标签</p>
<p>git的标签类型：</p>
<ol>
<li>轻量型标签：是个不会变化的标签，只指向某个特定对象的引用</li>
<li>含附注的标签：存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明。</li>
</ol>
<h2 id="6-1-显示所有标签"><a href="#6-1-显示所有标签" class="headerlink" title="6.1 显示所有标签"></a>6.1 显示所有标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>标签按字母顺序排列，所以<strong>标签的先后不表示重要程度的轻重</strong>.</p>
<p>筛选标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -l &#x27;v1.4.2.*&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-创建标签"><a href="#6-2-创建标签" class="headerlink" title="6.2 创建标签"></a>6.2 创建标签</h2><p>创建含附注的标签：<code>-a</code> 后附带<strong>标签的名字</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -a v1.4 -m &#x27;my version 1.4&#x27;</span><br></pre></td></tr></table></figure>
<p><code>-m</code>表示指定对应的标签说明，如果没有 -m后面的内容，则会跳转到vscode让你手动编写 <strong>标签说明</strong></p>
<p>使用下面的命令来显示标签对应的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git show v1.4</span><br></pre></td></tr></table></figure>
<p>列出了此标签的提交者和提交时间，以及相应的标签说明。</p>
<p>创建个人的<strong>私钥</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -s v1.5 -m &#x27;my signed 1.5 tag&#x27;</span><br></pre></td></tr></table></figure>
<p>创建<strong>轻量级标签</strong>，直接给出标签的名字即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag v1.8</span><br></pre></td></tr></table></figure>
<h2 id="6-3-加注标签"><a href="#6-3-加注标签" class="headerlink" title="6.3 加注标签"></a>6.3 加注标签</h2><p>已经提交的版本中<strong>补上标签信息</strong>：</p>
<p>首先显示所有的版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure>
<p>可以看到 没有标签，我们输入命令，让其中一个版本加上标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -a v1.9 085bb3b</span><br></pre></td></tr></table></figure>
<p><strong>注意：直需要加上校验和的前几位即可，git就会识别这是哪一个版本。</strong></p>
<p>显示我们刚加的标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git show v1.9</span><br></pre></td></tr></table></figure>
<h2 id="6-4-分享标签"><a href="#6-4-分享标签" class="headerlink" title="6.4 分享标签"></a>6.4 分享标签</h2><p>通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 <code>git push origin [tagname]</code> 即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin v1.5</span><br></pre></td></tr></table></figure>
<p>一次性推送所有的本地标签上去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>
<h1 id="7-Git使用技巧"><a href="#7-Git使用技巧" class="headerlink" title="7. Git使用技巧"></a>7. Git使用技巧</h1><h2 id="7-1-自动补全"><a href="#7-1-自动补全" class="headerlink" title="7.1 自动补全"></a>7.1 自动补全</h2><p>首先可以查看自己的 Git 有没有自动补全的功能，如下操作所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git con&lt;tab&gt;</span><br></pre></td></tr></table></figure>
<p>输入git co 然后 按<strong>两次tab键</strong>，会出现提示的命令： config 和commit</p>
<p><img src="https://great.wzznft.com/i/2023/03/04/m5tqml.png" alt=""></p>
<p><strong>如果上述办法不可以</strong>，则需要进行如下操作：</p>
<blockquote>
<p>如果你用的是 Bash shell，可以试试看 Git 提供的自动补全脚本。下载 Git 的源代码，进入 <code>contrib/completion</code> 目录，会看到一个 <code>git-completion.bash</code> 文件。将此文件复制到你自己的用户主目录中（译注：按照下面的示例，还应改名加上点：<code>cp git-completion.bash ~/.git-completion.bash</code>），并把下面一行内容添加到你的 <code>.bashrc</code> 文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.git-completion.bash</span><br></pre></td></tr></table></figure>
<p>也可以为系统上所有用户都设置默认使用此脚本。Mac 上将此脚本复制到 <code>/opt/local/etc/bash_completion.d</code> 目录中，Linux 上则复制到 <code>/etc/bash_completion.d/</code> 目录中。这两处目录中的脚本，都会在 Bash 启动时自动加载。</p>
</blockquote>
<h2 id="7-2-使用别名"><a href="#7-2-使用别名" class="headerlink" title="7.2 使用别名"></a>7.2 使用别名</h2><p>为命令起一个别名： <code>git config</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>
<p>接下来输入 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git st</span><br></pre></td></tr></table></figure>
<p>其实就是 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status </span><br></pre></td></tr></table></figure>
<p><strong>取消在暂存区的文件</strong>：<strong>完整命令如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure>
<p>可以使用别名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git unstage file</span><br></pre></td></tr></table></figure>
<p><strong>显示最后一次提交的文件，完整命令如下</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -1 HEAD</span><br></pre></td></tr></table></figure>
<p>可以使用别名，看起来会更清晰</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.last &#x27;log -1 HEAD&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git last</span><br></pre></td></tr></table></figure>
<p> Git 只是简单地在命令中替换了你设置的别名</p>
<p><strong>输入Git外部命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.visual &#x27;!gitk&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git visual </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习（1） - git的安装与配置</title>
    <url>/2023/03/03/git%E5%AD%A6%E4%B9%A0-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><ol>
<li>本地版本控制系统</li>
<li>集中化的版本控制系统</li>
<li>分布式版本控制系统</li>
</ol>
<h1 id="git基础"><a href="#git基础" class="headerlink" title="git基础"></a>git基础</h1><p>git与其他版本控制系统的区别是：<strong>git只保存文件数据的整体是否发生变化。</strong> 而大多数其他系统则只关心文件内容的<strong>具体差异</strong></p>
<p>换句话说：<strong>git保存每次更新时的文件快照</strong></p>
<p>Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的 VCS。</p>
<p>git的所有操作都是对本地文件的资源操作，因此不需要联网。 <strong>Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。</strong></p>
<p>git每次只需要从本地数据库读取内容，在任何时候都可以随时读取，再查看历史版本的时候，git会在保存的<strong>历史快照中</strong>查询，而不需要请求远程服务器或者把查询老版本的文件。</p>
<p>git可以在没有网络的时候<strong>随时提交更新到本地</strong>，等到有网络的时候再<strong>上传远程仓库</strong>。</p>
<p>git具有内容完整性的功能：<strong>在保存到 Git 之前，所有数据都要进行内容的校验和计算，并将此结果作为数据的唯一标识和索引。</strong>任何文件如果在传输时发生损坏，git都能察觉。</p>
<p>git使用 SHA-1 算法计算数据的校验和，这实际上是一个<strong>哈希值</strong>，git通过将文件转换为哈希值来工作，并依靠它作为git的索引。</p>
<hr>
<h2 id="git文件的三种形式"><a href="#git文件的三种形式" class="headerlink" title="git文件的三种形式"></a>git文件的三种形式</h2><ol>
<li>已提交：文件已经被安全的保存在本地数据库中</li>
<li>已修改：已经修改了文件，但是还没有保存提交</li>
<li>已暂存：把已修改的文件放在下次提交要保存的清单中</li>
</ol>
<p>git管理项目的三个区域：</p>
<ol>
<li>git的工作目录：项目中取出<strong>某个版本的所有文件和目录</strong>，用以开始后续工作。</li>
<li>暂存区域：暂存区域只不过是个简单的文件，一般都放在 Git 目录中。</li>
<li>本地仓库：Git或者 .git 目录：是保存元数据和对象数据库的地方，实际上克隆仓库的时候就是克隆这里面的数据</li>
</ol>
<hr>
<p>Git的工作流程：</p>
<ol>
<li>在<strong>工作目录</strong>中修改某些文件。</li>
<li>修改完成后的文件进行<strong>快照</strong>存放在<strong>暂存区域</strong>中</li>
<li>把暂存区域中的文件的快照提交更新到<strong>Git目录</strong>中。</li>
</ol>
<p>三种状态：</p>
<ol>
<li>已提交状态</li>
<li>已暂存状态</li>
<li>已修改状态</li>
</ol>
<h1 id="git的安装"><a href="#git的安装" class="headerlink" title="git的安装"></a>git的安装</h1><h2 id="源代码安装"><a href="#源代码安装" class="headerlink" title="源代码安装"></a>源代码安装</h2><ol>
<li>如果有 yum，则输入以下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install curl-devel expat-devel gettext-devel \</span><br><span class="line">  openssl-devel zlib-devel</span><br></pre></td></tr></table></figure>
<ol>
<li>如果有apt-get，则输入以下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \</span><br><span class="line">  libz-dev libssl-dev</span><br></pre></td></tr></table></figure>
<p>之后，从下面的 Git 官方站点下载最新版本源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://git-scm.com/download</span><br></pre></td></tr></table></figure>
<p>然后编译并安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar -zxf git-1.7.2.2.tar.gz</span><br><span class="line">$ cd git-1.7.2.2</span><br><span class="line">$ make prefix=/usr/local all</span><br><span class="line">$ sudo make prefix=/usr/local install</span><br></pre></td></tr></table></figure>
<p>现在已经可以用 <code>git</code> 命令了，用 <code>git</code> 把 Git 项目仓库克隆到本地，以便日后随时更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git://git.kernel.org/pub/scm/git/git.git</span><br></pre></td></tr></table></figure>
<h2 id="linux安装"><a href="#linux安装" class="headerlink" title="linux安装"></a>linux安装</h2><ol>
<li>具有yum的时候，通过yum安装</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install git-core</span><br></pre></td></tr></table></figure>
<ol>
<li>Ubuntu 具有 apt-get的时候，通过apt-get安装</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure>
<h2 id="window安装"><a href="#window安装" class="headerlink" title="window安装"></a>window安装</h2><ol>
<li>通过GitHub的开源项目安装 下载exe，并且运行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://msysgit.github.com/</span><br></pre></td></tr></table></figure>
<ol>
<li>上一种方法国内下载慢，可以使用阿里镜像安装</li>
</ol>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZWdpc3RyeS5ucG1taXJyb3IuY29tL2JpbmFyeS5odG1sP3BhdGg9Z2l0LWZvci13aW5kb3dzLw==">阿里镜像下载 git<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h1><p>git config工具，实际上是 git-config命令，使用这个命令来配置或者读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<ol>
<li><code>/etc/gitconfig</code>：系统中所有用户都使用的配置，git config时使用 —system。</li>
<li><code>~/.gitconfig</code>：用户工作目录下的配置文件只适用于此用户git config时使用 —global。</li>
<li><code>.git/config</code>：当前项目的配置文件，只针对于当前项目。</li>
</ol>
<p>每一个级别的配置都会覆盖上层相同的配置，因此<code>.git/config</code>会覆盖<code>/etc/gitconfig</code>中的同名变量。</p>
<p><code>.gitconfig</code>的路径：默认在C盘的user的文件夹下。</p>
<h2 id="修改用户信息"><a href="#修改用户信息" class="headerlink" title="修改用户信息"></a>修改用户信息</h2><p>git在提交更新的时候需要知道是谁提交了，因此需要配置个人信息</p>
<p>输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.email 电子邮箱</span><br></pre></td></tr></table></figure>
<p>使用—global配置的.gitconfig的文件路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Users\username\.gitconfig&quot;</span><br></pre></td></tr></table></figure>
<p><strong>我们配置的是用户主目录的那个，因此所有的项目默认使用这个配置。</strong></p>
<p>如果要在<strong>某个特定的项目中</strong>使用其他用户或者电脑，则需要去掉 —global ，重新配置信息即可。</p>
<h2 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h2><p>默认的git输入信息使用的文编编辑器</p>
<p>我这里使用vscode，你也可以使用Emacs  或者 vim</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.editor vscode</span><br></pre></td></tr></table></figure>
<h2 id="差异比较工具"><a href="#差异比较工具" class="headerlink" title="差异比较工具"></a>差异比较工具</h2><p>在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global merge.tool vimdiff</span><br></pre></td></tr></table></figure>
<h2 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h2><p>输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
<h2 id="使用帮助命令"><a href="#使用帮助命令" class="headerlink" title="使用帮助命令"></a>使用帮助命令</h2><p>想要知道某个命令如何使用： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config &lt;xxx&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo与github搭建个人博客</title>
    <url>/2023/03/02/hexo%E4%B8%8Egithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="0-前置内容"><a href="#0-前置内容" class="headerlink" title="0. 前置内容"></a>0. 前置内容</h1><ol>
<li><strong>git 的下载</strong>： 官网下载较慢，这边推荐阿里镜像下载：</li>
</ol>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZWdpc3RyeS5ucG1taXJyb3IuY29tL2JpbmFyeS5odG1sP3BhdGg9Z2l0LWZvci13aW5kb3dzLw==">阿里镜像下载 git<i class="fa fa-external-link-alt"></i></span></p>
<p>往下滑选择接近当前日期的最新版本  2.39.2 windows</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124lpsb.png" alt=""></p>
<p>选择 2.39.2 -64 的exe下载，大概有 50Mb大小</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124lsc8.png" alt=""></p>
<p>下载好后，直接<strong>一直点下一步即可</strong>。如果你了解过git，则可以按照自己的习惯下载，这不重要。</p>
<ol>
<li><strong>Nodejs下载</strong></li>
</ol>
<p>直接百度搜索 Nodejs，<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">Nodejs下载<i class="fa fa-external-link-alt"></i></span> </p>
<p>选择 18.14.2 的 LTS版本下载</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124luej.png" alt=""></p>
<h1 id="1-hexo创建个人博客"><a href="#1-hexo创建个人博客" class="headerlink" title="1. hexo创建个人博客"></a>1. hexo创建个人博客</h1><p>hexo是什么？</p>
<ul>
<li><p>正如hexo的首页所显示的，它是一款非常快速，简介，高效的博客框架平台，我们可以利用hexo快速生成博客网站的模板，然后部署为我们自己的博客网站。</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124lxlr.png" alt=""></p>
</li>
</ul>
<p>直接进入操作：</p>
<ol>
<li><strong>在任意盘符中新建 hexo 文件夹</strong>，这里我创建在了F盘</li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/02/124m59v.png" alt=""></p>
<ol>
<li><strong>打开hexo文件夹，空白的地方右键，选择 Git Bash Here</strong> ，即我们使用 git 环境创建 hexo的blog模板（必须提前安装好 git），打开后如下图所示：<strong>/ f / hexo表示当前操作位置在 F盘的 hexo文件夹中</strong></li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/02/124m6dn.png" alt=""></p>
<p><img src="https://tudingtu.cn/i/2023/03/02/124mb6h.png" alt=""></p>
<ol>
<li><strong>在 git窗口中依次输入以下命令</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd blog</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>全部输入完成后，hexo文件夹中便会生成一个 blog 子文件夹，并且blog文件夹里面包含有很多信息：</p>
<p><img src="https://great.wzznft.com/i/2023/03/02/1282mhg.png" alt=""></p>
<p>关于这些文件夹，做一个简单的介绍：</p>
<ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：生成文章的一些模板</li>
<li>source：用来存放你的文章</li>
<li>themes：主题</li>
</ul>
<p>然后输入这两条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s </span><br></pre></td></tr></table></figure>
<p>完成后会显示如下内容，则说明<strong>配置成功</strong>!</p>
<p><img src="https://great.wzznft.com/i/2023/03/03/piaj7x.png" alt=""></p>
<p>在  git 中输入 Ctrl+C 即可关闭hexo s的内容。</p>
<p>打开浏览器，在浏览器输入 <strong>localhost:4000</strong> 即可进入你的<strong>初始默认博客</strong></p>
<p>它长这样：</p>
<p><img src="https://tudingtu.cn/i/2023/03/02/12e7hdk.png" alt=""></p>
<p>注意：这只是一个<strong>离线版本的博客</strong> ，只能你自己看见，因此我们还需要 GitHub或者 gittee提供的 ssh功能将他变为对外开放的。</p>
<h1 id="2-GitHub创建仓库"><a href="#2-GitHub创建仓库" class="headerlink" title="2. GitHub创建仓库"></a>2. GitHub创建仓库</h1><ol>
<li>首先注册一个GitHub的仓库，然后在<strong>个人主页中选择 new 新建仓库</strong></li>
</ol>
<p>注意： 仓库名称的<strong>前半部分与你的用户名一致</strong>，即 lummod，<strong>后半部分 为  .git.io 固定格式</strong>（忽略红色警告，因为我已经创建过了！），可以选择一个readme为说明文件（随便），然后<strong>点击创建仓库</strong></p>
<p><img src="https://tudingtu.cn/i/2023/03/02/12idvsn.png" alt=""></p>
<ol>
<li>回到 git bash黑窗口中，<strong>输入以下两个命令</strong>（逐条）：</li>
</ol>
<p>yourname改为你的<strong>GitHub的用户名</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br></pre></td></tr></table></figure>
<p>youremail改为你的<strong>注册GitHub时的邮箱</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
<p>一定不要输入错，这样github才能检查到这个用户属于你</p>
<ol>
<li><strong>创建 ssh，输入命令，然后一直回车</strong></li>
</ol>
<p>youremail改为你的<strong>注册GitHub时的邮箱</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
<p>之后会提示你已完成 ssh的创建，在文件中找到这个路径</p>
<p><img src="https://great.wzznft.com/i/2023/03/02/12lqlrh.png" alt=""></p>
<p>记住这两个文件</p>
<ol>
<li>在 GitHub的 Setting里面，找到 SSH keys，<strong>把 id_rsa.pub 里面的内容全部复制到 key 进去</strong>，title随便写一个就行</li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/02/12mxnrn.png" alt=""></p>
<p>操作完成后，就成功了。</p>
<h1 id="3-hexo部署到GitHub"><a href="#3-hexo部署到GitHub" class="headerlink" title="3. hexo部署到GitHub"></a>3. hexo部署到GitHub</h1><ol>
<li>在 blog文件夹下面找到 <strong>_config.yml 文件</strong>，这是属于 你的博客的<strong>配置文件</strong>，<strong>点进入一看就知道了，你可以在这里面直接修改 姓名，内容，等用户的信息</strong>。双击打开它（vscode或者其他文本编辑器，记事本都可以）</li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/nknu8o.png" alt=""></p>
<ol>
<li>先找一下有没有以下这段内容（我也忘记了是我添加的还是自带的），<strong>如果自带则一定是空的，则修改为如下所示，如果没有，则直接复制下面内容到 文档的末尾：</strong></li>
</ol>
<p><strong>user表示你的GitHub的用户名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line"># deploy:</span><br><span class="line">#   type: &#x27;&#x27;</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/username/username.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  # message: Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>说明：类型是 git，远程 ssh连接是 你的 repo输入项，branch 输入gh-pages。</strong></p>
<p>另外，找到 第16行（或者直接搜索 url）修改url 为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://username.github.io</span><br></pre></td></tr></table></figure>
<p>  同样username是你的GitHub的用户名。</p>
<ol>
<li>完成后，保存文件并且退出，在 git bash中输入以下命令：</li>
</ol>
<p><strong>表示安装 git部署命令工具</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<ol>
<li>最后输入以下三行命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。<br><code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写<br><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p>
<p><strong>如果是在离线端即 localhost:4000端测试你的博客，则只需要 hexo  g + hexo s 即可，无需 hexo d</strong></p>
<ol>
<li>输入完成后会出现一堆内容，不用管他<strong>，只要最后内容如下所示，</strong>就表示成功了！</li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/03/nl3wwl.png" alt=""></p>
<p>然后你就可以在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username.github.io  # https://username.github.io</span><br></pre></td></tr></table></figure>
<p><strong>访问到你的博客了，其中username是你GitHub用户名，这个网站不是离线的，其他人都可以访问到！！！</strong></p>
<h1 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h1><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>在 根目录中，git bash黑窗口中输入 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;博客名称&quot;</span><br></pre></td></tr></table></figure>
<p>然后打开 blog/source/_posts/ 文件夹后，你的 博客名称的md文档就创建好，<strong>直接打开编写即可，可以添加一些标签给这个文章</strong>，如 tags：编程技术</p>
<p><img src="https://great.wzznft.com/i/2023/03/03/p8mg87.png" alt=""></p>
<h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>生成静态文件。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-d</code>, <code>--deploy</code></td>
<td style="text-align:left">文件生成后立即部署网站</td>
</tr>
<tr>
<td style="text-align:left"><code>-w</code>, <code>--watch</code></td>
<td style="text-align:left">监视文件变动</td>
</tr>
<tr>
<td style="text-align:left"><code>-b</code>, <code>--bail</code></td>
<td style="text-align:left">生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td style="text-align:left"><code>-f</code>, <code>--force</code></td>
<td style="text-align:left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-c</code>, <code>--concurrency</code></td>
<td style="text-align:left">最大同时生成文件的数量，默认无限制</td>
</tr>
</tbody>
</table>
</div>
<p>该命令可以简写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-p</code>, <code>--port</code></td>
<td style="text-align:left">重设端口</td>
</tr>
<tr>
<td style="text-align:left"><code>-s</code>, <code>--static</code></td>
<td style="text-align:left">只使用静态文件</td>
</tr>
<tr>
<td style="text-align:left"><code>-l</code>, <code>--log</code></td>
<td style="text-align:left">启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody>
</table>
</div>
<p>该命令可以简写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p><strong>部署网站，构建在GitHub的服务器中。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-g</code>, <code>--generate</code></td>
<td style="text-align:left">部署之前预先生成静态文件</td>
</tr>
</tbody>
</table>
</div>
<p>该命令可以简写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>命令配合使用，重新构建网站（release）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>访问离线的端口（debug）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<h1 id="5-添加插件"><a href="#5-添加插件" class="headerlink" title="5. 添加插件"></a>5. 添加插件</h1><h2 id="5-1-主题"><a href="#5-1-主题" class="headerlink" title="5.1 主题"></a>5.1 主题</h2><ol>
<li>hexo提供了非常多的主题模板，在hexo的网站里往下滑，点击<strong>探索主题</strong>即可。</li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/nlx1xa.png" alt=""></p>
<ol>
<li>选择某一个主题，然后可以点击 中间是<strong>预览的效果</strong>，点击蓝色的名字是 该<strong>主题的GitHub的下载地址</strong></li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/nmwn8v.png" alt=""></p>
<ol>
<li>我的<strong>主题是 next</strong>，next是一款非常简洁舒服的主题，并且可支持的插件非常多，功能也很强大，可以直接搜索next，然后点击 GitHub的地址，进入下载</li>
<li>根据它的下载提示，直接在 git bash窗口中输入，即可下载next主题</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<ol>
<li>下载完成之后，在 blog文件夹（即根目录）下找到 <strong>themes文件夹，这个文件夹里面存放你下载的主题文件</strong>，可以看到next主题又再次包含一个文件夹，其中包含了next 主题的配置信息</li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/nqh1kl.png" alt=""></p>
<ol>
<li>修改blog的主题：首先返回<strong>blog根目录中，打开 _config.yml 文件</strong>（建议备份一份，直接复制即可），然后在 _config.yml 中<strong>找到  theme选项</strong>（如果你使用vscode，则直接 ctrl+h搜索即可，否则就自己往下滑），然后把 <strong>theme 上输入 next，表示使用的主题是next</strong>（使用其他主题也是如此）</li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/nrs0i4.png" alt=""></p>
<ol>
<li>之后就成功！输入 localhost:4000 或者 hexo g， hexo d，然后输入 username.github.io， 离线或者在线都可以看到设置的next的主题，具体效果自己查看吧！</li>
</ol>
<h2 id="5-2-博客基本信息"><a href="#5-2-博客基本信息" class="headerlink" title="5.2 博客基本信息"></a>5.2 博客基本信息</h2><p>修改 博客的标题，副标题，描述，等等基本信息。。。</p>
<p>在 blog根目录下打开 _config.yml 配置文件，直接修改以下信息即可（看不懂英文的直接有道云翻译即可）</p>
<p>注意，语言要改成 zh-CN即中国，其他的自己随便改改</p>
<p><img src="https://tudingtu.cn/i/2023/03/03/nur4r6.png" alt=""></p>
<h2 id="5-3-创建新的菜单"><a href="#5-3-创建新的菜单" class="headerlink" title="5.3 创建新的菜单"></a>5.3 创建新的菜单</h2><p><strong>打开 themes 的 next 的 _config.yml ，我们此时打开的是主题的配置文件，不是根目录的。</strong></p>
<p>找到第118行或者 搜索menu，即可看到：这里其实就是我们的博客菜单选项。在一开始我们只有home和 archives是开着的，<strong>如果你想添加一个 tags或者about菜单该如何操作呢？</strong></p>
<p><img src="https://tudingtu.cn/i/2023/03/03/o07neg.png" alt=""></p>
<ol>
<li>首先在 blog的根目录中打开 git bash黑窗口，输入以下的命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags  # tags可以是其他的</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>然后在这个 _config 的menu中把 tags这一项取消注释</strong>，然后重新构建：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<ol>
<li>在localhost：4000中 看看效果：</li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/o2eke4.png" alt=""></p>
<p>添加完成之后，<strong>我们在 blog根目录中打开 source文件夹，即可看到我们的菜单文件夹， tags，打开后，它其实就是一个 md文档！你可以自己在md文档上编辑，然后重新构建看看效果！</strong></p>
<p><img src="https://tudingtu.cn/i/2023/03/03/o31yhd.png" alt=""></p>
<p>同理我们可以<strong>自己创建 菜单，输入 hexo new page xxx</strong>，然后在 <strong>主题的config_yml 的menu中按照其他的格式添加即可 。</strong></p>
<h2 id="5-4-添加搜索功能"><a href="#5-4-添加搜索功能" class="headerlink" title="5.4 添加搜索功能"></a>5.4 添加搜索功能</h2><p>打开博客的<strong>搜索文章的 功能</strong></p>
<p>下载<strong>搜索插件</strong>：</p>
<p>git bash黑窗口中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<ol>
<li>主题 的 _config 配置文件中找到 <strong>local_search</strong>，下面的 <strong>enable输入true即可。</strong></li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/ot2kta.png" alt=""></p>
<ol>
<li>在根目录的 _config.yml 文件中 的末尾添加下面的内容：（选项的内容可以适当修改）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo-generator-searchdb</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10</span><br></pre></td></tr></table></figure>
<p>重新构建后，即可看到效果：</p>
<p><img src="https://great.wzznft.com/i/2023/03/03/ovkwm1.png" alt=""></p>
<h2 id="5-5-添加阅读时间字数提示"><a href="#5-5-添加阅读时间字数提示" class="headerlink" title="5.5 添加阅读时间字数提示"></a>5.5 添加阅读时间字数提示</h2><p>效果如图：</p>
<p><img src="https://great.wzznft.com/i/2023/03/03/owxl01.png" alt=""></p>
<ol>
<li>git 黑窗口中输入以下命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>在blog的根目录的 _config中 复制下面这段话到末尾</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br><span class="line">  exclude_codeblock: false</span><br><span class="line">  awl: 2	</span><br><span class="line">  wpm: 275</span><br><span class="line">  suffix: &quot;mins.&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li>在 <strong>主题的 config文件中找到，并且 输入 true即可，效果可以自行查看。</strong></li>
</ol>
<p><img src="https://great.wzznft.com/i/2023/03/03/oyhmga.png" alt=""></p>
<h2 id="5-6-打赏功能"><a href="#5-6-打赏功能" class="headerlink" title="5.6 打赏功能"></a>5.6 打赏功能</h2><p>在 主题的 config中找到如下的 <strong>raward功能</strong></p>
<ol>
<li>enable选择打开，comment输入文字</li>
<li>在缀主题的images文件夹中把你的<strong>付款码的图片放到 /blog /themes /next /source /images/ 中</strong>，它会按照这个路径寻找图片</li>
</ol>
<p><img src="https://tudingtu.cn/i/2023/03/03/oz699b.png" alt=""></p>
<p><strong>可以发现 这个images文件夹里面的图片都是可以修改的，找到合适的地点，然后更改你的 图片即可换成你想要的图片了。</strong></p>
<h2 id="5-7-切换主题"><a href="#5-7-切换主题" class="headerlink" title="5.7 切换主题"></a>5.7 切换主题</h2><p>在 主题的config文件夹中找到这个地方，<strong>直接注释或者取消注释即可</strong></p>
<p><img src="https://tudingtu.cn/i/2023/03/03/p28l6c.png" alt=""></p>
<h2 id="5-8-添加不蒜子统计"><a href="#5-8-添加不蒜子统计" class="headerlink" title="5.8 添加不蒜子统计"></a>5.8 添加不蒜子统计</h2><p>在主题的config文件中找到这个地方，直接enable输入true即可。它可以帮助我们<strong>统计网站的观看人数</strong></p>
<p><img src="https://tudingtu.cn/i/2023/03/03/p4k4l4.png" alt=""></p>
<h2 id="5-9-添加百度统计"><a href="#5-9-添加百度统计" class="headerlink" title="5.9 添加百度统计"></a>5.9 添加百度统计</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxOTc3Mi9hcnRpY2xlL2RldGFpbHMvMTIzMjczMTYz">为hexo的next主题添加百度统计功能，<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="…-待更新"><a href="#…-待更新" class="headerlink" title="… 待更新"></a>… 待更新</h2>]]></content>
      <tags>
        <tag>hexo博客配置</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数知识点总结</title>
    <url>/2023/03/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-行列式"><a href="#1-行列式" class="headerlink" title="1. 行列式"></a>1. 行列式</h1><p>行列式的定义：n*n个数字排成n行n列，叫做n阶行列式。</p>
<p>行列式的项数：</p>
<ol>
<li>2阶行列式有2项</li>
<li>3阶行列式有6项</li>
<li>4阶行列式有24项</li>
</ol>
<h2 id="1-1-余子式与代数余子式"><a href="#1-1-余子式与代数余子式" class="headerlink" title="1.1 余子式与代数余子式"></a>1.1 余子式与代数余子式</h2><p>余子式：关于一个k阶子式的余子式，是A去掉了这个k阶子式所在的行与列之后得到的（n－k）×（n－k）矩阵的行列式。</p>
<p>代数余子式：元素aₒₑi的代数余子式与该元素本身没什么关系，只与该元素的位置有关。</p>
<p><strong>行列式按行展开</strong></p>
<ul>
<li>行列式的值D = 任意一行（列）元素<em>自己的<em>*代数余子式</em></em>之和</li>
</ul>
<hr>
<p><strong>异乘变零定理</strong></p>
<ul>
<li>某行元素与另一行元素的代数余子式乘积之和=0</li>
</ul>
<hr>
<p>拉普拉斯定理（k阶子式）</p>
<ul>
<li>k=2<ul>
<li>2阶子式：取任意两行两列，交界的元素就是2阶子式</li>
<li>余子式：两行两列之外（剩余）的元素就是余子式</li>
<li>代数余子式：（-1）^（行1+行2+列1+列2）*余子式</li>
</ul>
</li>
</ul>
<p>拉普拉斯展开定理</p>
<ul>
<li>n阶行列式中，任意取定k行，由k行元素组成的所有<strong>k阶子式</strong>与<strong>代数余子式</strong>的乘积之和=行列式的值（D）</li>
</ul>
<hr>
<p>行列式相乘：（同阶行列式）三阶行列式：</p>
<ul>
<li><p>第一行</p>
<ul>
<li>第一行元素*第一列元素，元素对应先相乘再相加</li>
<li>第一行元素*第二列元素，…</li>
<li>第一行元素*第三列元素，… </li>
</ul>
</li>
<li><p>第二行</p>
<ul>
<li>第二行元素*第一列元素，…</li>
<li>第二行元素*第二列元素，…</li>
<li>第二行元素*第三列元素，… </li>
</ul>
</li>
<li><p>第三行</p>
<ul>
<li>第三行元素*第一列元素，…</li>
<li>第三行元素*第二列元素，…</li>
<li>第三行元素*第三列元素，… </li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-2-行列式计算"><a href="#1-2-行列式计算" class="headerlink" title="1.2 行列式计算"></a>1.2 行列式计算</h2><ul>
<li>化成上下三角</li>
<li><p>按行展开</p>
</li>
<li><p>制造<strong>行和</strong>：如图所示行列式</p>
</li>
</ul>
<script type="math/tex; mode=display">
\left|\begin{matrix}
    x & a & a \\
    a & x & a \\
    a & a & x 
   \end{matrix} \right|-> 
   (x+2a)\left|\begin{matrix}
    1 & a & a \\
    1 & x & a \\
    1 & a & x 
   \end{matrix} \right| ->
   (x+2a) \left|\begin{matrix}
    1 & 0 & 0 \\
    1 & x & 0 \\
    1 & 0 & x 
   \end{matrix} \right|(用第一列乘-a加到后两列去，形成下三角求和)</script><ul>
<li><p>加边法：不能改变原行列式的值</p>
</li>
<li><p>范德蒙德行列式：[<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/ojIPlvrfokpnooYzliJflvI8vNjA4MTI4OD9mcm9tdGl0bGU96IyD5b636JKZ5b636KGM5YiX5byPJmFtcDtmcm9taWQ9MTU5OTUzMzYmYW1wO2ZyPWFsYWRkaW4=">范德蒙行列式_百度百科 (baidu.com)<i class="fa fa-external-link-alt"></i></span>]</p>
</li>
<li><strong>反对称行列式</strong><ul>
<li>主对角线全为零 aii=-aii  aii=0</li>
<li>对角线对称位置对应成<strong>相反数</strong> aij=-aji</li>
<li>如果是<strong>奇数阶</strong>，则D=0（利用转置性质）</li>
</ul>
</li>
<li><strong>对称行列式</strong><ul>
<li>主对角线元素没有要求</li>
<li>对角线对称位置对应成<strong>相等</strong> aij=aji</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-3-克莱姆法则"><a href="#1-3-克莱姆法则" class="headerlink" title="1.3 克莱姆法则"></a>1.3 克莱姆法则</h2><p><strong>方程的个数等于未知量的个数</strong></p>
<ul>
<li>n个方程，n个未知量 </li>
<li><p>D !=0 ： <strong>Xi= Di/D</strong>  </p>
</li>
<li><p><strong>Di 表示的是把系数行列式中第 i 列的元素用 常数项列 替代</strong></p>
</li>
</ul>
<p>定理与推论：</p>
<ul>
<li>定理1：系数行列式D不等于0，则方程组有唯一解，解为：x1=D1/D,x2=D2/D ….<ul>
<li>推论1：线性方程组<strong>无解或者有多组不同的解</strong>，<strong>系数行列式D=0</strong></li>
</ul>
</li>
</ul>
<ul>
<li>定理2：齐次线性方程组的系数行列式 <strong>D!=0</strong>，则齐次线性方程组<strong>只有零解</strong><ul>
<li>齐次线性方程组有非零解的<strong>充要条件</strong> &lt;==&gt; D=0</li>
</ul>
</li>
</ul>
<p>简单来说： </p>
<ol>
<li>D!=0 ，只有零解</li>
<li>D=0，有非零解</li>
</ol>
<hr>
<h1 id="2-矩阵"><a href="#2-矩阵" class="headerlink" title="2. 矩阵"></a>2. 矩阵</h1><h2 id="2-1-矩阵的运算"><a href="#2-1-矩阵的运算" class="headerlink" title="2.1 矩阵的运算"></a>2.1 矩阵的运算</h2><h3 id="2-1-1-加法运算"><a href="#2-1-1-加法运算" class="headerlink" title="2.1.1 加法运算"></a>2.1.1 加法运算</h3><ul>
<li><p>同型矩阵才能相加减</p>
</li>
<li><p>对应行对应列的元素相加即可</p>
</li>
</ul>
<h3 id="2-1-2-数乘运算"><a href="#2-1-2-数乘运算" class="headerlink" title="2.1.2 数乘运算"></a>2.1.2 数乘运算</h3><ul>
<li>把矩阵的每一个元素都乘以k</li>
<li>矩阵的加减法与矩阵的数乘运算统称为<strong>矩阵的线性运算</strong></li>
</ul>
<h3 id="2-1-3-矩阵的乘法"><a href="#2-1-3-矩阵的乘法" class="headerlink" title="2.1.3 矩阵的乘法"></a>2.1.3 矩阵的乘法</h3><p>定义： 设A=(aij)m<em>s， B=(bij)s </em> n ,则C=(cij)m*n=AB</p>
<ul>
<li>只有当左边矩阵A的行数等于右边矩阵B的列数才能做乘法运算。</li>
<li><p>相乘后，结果矩阵的行数等于左边矩阵A的行数，列数等于右边矩阵B的列数。</p>
</li>
<li><p>矩阵cij的元素等于矩阵A的第i行与矩阵B第j列元素相乘后相加。</p>
</li>
<li><p>矩阵乘法与普通乘法运算规则不同</p>
</li>
<li>若矩阵满足AB=BA，则A和B是可交换的，仅当A和B可交换时，才满足交换律，结合律等数学公式</li>
</ul>
<h3 id="2-1-4-矩阵的幂运算"><a href="#2-1-4-矩阵的幂运算" class="headerlink" title="2.1.4 矩阵的幂运算"></a>2.1.4 矩阵的幂运算</h3><ul>
<li>将k个Aij连乘即为A的k次幂</li>
</ul>
<h2 id="2-2-矩阵的转置"><a href="#2-2-矩阵的转置" class="headerlink" title="2.2 矩阵的转置"></a>2.2 矩阵的转置</h2><ul>
<li>将矩阵Aij转换为Aji，即行列互换即为A的转置</li>
<li>（AB）的转置 = B转置*A转置</li>
<li>A的转置等于A，则A是对称矩阵</li>
<li>A的转置等于-A，则A是反对称矩阵</li>
</ul>
<h2 id="2-3-方阵的行列式"><a href="#2-3-方阵的行列式" class="headerlink" title="2.3 方阵的行列式"></a>2.3 方阵的行列式</h2><ul>
<li>N阶方阵的所有元素（Aij）n*n 按照原来的位置构成的的行列式，称为方阵A的行列式，记作 |A|或者 detA</li>
<li>方阵行列式：是一个数；方阵：是一个数表</li>
<li>方阵行列式的性质</li>
<li>A的n阶方阵，若|A|!=0，则A为非奇异矩阵，当 |A|=0，则A为奇异矩阵</li>
</ul>
<h2 id="2-4-伴随矩阵"><a href="#2-4-伴随矩阵" class="headerlink" title="2.4 伴随矩阵"></a>2.4 伴随矩阵</h2><ul>
<li>A=（aij）n<em>n 是n阶方阵，则行列式 |A|中的每个元素aij的<em>*代数余子式</em></em>Aij所构成的矩阵称为矩阵A的伴随矩阵</li>
<li><strong>A*在（i，j）上的位置元素等于 A在 （j，i）上的位置的元素的代数余子式！！！！！！！</strong></li>
<li><p>伴随的一般求法：</p>
<ul>
<li>二阶矩阵的伴随： 对角线元素互换，反对角线添负号</li>
<li>三阶矩阵的伴随：将矩阵<strong>转置后</strong>求<strong>代数余子式</strong></li>
</ul>
</li>
<li><p>A是n阶方阵，A<em>是A的伴随矩阵，则满足： AA </em>=A *A=|A|E</p>
</li>
</ul>
<h2 id="2-5-逆矩阵"><a href="#2-5-逆矩阵" class="headerlink" title="2.5 逆矩阵"></a>2.5 逆矩阵</h2><ul>
<li>对于n阶方阵A，存在一个n阶方阵B，使得AB=BA=E，则称A是<strong>可逆矩阵</strong>，B是A的<strong>逆矩阵</strong>。记作A-1=B</li>
<li>单位矩阵E是可逆的，它的逆矩阵等于自身，零矩阵不是可逆矩阵</li>
</ul>
<h3 id="2-5-1-逆矩阵性质"><a href="#2-5-1-逆矩阵性质" class="headerlink" title="2.5.1 逆矩阵性质"></a>2.5.1 逆矩阵性质</h3><ul>
<li>若方阵A可逆，则A的<strong>逆矩阵是唯一</strong>的： 若B，C都是A 的逆矩阵，则AB=AC=E，B=BE=B(AC)=C(AB)=CE，所以 A=B</li>
<li>AB=E，则AB均可逆，A-1=B，B-1=A，判断A是不是B的逆矩阵：判断AB=E</li>
<li><strong>方阵A可逆，则|A|!=0，且|A-1|=1/|A|</strong>，<strong>判断A是否可逆，则仅需判断 |A|！=0</strong> ，|A|！=0 &lt;==&gt; A可逆</li>
<li>方阵A可逆，则A-1也可逆，则（A-1）-1=A</li>
<li>方阵A可逆，且k！=0，则 （kA）-1= 1/k *（A-1）</li>
<li>方阵A可逆，则A转置也可逆，（A转置）-1=（A-1）转置</li>
<li>AB是同阶可逆矩阵，AB也可逆，则（AB）-1=B-1* A-1</li>
</ul>
<h3 id="2-5-2-逆矩阵的求法"><a href="#2-5-2-逆矩阵的求法" class="headerlink" title="2.5.2 逆矩阵的求法"></a>2.5.2 逆矩阵的求法</h3><ul>
<li>根据伴随矩阵（求低阶方阵逆矩阵） <strong>若A是非奇异矩阵（|A|不等于0，则A是可逆的），则A-1=1/|A| * A伴随</strong></li>
</ul>
<h3 id="2-5-3-逆矩阵的应用"><a href="#2-5-3-逆矩阵的应用" class="headerlink" title="2.5.3 逆矩阵的应用"></a>2.5.3 逆矩阵的应用</h3><ul>
<li>对于一个线性方程组： A是系数矩阵，B是常系数矩阵，X是未知数矩阵，因此线性方程组用矩阵表示为AX=B，<strong>因此求线性方程组的解，可以转换为求相应矩阵的解</strong></li>
</ul>
<h2 id="2-6-矩阵的初等变换"><a href="#2-6-矩阵的初等变换" class="headerlink" title="2.6 矩阵的初等变换"></a>2.6 矩阵的初等变换</h2><p>性质</p>
<ol>
<li>交换矩阵的 第 i 行（列）与第 j 行（列）</li>
<li>非零常数 k 乘以 矩阵的第 i 行（列）</li>
<li>矩阵的第 j 行乘以 k倍 加到第 i 行上去</li>
</ol>
<p>矩阵的初等行或者列变换统称为 <strong>矩阵的初等变换</strong></p>
<ul>
<li>矩阵A经过有限次初等变换变成B，则A与B<strong>等价</strong><ul>
<li>反身性</li>
<li>对称性</li>
<li>传递性</li>
</ul>
</li>
<li>矩阵的左上角为一个<strong>单位矩阵</strong>，其余元素都是零，则该矩阵为<strong>标准型矩阵</strong><ul>
<li>任何一个非奇异矩阵，经过有限次初等行变换都能变成<strong>单位矩阵 E</strong> </li>
<li>推论：<strong>矩阵A可逆的充要条件使它与单位矩阵E等价</strong></li>
</ul>
</li>
</ul>
<p>行变换转换为标准型矩阵的一般步骤:</p>
<ol>
<li>行变换 转换为 <strong>行阶梯型矩阵</strong></li>
<li>行阶梯形矩阵 转换为 <strong>行最简</strong></li>
<li>行最简 列变换转换为<strong>标准型</strong></li>
</ol>
<p><strong>单位矩阵的行数等于行阶梯非零行的行数</strong></p>
<hr>
<h3 id="2-6-1-初等矩阵"><a href="#2-6-1-初等矩阵" class="headerlink" title="2.6.1 初等矩阵"></a>2.6.1 初等矩阵</h3><p>三种初等变换：</p>
<ol>
<li>交换第 i 行 与第 j 行</li>
<li>非零常数乘以 第 i 行</li>
<li>第 j 行乘以k 加到第 i 行上去</li>
</ol>
<p>性质：</p>
<ol>
<li>初等矩阵都是可逆矩阵，且其逆矩阵也是同类型的初等矩阵</li>
<li>初等矩阵的转置仍是同类型的初等矩阵</li>
<li>对一个矩阵A施行一次<strong>初等行变换等于对 A左乘一个m阶单位矩阵</strong>；对矩阵A施行<strong>一次初等列变换相当于对A右乘一个n阶单位矩阵</strong></li>
</ol>
<h2 id="2-7-初等变换的应用"><a href="#2-7-初等变换的应用" class="headerlink" title="2.7 初等变换的应用"></a>2.7 初等变换的应用</h2><h3 id="2-7-1-求逆矩阵"><a href="#2-7-1-求逆矩阵" class="headerlink" title="2.7.1 求逆矩阵"></a>2.7.1 求逆矩阵</h3><ul>
<li><strong>对矩阵 A 与 E做相同的初等变换等于对矩阵A 做初等行变换化为单位矩阵E时，E就变成了A的逆矩阵A-1</strong>（单位矩阵E乘以任何矩阵A，都等于矩阵A本身）</li>
</ul>
<script type="math/tex; mode=display">
(A,E)->(E,A^{-1})</script><p>初等列变换也是同理</p>
<h3 id="2-1-2-求解矩阵方程"><a href="#2-1-2-求解矩阵方程" class="headerlink" title="2.1.2 求解矩阵方程"></a>2.1.2 求解矩阵方程</h3><p>在矩阵A，B，C均可逆的前提下：</p>
<ol>
<li>AX=B，则 X=A-1B</li>
<li>XA=B，则 X=BA-1</li>
<li>AXB=C，则 X=A-1CB-1 </li>
</ol>
<ul>
<li>对矩阵 A 与 E做相同的初等变换等于对矩阵A 做初等行变换化为单位矩阵E时，E就变成了A的逆矩阵A-1</li>
</ul>
<script type="math/tex; mode=display">
(A,B)-^{初等行变换}->(E,A^{-1}B)</script><p>初等列变换也是同理</p>
<hr>
<h2 id="2-9-行最简矩阵与矩阵的秩"><a href="#2-9-行最简矩阵与矩阵的秩" class="headerlink" title="2.9 行最简矩阵与矩阵的秩"></a>2.9 行最简矩阵与矩阵的秩</h2><h3 id="2-9-1-行最简矩阵"><a href="#2-9-1-行最简矩阵" class="headerlink" title="2.9.1 行最简矩阵"></a>2.9.1 行最简矩阵</h3><p>行阶梯形矩阵：</p>
<ol>
<li>零行位于所有非零行的下面。</li>
<li>首非零元前面零的个数一定逐行严格增加</li>
</ol>
<p><strong>行最简型矩阵：</strong></p>
<ol>
<li>行阶梯形矩阵经过初等行变换使得 <strong>每一行的首非零元全部变为1，且他们所在列的其他元素都是 0</strong>，则成这样的矩阵为 <strong>行最简型矩阵</strong></li>
</ol>
<h3 id="2-9-2-矩阵的秩"><a href="#2-9-2-矩阵的秩" class="headerlink" title="2.9.2 矩阵的秩"></a>2.9.2 矩阵的秩</h3><p>定义：在矩阵A中，<strong>不为零子式的最高阶数称为A的秩</strong>，r（A）=min（m，n），则A为满秩矩阵，否则为降秩矩阵</p>
<p>性质：</p>
<ul>
<li>任意矩阵A与秩满足： 0&lt;=r(A)&lt;=min(m,n)</li>
<li><p>矩阵A可逆，则|A|不为零，则与 r（A）=n 形成<strong>充分必要条件</strong>，矩阵A为<strong>满秩矩阵</strong></p>
<ul>
<li><strong>n阶方阵可逆的充要条件：r(A)=n</strong></li>
</ul>
</li>
<li><p><strong>行阶梯形矩阵的秩等于它非零行的行数或者首非零元的个数</strong></p>
</li>
</ul>
<p>求矩阵秩的一般方法：<strong>用初等变换将矩阵转换为阶梯型矩阵</strong></p>
<p>关于秩的相关结论：</p>
<ol>
<li>矩阵A的 n 阶子式全为0，则 r(A)&lt;n</li>
<li>矩阵A的 n 阶子式全不为0，则 r(A)&gt;=n</li>
<li>若矩阵A与B等价，则 r(A)=r(B)</li>
<li>若矩阵Q，P可逆，则 r(PA)=r(AQ)=r(PAQ)=r(A)</li>
</ol>
<h3 id="2-9-3-分块矩阵"><a href="#2-9-3-分块矩阵" class="headerlink" title="2.9.3 分块矩阵"></a>2.9.3 分块矩阵</h3><hr>
<h1 id="3-向量组的线性相关性"><a href="#3-向量组的线性相关性" class="headerlink" title="3. 向量组的线性相关性"></a>3. 向量组的线性相关性</h1><p>向量的线性运算</p>
<p><strong>线性方程组的向量形式： a1x1+a2x2+a3x3+ … a4x4=B，借助向量可以讨论线性方程组</strong></p>
<h2 id="3-1-向量组的线性关系"><a href="#3-1-向量组的线性关系" class="headerlink" title="3.1 向量组的线性关系"></a>3.1 向量组的线性关系</h2><h3 id="3-1-1-线性组合与线性表示"><a href="#3-1-1-线性组合与线性表示" class="headerlink" title="3.1.1 线性组合与线性表示"></a>3.1.1 线性组合与线性表示</h3><p>定义：设 n维向量组 a1，a2，a3 ，B</p>
<ol>
<li><p>若k1，k2，k3为任意一组常数，则称 k1a1+k2a2+k3a3…+k4a4为向量组 a1+a2+a3的一个<strong>线性组合</strong></p>
</li>
<li><p>若k1，k2，k3为任意一组常数，使得 B=k1a1+k2a2+k3a3+…knan成立，则称B可由向· 量组<strong>线性表示</strong></p>
</li>
</ol>
<p><strong>向量B是否可由a1,a2,a3,an线性表示的方法：判断线性方程组k1a1+k2a2+knan是否有解</strong></p>
<h3 id="3-1-2-线性相关与线性无关"><a href="#3-1-2-线性相关与线性无关" class="headerlink" title="3.1.2 线性相关与线性无关"></a>3.1.2 线性相关与线性无关</h3><ol>
<li>若存在一组<strong>不全为零</strong>的数 k1,k2,k3,kn 使得 k1a1+k2a2+…+knan =0 成立，则称a1,a2,a3是<strong>线性相关</strong>的</li>
<li>当且仅当 k1,k2,k3,kn <strong>全为零</strong> 使得 k1a1+k2a2+…+knan =0 成立，则称a1,a2,a3是<strong>线性无关</strong>的</li>
</ol>
<p>简单来说：</p>
<ol>
<li><strong>线性相关：有非零解</strong></li>
<li><strong>线性无关：只有零解</strong></li>
</ol>
<p><strong>判断一个向量组的线性关系的方法：</strong></p>
<ol>
<li>令 k1a1+k2a2+…+knan =0，求出 k1,k2,k3的值</li>
<li><strong>如果全为零：线性无关；不全为零：线性相关</strong></li>
</ol>
<hr>
<h3 id="3-1-3-线性相关性结论-重要"><a href="#3-1-3-线性相关性结论-重要" class="headerlink" title="3.1.3 线性相关性结论(重要)"></a>3.1.3 线性相关性结论(重要)</h3><ul>
<li><strong>s个n维 即n*s形式的矩阵：</strong>  线性方程组<strong>线性相关的充要条件是齐次线性方程组有非零解</strong>，<strong>线性无关的充要条件是齐次线性方程组只有零解</strong><ul>
<li><strong>n个n维 即方阵：向量组线性相关的充要条件是行列式的值为0；线性无关的充要条件是行列式的值不为0.</strong></li>
<li><strong>向量组所含向量的个数大于维数，向量组一定线性相关</strong></li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>方阵形式：直接判断行列式的值是否为零，线性相关D为0，线性无关D不为0</li>
<li>行数大于列数的矩阵：判断齐次线性方程组的解，线性相关有非零解，线性无关只有零解</li>
<li>列数大于行数的矩阵：向量个数大于维数，一定线性相关</li>
</ol>
</blockquote>
<ul>
<li>向量组 a1  a2  am线性<strong>相关</strong>的充分必要条件是：其中至少有一个向量可由其余m -1 个向量线性表示<ul>
<li>向量组 a1  a2  am线性<strong>无关</strong>的充分必要条件是：其中每一个向量都不能由其余m -1 个向量线性表示</li>
</ul>
</li>
<li>若向量组 a1  a2  am线性无关，而向量组 a1  a2  a3 B线性相关，<strong>则 B可由 a1  a2  a3 线性表示，且表达式唯一</strong></li>
<li>若部分线性相关，则整个向量组也线性相关<ul>
<li>若整体线性无关，则任意一个部分也线性无关</li>
</ul>
</li>
<li>如果n维向量组 a1  a2  an线性无关，则在每一个向量上都添加 m 个分量，得到的 <strong>n+m 维接长的向量组也线性无关</strong><ul>
<li>如果n维向量组 a1  a2  an线性相关，则在每一个向量上都减去 m 个分量，得到的 <strong>n-m 维截断的向量组也线性相关</strong></li>
</ul>
</li>
</ul>
<h2 id="3-2-向量组的秩"><a href="#3-2-向量组的秩" class="headerlink" title="3.2 向量组的秩"></a>3.2 向量组的秩</h2><h3 id="3-2-1-向量组的极大无关组"><a href="#3-2-1-向量组的极大无关组" class="headerlink" title="3.2.1 向量组的极大无关组"></a>3.2.1 向量组的极大无关组</h3><p>定义：设向量组T： a1 ,  a2 , a3 … an 中有一部分向量组 a1  a2   a3   ar （r&lt;n）满足</p>
<ol>
<li>a1 a2 a3  ar<strong>线性无关</strong></li>
<li>在向量组T中除去（1-r）任取一个向量 ai，<strong>满足 a1 a2  a3 ar，ai 线性相关</strong>，则称 a1  a2  a3  ar是向量组T的一个<strong>极大线性无关组</strong>。简称为极大无关组</li>
</ol>
<p>根据上节的结论:</p>
<blockquote>
<p>若向量组 a1  a2  am线性无关，而向量组 a1  a2  a3 B线性相关，<strong>则 B可由 a1  a2  a3 线性表示，且表达式唯一</strong></p>
</blockquote>
<p>可得：<strong>向量组T中任意向量 ai 都可由 a1  a2   a3   ar线性表示</strong></p>
<p>极大无关组不一定是唯一的，只含零向量的向量组没有极大无关组</p>
<hr>
<p>定义2：设有两个向量组1，2，向量组2中的每一个元素都可由向量组1线性表示，则<strong>称向量组2可由向量组1线性表示</strong>，否则称不可线性表示。</p>
<ul>
<li>若两个向量组1和2可以<strong>互相</strong>线性表示，则称他们<strong>等价</strong></li>
</ul>
<p>定理：</p>
<ul>
<li><strong>若向量组1可以由向量组2线性表示，且向量组1的元素个数大于向量组2的元素个数，则向量组1线性相关</strong></li>
</ul>
<h3 id="3-2-2-向量组的秩的定义"><a href="#3-2-2-向量组的秩的定义" class="headerlink" title="3.2.2 向量组的秩的定义"></a>3.2.2 向量组的秩的定义</h3><p>定义： 向量组T的极大无关组所包含向量的个数，称为向量组的的秩</p>
<p>定理：</p>
<ul>
<li>向量组 a1 a2  as<strong>线性无关</strong>的充要条件是 r(a1 a2 as)=s，即<strong>它的秩等于它所包含的向量的个数</strong></li>
<li>相互等价的向量组的秩相等</li>
<li><strong>如果两个向量组的秩相等，且其中一个向量组可由另一个线性表示，则两个向量组等价</strong></li>
</ul>
<blockquote>
<ol>
<li>秩的个数等于向量的个数，线性无关</li>
<li>秩的个数小于向量的个数，线性相关</li>
</ol>
</blockquote>
<p>行向量组与列向量组：</p>
<ul>
<li>行向量组的秩为<strong>行秩</strong>，列向量组的秩为<strong>列秩</strong></li>
<li><strong>行秩=列秩=矩阵的秩</strong></li>
</ul>
<p><strong>求向量组极大无关组的方法：先将列向量组构成矩阵A，然后对A实行初等行变换，把A化为行最简型矩阵，由行最简型矩阵列之间的关系，确定原向量组间的线性关系，从而确定极大无关组。</strong></p>
<h2 id="3-3-向量空间"><a href="#3-3-向量空间" class="headerlink" title="3.3 *向量空间"></a>3.3 *向量空间</h2><hr>
<h1 id="4-线性方程组"><a href="#4-线性方程组" class="headerlink" title="4. 线性方程组"></a>4. 线性方程组</h1><p>阶梯型方程组：对线性方程组做初等变换所得到的就是<strong>阶梯型方程组</strong></p>
<ul>
<li>系数矩阵：由未知数的系数所构成的矩阵称为线性方程组的<strong>系数矩阵</strong></li>
<li>线性方程组的系数和常数项所构成的矩阵称为线性方程组的<strong>增广矩阵</strong></li>
</ul>
<h2 id="4-1-消元法解线性方程组"><a href="#4-1-消元法解线性方程组" class="headerlink" title="4.1 消元法解线性方程组"></a>4.1 消元法解线性方程组</h2><ol>
<li><p>就是对方程组的增广矩阵做初等行变换，化为<strong>阶梯型矩阵</strong>，从而得到方程组的解</p>
</li>
<li><p>对增广矩阵化为<strong>行最简型矩阵</strong>，更容易求解</p>
</li>
</ol>
<blockquote>
<p>有无解的判定：</p>
<p>增广矩阵的秩 = 系数矩阵的秩 = 未知量的个数，则方程组 Ax=b 具有<strong>唯一解</strong></p>
<p>增广矩阵的秩 不等于 系数矩阵的秩，则方程组Ax=b<strong>无解</strong>，存在一行，满足系数项全为零，而常数项不为零</p>
</blockquote>
<h2 id="4-2-非齐次线性方程组解的判定"><a href="#4-2-非齐次线性方程组解的判定" class="headerlink" title="4.2 非齐次线性方程组解的判定"></a>4.2 非齐次线性方程组解的判定</h2><ul>
<li>线性方程组 Amn <em> X=b <em>*有解</em></em>的 充要条件 是 r（A，b）= r（A）</li>
<li>当线性方程组 Amn <em> X=b 有解时：<em>*r 为秩，n为系数项数，即未知量的个数</em></em><ul>
<li>若  r（A，b）= r（A）=<strong>r = n</strong>，方程组有<strong>唯一解</strong></li>
<li>若  r（A，b）= r（A）=<strong>r &lt; n</strong>，方 程组有<strong>无穷多解</strong></li>
</ul>
</li>
<li>同理， Amn <em> X =b <em>*无解</em></em>的充要条件是 r（A，b）!=r（A）</li>
</ul>
<h2 id="4-3-齐次线性方程组解的判定"><a href="#4-3-齐次线性方程组解的判定" class="headerlink" title="4.3 齐次线性方程组解的判定"></a>4.3 齐次线性方程组解的判定</h2><p>齐次线性方程组一定满足：r（A，b）=r（A）</p>
<ul>
<li>齐次线性方程组Amn <em> X=0 <em>*只有零解的充要条件是 r（A）= n</em></em></li>
<li>齐次线性方程组Amn <em> X=0 <em>*有非零解的充要条件是 r（A）&lt; n</em></em>（有非零解即为无穷多解）</li>
</ul>
<h2 id="4-4-齐次线性方程组的解的结构"><a href="#4-4-齐次线性方程组的解的结构" class="headerlink" title="4.4 齐次线性方程组的解的结构"></a>4.4 齐次线性方程组的解的结构</h2><p>解向量的概念</p>
<p><strong>若齐次线性方程组有非零解，则它会有无穷多解，这些解组成一个n维向量组，若能求出这个向量组的一个极大无关组，则就能用它来表示它的全部解，这个极大无关组称为齐次线性方程组的基础解系</strong></p>
<p>齐次线性方程组有非零解，则它一定有基础解系。</p>
<ul>
<li><p>定理1：<strong>如果齐次线性方程组Amn <em> X=0 的系数矩阵A的秩 r（A）= r &lt; n，则Amn </em> X=0 的基础解系中有 n-r个解向量</strong></p>
</li>
<li><p><strong>齐次线性方程组的基础解系求解</strong></p>
</li>
<li><p><strong>非齐次线性方程组的基础解系求解</strong></p>
</li>
</ul>
<h2 id="4-5-非齐次线性方程组的解的结构"><a href="#4-5-非齐次线性方程组的解的结构" class="headerlink" title="4.5 非齐次线性方程组的解的结构"></a>4.5 非齐次线性方程组的解的结构</h2><p>非齐次线性方程组的解的结构为：非齐次线性方程组的特解 + 齐次线性方程组的通解。</p>
<hr>
<blockquote>
<p>求线性方程组通解的一般步骤</p>
<p>齐次线性方程组：</p>
<ol>
<li>对于增广矩阵化简为 <strong>行最简型矩阵</strong></li>
<li>判断解的情况并且得到解向量的个数=n-r</li>
<li>通过行最简矩阵得到<strong>自由未知量</strong>，首非零元与自由未知量确定方程，求方程解，得到各个未知量的解，并且得到每一个<strong>基础解系</strong></li>
<li>通解为 各个基础解系的k倍和</li>
</ol>
<p>非齐次线性方程组：</p>
<ol>
<li>步骤与上面基本一致，但是通解为：特解 + 导出组（导出组指的是常数项为0）的基础解系</li>
</ol>
</blockquote>
<hr>
<h1 id="5-矩阵相似与对角化"><a href="#5-矩阵相似与对角化" class="headerlink" title="5. 矩阵相似与对角化"></a>5. 矩阵相似与对角化</h1><h2 id="5-1-特征值与特征向量"><a href="#5-1-特征值与特征向量" class="headerlink" title="5.1 特征值与特征向量"></a>5.1 特征值与特征向量</h2><p>定义1：<strong>设A=（aij）nn为n阶实方阵，如果存在某个非零 r 和某个n维非零列向量 p 满足： Ap=rp，则 r 是A 一个特征值，p是A的属于特征值为r 的一个特征向量</strong></p>
<p>定义2：带参数r的n阶方阵称为A的<strong>特征方阵</strong>；它的行列式称为A的<strong>特征多项式</strong>；|rE-A|=0称为A的<strong>特征方程</strong></p>
<p>求解特征值与特征向量的方法：</p>
<ul>
<li><strong>n阶实方阵的特征值就是它的特征方程的n个根</strong></li>
<li><strong>任意取定一个特征值，其对应特征向量就是相应齐次线性方程组（rE-A）x=0 的所有非零解</strong>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </li>
</ul>
<hr>
<h2 id="5-2-特征值与特征向量的若干结论"><a href="#5-2-特征值与特征向量的若干结论" class="headerlink" title="5.2 特征值与特征向量的若干结论"></a>5.2 特征值与特征向量的若干结论</h2><ol>
<li><p><strong>实方阵的特征值未必是实数，特征向量也未必是实向量</strong></p>
</li>
<li><p>上下三角矩阵的特征值就是它的<strong>全体对角元素</strong></p>
</li>
<li>一个向量p不可能是属于同一个方阵A的不同特征值的特征向量</li>
<li>n阶方阵和它的转置具有相同的特征值</li>
<li>r1  r2  r3 为A的全体特征值则必有：即<strong>特征值之和等于对角线元素之和（迹）</strong>，<strong>特征值之积等于行列式的值</strong></li>
</ol>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}\lambda_{i}=\sum_{i=1}^{n}a_{ii}=tr(A) \qquad \prod_{i=1}^{n}\lambda_{i}=|A|</script><ol>
<li><strong>只要 r 是A的特征值，那么 f(r) 一定是 f(A) 的特征值</strong></li>
</ol>
<hr>
<h3 id="5-2-1-求特征值和特征向量的一般方法"><a href="#5-2-1-求特征值和特征向量的一般方法" class="headerlink" title="5.2.1 求特征值和特征向量的一般方法"></a>5.2.1 求特征值和特征向量的一般方法</h3><p>步骤：</p>
<ol>
<li><p>求出特征值，检查特征值之和是否等于行列式对角线元素之和，即<strong>迹</strong>，特征值之积是否等于行列式的值。</p>
</li>
<li><p>属于特征值的特征向量全体是 …   </p>
</li>
</ol>
<h2 id="5-3-相似矩阵与可对角化的条件"><a href="#5-3-相似矩阵与可对角化的条件" class="headerlink" title="5.3 相似矩阵与可对角化的条件"></a>5.3 相似矩阵与可对角化的条件</h2><p>定义1： A与B是n阶方阵，如果存在一个n阶可逆矩阵P，使得 P-1AP=B，则称A与B相似，记作A~B</p>
<p><strong>相似矩阵具有对称性，传递性，反身性</strong></p>
<p>两矩阵相似的特征：</p>
<ol>
<li>相同的特征值</li>
<li>相同的行列式值</li>
<li>迹相等，即对角线元素之和相同</li>
<li>秩相同</li>
</ol>
<h3 id="5-3-1-矩阵可对角化"><a href="#5-3-1-矩阵可对角化" class="headerlink" title="5.3.1 矩阵可对角化"></a>5.3.1 矩阵可对角化</h3><p><strong>定理3：n阶方阵相似于n阶对角矩阵的充要条件：A有n个线性无关的特征向量</strong></p>
<p><strong>推论：如果n阶矩阵A有n个互不相同的特征值 r1 r2  r3  r4 … rn，则A与对角矩阵 相似，并且对角矩阵的对角线元素为 r1 r2  r3  r4 … rn。</strong></p>
<p>n阶矩阵与对角矩阵相似的充分必要条件是：对于A的每一个n重特征值，齐次线性方程组（rE-A）x=0 的基础解系中恰含n个向量</p>
<h2 id="5-4-向量的内积与正交矩阵"><a href="#5-4-向量的内积与正交矩阵" class="headerlink" title="5.4 向量的内积与正交矩阵"></a>5.4 向量的内积与正交矩阵</h2><h3 id="5-4-1-内积"><a href="#5-4-1-内积" class="headerlink" title="5.4.1 内积"></a>5.4.1 内积</h3><p>概念：两个矩阵的对应元素相乘再相加，得到的一个<strong>数值</strong>，是两个矩阵的内积，记作：[A，B]</p>
<ul>
<li>施瓦茨不等式</li>
</ul>
<p>定义2<strong>：向量的内积开根号 叫做向量的长度，向量的长度用||A||表示</strong>，例如：a=(a1,a2,a3) ， ||a||=根号下[a,a]，</p>
<ul>
<li>若 ||a||=1，称a为单位向量</li>
</ul>
<h3 id="5-4-2-正交向量组"><a href="#5-4-2-正交向量组" class="headerlink" title="5.4.2 正交向量组"></a>5.4.2 正交向量组</h3><p>定义：若[a,b]=0，则向量a，b正交</p>
<p><strong>由非零向量两两正交组成的向量组称为正交向量组</strong></p>
<ul>
<li>正交向量组内每一个ai一定是线性无关的</li>
</ul>
<hr>
<p>施密特正交化：正交化 -&gt; 单位化</p>
<h1 id="6-二次型"><a href="#6-二次型" class="headerlink" title="6. 二次型"></a>6. 二次型</h1><p>含n个变量的 二次齐次多项式称为一个n元二次型，简称二次型</p>
<ul>
<li>令A为一个实对称矩阵，二次型式用矩阵表示为 f=x^T Ax  <ul>
<li>A称为二次型f的矩阵，对称阵A的秩为二次型f的秩</li>
<li>二次型与对称阵具有一一对应的关系，<strong>一个二次型f由其对应的实对称矩阵A唯一确定。当给定了二次型f后，便可以确定其对应的实对称矩阵A</strong><ul>
<li>A的对角线元素为：aii为xi ^2项的<strong>系数</strong></li>
<li>A的其他元素为： aij = aji 为 xij 项的<strong>系数的 1/2</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-1-可逆变换"><a href="#6-1-可逆变换" class="headerlink" title="6.1 可逆变换"></a>6.1 可逆变换</h2><p>若C 是可逆矩阵，x=Cy为可逆线性变换；若C是正交矩阵，则x=Cy为正交线性变换</p>
<p><strong>定义： 如果A，B均为n阶方阵，若存在可逆矩阵C，使得 CT A C =B，则称A与B合同</strong></p>
<ul>
<li>如果A为对称矩阵，AB合同，则B也为对称矩阵</li>
<li>A与B合同，则R（A）=R（B）</li>
<li>合同具有传递性</li>
</ul>
<h2 id="6-2-二次型的标准型"><a href="#6-2-二次型的标准型" class="headerlink" title="6.2 二次型的标准型"></a>6.2 二次型的标准型</h2><p><strong>定义：只含平方项的 二次型称为二次型的标准型</strong></p>
<p>正交变换法化二次型为标准型的方法：</p>
<ol>
<li>写出二次型的矩阵A，求其特征值 </li>
<li>求出特征值对应的特征向量，并且将他们正交单位化</li>
<li>将正交单位化后的特征向量依次作为列向量构成正交矩阵P。</li>
<li>做正交变换 x=Py，得二次型的标准型</li>
</ol>
<blockquote>
<p>正交单位化的时候：</p>
<ol>
<li>如果对应不同的特征值，所以他们正交，直接单位化即可</li>
<li>如果对应相同的特征值，所以要首先正交化，然后再单位化</li>
</ol>
</blockquote>
<h3 id="6-2-1-配方法化二次型为标准型"><a href="#6-2-1-配方法化二次型为标准型" class="headerlink" title="6.2.1 配方法化二次型为标准型"></a>6.2.1 配方法化二次型为标准型</h3><h3 id="6-2-2-初等变换化二次型为标准型"><a href="#6-2-2-初等变换化二次型为标准型" class="headerlink" title="6.2.2 初等变换化二次型为标准型"></a>6.2.2 初等变换化二次型为标准型</h3><h2 id="6-3-正定二次型"><a href="#6-3-正定二次型" class="headerlink" title="6.3 正定二次型"></a>6.3 正定二次型</h2><p>判别方法：f=xT A x正定的充要条件是 矩阵A的特征值都是正数</p>
<p><strong>实对阵矩阵A正定的充要条件是 A的各阶顺序子式都大于0</strong></p>
<hr>
<h1 id="待完善"><a href="#待完善" class="headerlink" title="待完善 ~~~"></a>待完善 ~~~</h1>]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>A星寻路算法详解</title>
    <url>/2023/03/01/A%E6%98%9F%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>@[toc]</p>
<h2 id="三种寻路算法"><a href="#三种寻路算法" class="headerlink" title="三种寻路算法"></a>三种寻路算法</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pqNjY2NmRqZGJiZC9hcnRpY2xlL2RldGFpbHMvMTI2MjA1Nzcw">深度寻路算法：不一定能找到最佳路径，但是寻路快速，只能走直线。<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pqNjY2NmRqZGJiZC9hcnRpY2xlL2RldGFpbHMvMTI2MjY1MTk5">广度寻路算法：一定能找到最短路径，但是开销大，时间慢，只能走直线。<i class="fa fa-external-link-alt"></i></span></li>
<li><strong>A星寻路算法</strong>（常用）：一定能找到最短路径，可以走直线和斜线，而且开销较小，常用于大型地图的寻路</li>
</ul>
<h1 id="A星寻路算法"><a href="#A星寻路算法" class="headerlink" title="A星寻路算法"></a>A星寻路算法</h1><h2 id="A星寻路算法思想"><a href="#A星寻路算法思想" class="headerlink" title="A星寻路算法思想"></a>A星寻路算法思想</h2><blockquote>
<p>引入： 狼吃羊模型。</p>
<p>狼捕猎羊：如果抓到了就加100分；如果狼不动，每分钟减2分；如果狼抓捕时会跑，跑步每分钟减5分；</p>
<p>​     狼会饿 ，饿的时候每分钟减10分。 有一个积分的概念在这里面。结果会发现<strong>狼会站在原地不动</strong>。</p>
<p>​    因为狼直到，抓住羊很困难，跑步时会扣分，饿时会扣分，不动时也会扣分。但是人工智能狼计算出了站着不动时扣分的代价最低，而干其他事代价都高，因此狼会自动选择代价最低的方式，一动不动</p>
<p>​    之后又加了设定：原地不动每分钟也扣分，而且是线性扣分。结果你会发现<strong>狼从一开始就会自杀</strong>。</p>
<p>同理，<strong>自杀是代价最小的选择</strong>（即分数最高，如果你干其他的事，则可能会负分，所以狼会选择自杀）。</p>
</blockquote>
<p>A星寻路算法也引入了这一概念，即通过<strong>计算和量化行走的各个方向的代价</strong>，来<strong>选择最优路径</strong></p>
<ul>
<li><strong><em>公式： f = g + h</em></strong></li>
<li>f： 设定其为<strong>最终评估代价</strong></li>
<li>g：当前点走到下一点的<strong>付出的代价</strong></li>
<li>h：当前点到终点的<strong>预期代价</strong></li>
<li>通过比较各条路线的最终代价，选择<strong>最小代价</strong>，即为合适的路径，也为<strong>最短路径</strong>。</li>
</ul>
<h2 id="A星寻路准备"><a href="#A星寻路准备" class="headerlink" title="A星寻路准备"></a>A星寻路准备</h2><p>地图行列数，方向枚举，地图，辅助地图的设计等在此不描述，具体请看之前我写的前两种寻路算法的博客。<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pqNjY2NmRqZGJiZC9hcnRpY2xlL2RldGFpbHMvMTI2MjY1MTk5P3NwbT0xMDAxLjIwMTQuMzAwMS41NTAy">广度寻路算法<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pqNjY2NmRqZGJiZC9hcnRpY2xlL2RldGFpbHMvMTI2MjA1NzcwP3NwbT0xMDAxLjIwMTQuMzAwMS41NTAy">深度寻路算法<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><strong>记录坐标点的类型</strong>，GetH和GetF函数即为计算各种代价的函数，稍后会介绍。一个重载用来比较当前点是否到达终点</li>
</ul>
<blockquote>
<p>h表示当前点到终点的预期代价，因此我们每次移动一步，都需要求出 h，而h的计算我们可以直接通过数格子来获得，即水平，竖直个有几个格子，这便是<strong>预期的代价</strong><br>g表示走到每一点的代价，因此每走一个方向，记录这个方向的代价， 最后选择代价最小的方向即可，g可以通过遍历八个方向来记录<br>f =g + h</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mypoint</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> row;</span><br><span class="line">	<span class="type">int</span> col;</span><br><span class="line">	<span class="type">int</span> f, g, h;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">return</span> (pos.row == row &amp;&amp; pos.col == col);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetH</span><span class="params">(<span class="type">const</span> Mypoint&amp; Begpos, <span class="type">const</span> Mypoint&amp; Endpos)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">abs</span>(Begpos.col - Endpos.col);<span class="comment">//计算水平差距</span></span><br><span class="line">		<span class="type">int</span> y = <span class="built_in">abs</span>(Begpos.row - Endpos.row);<span class="comment">//计算垂直差距</span></span><br><span class="line">		h = x + y;<span class="comment">//计算总的差距</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetF</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		f = g + h;<span class="comment">//计算f</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>存储位置节点的树结构</strong>，含有构造函数用来构建树节点，<strong>vector数组</strong>存储多个节点：因为一个父亲会有多个孩子的情况。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树结构存储节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">	Mypoint pos;<span class="comment">//当前点坐标</span></span><br><span class="line">	TreeNode* pParent;<span class="comment">//当前点的父节点</span></span><br><span class="line">	vector&lt;TreeNode*&gt; pChild;	<span class="comment">//存储当前点的所有孩子节点</span></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pos = pos;</span><br><span class="line">		pParent = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>判断是否能走的函数</strong>，用于判断地图某个点是否能走，即不为墙，没越界，没走过，则能走。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断某个点能否走</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CanWalk</span><span class="params">(<span class="type">int</span> map[ROW][COL], <span class="type">bool</span> vis[ROW][COL], <span class="type">const</span> Mypoint&amp; pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果越界，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (pos.row &lt; <span class="number">0</span> || pos.col &lt; <span class="number">0</span> || pos.row &gt;= ROW || pos.col &gt;= COL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是墙，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (map[pos.row][pos.col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果已经走过，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (vis[pos.row][pos.col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//否则能走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数据的准备</strong></li>
</ul>
<ol>
<li>起点与终点的坐标</li>
<li>树根节点，用于保存寻路的<strong>树结构</strong></li>
<li>buff数组来记录每一个孩子节点，<strong>用来确定下一步该走的点</strong></li>
<li>vis标记数组，不能重复走</li>
<li>当前点与试探点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//地图，1表示墙，0表示路径</span></span><br><span class="line">	<span class="type">int</span> map[ROW][COL] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//起始点和终点</span></span><br><span class="line">	Mypoint Begpos = &#123; <span class="number">1</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	Mypoint Endpos = &#123; <span class="number">6</span>,<span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//标记有没有走过</span></span><br><span class="line">	<span class="type">bool</span> vis[ROW][COL] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建树根，即根节点</span></span><br><span class="line">	TreeNode* pRoot = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(Begpos);</span><br><span class="line"></span><br><span class="line">	vector&lt;TreeNode*&gt; buff;	<span class="comment">//存储孩子节点的数组</span></span><br><span class="line"></span><br><span class="line">	TreeNode* pCurrent = pRoot;	<span class="comment">//记录当前点</span></span><br><span class="line">	TreeNode* pTemp = <span class="literal">nullptr</span>;	<span class="comment">//试探节点,用于试探下一个位置的点</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> isFindEnd = <span class="literal">false</span>;<span class="comment">//终点标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="A星寻路过程（图例）"><a href="#A星寻路过程（图例）" class="headerlink" title="A星寻路过程（图例）"></a>A星寻路过程（图例）</h2><p>假定<strong>直着走的代价为10，斜着走的代价为14</strong></p>
<ul>
<li><p>首先计算起点位置周围八个方向<strong>付出代价</strong>（蓝色），此代价为<strong>付出的代价 g</strong>。<br><img src="https://img-blog.csdnimg.cn/15215e45fdd948fda712c731eb17c42f.png" alt="在这里插入图片描述"></p>
</li>
<li><p>然后再计算<strong>起点到终点的代价</strong>（如何计算：数格子即可，某个点到终点的格子数，只能行列，不能斜着），此代价为<strong>预期代价h</strong>，可以发现 <strong>最终代价=付出+预期</strong>，可以得到一个<strong>最小的代价点</strong>，即<strong>右下角的斜着的点</strong>。</p>
<p><strong>这个点即是我们下一步要走的点</strong>。<strong>依次类推，在下个点上，再次计算周围代价最小的点，然后再次移动</strong></p>
</li>
</ul>
<hr>
<p>upd： 2023. 2.22 新增一个图<br><img src="https://img-blog.csdnimg.cn/a88609b83bba49f49c4a55de372be256.png" alt="在这里插入图片描述"></p>
<hr>
<ul>
<li><p>注意：标记起始点和每个移动到的点为<strong>已经走过点</strong>，即下一次不会重复移动到这个点。</p>
</li>
<li><p>在移动到的点处（代价最小点），继续遍历八个方向，除了<strong>墙壁</strong>和<strong>已经走过点</strong>，继续计算最终代价，<strong>找到最终代价小的点，移动。</strong><br><img src="https://img-blog.csdnimg.cn/29dbe25e620e46679e0b2e965afed765.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<ul>
<li>注意：如果你移动到了一个死胡同，则必须回退，<strong>如何回退</strong>?<br>我们事先准备了<strong>一个容器vector</strong>名字叫做 buff ，来<strong>存储我们每次遍历的方向的节点</strong>，即我们把每一个方向都创建一个节点，然后<strong>节点入树</strong>，<strong>节点再入容器</strong>，当我们走到死胡同时，<strong>通过找到容器内的最小元素</strong>（即是代价最小点，但是这个点是死胡同），<strong>然后把他删除</strong>，则 ==<strong>再次找一个代价最小点</strong>，<strong>然后移动到它那里去</strong>== 。<br><strong>如果地图没有终点，则可以想到，容器会一直删除，然后为空，此时则退出，没有终点。</strong></li>
</ul>
<hr>
<h2 id="A星寻路代码（完整）"><a href="#A星寻路代码（完整）" class="headerlink" title="A星寻路代码（完整）"></a>A星寻路代码（完整）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ROW = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> COL = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ZXDJ = <span class="number">10</span>;	<span class="comment">//直线代价</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> XXDJ = <span class="number">14</span>;	<span class="comment">//斜线代价</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Dir</span> &#123; p_up, p_down, p_left, p_right, p_lup, p_ldown, p_rup, p_rdown &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mypoint</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> row;</span><br><span class="line">	<span class="type">int</span> col;</span><br><span class="line">	<span class="type">int</span> f, g, h;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">return</span> (pos.row == row &amp;&amp; pos.col == col);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetH</span><span class="params">(<span class="type">const</span> Mypoint&amp; Begpos, <span class="type">const</span> Mypoint&amp; Endpos)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">abs</span>(Begpos.col - Endpos.col);<span class="comment">//计算水平差距</span></span><br><span class="line">		<span class="type">int</span> y = <span class="built_in">abs</span>(Begpos.row - Endpos.row);<span class="comment">//计算垂直差距</span></span><br><span class="line">		h = x + y;<span class="comment">//计算总的差距</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetF</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		f = g + h;<span class="comment">//计算f</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构存储节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">	Mypoint pos;<span class="comment">//当前点坐标</span></span><br><span class="line">	TreeNode* pParent;<span class="comment">//当前点的父节点</span></span><br><span class="line">	vector&lt;TreeNode*&gt; pChild;	<span class="comment">//存储当前点的所有孩子节点</span></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pos = pos;</span><br><span class="line">		pParent = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断某个点能否走</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CanWalk</span><span class="params">(<span class="type">int</span> map[ROW][COL], <span class="type">bool</span> vis[ROW][COL], <span class="type">const</span> Mypoint&amp; pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果越界，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (pos.row &lt; <span class="number">0</span> || pos.col &lt; <span class="number">0</span> || pos.row &gt;= ROW || pos.col &gt;= COL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是墙，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (map[pos.row][pos.col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果已经走过，不能走</span></span><br><span class="line">	<span class="keyword">if</span> (vis[pos.row][pos.col])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//否则能走</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//地图，1表示墙，0表示路径</span></span><br><span class="line">	<span class="type">int</span> map[ROW][COL] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//起始点和终点</span></span><br><span class="line">	Mypoint Begpos = &#123; <span class="number">1</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	Mypoint Endpos = &#123; <span class="number">6</span>,<span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//标记有没有走过</span></span><br><span class="line">	<span class="type">bool</span> vis[ROW][COL] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建树根，即根节点</span></span><br><span class="line">	TreeNode* pRoot = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(Begpos);</span><br><span class="line"></span><br><span class="line">	vector&lt;TreeNode*&gt; buff;	<span class="comment">//存储孩子节点的数组</span></span><br><span class="line"></span><br><span class="line">	TreeNode* pCurrent = pRoot;	<span class="comment">//记录当前点</span></span><br><span class="line">	TreeNode* pTemp = <span class="literal">nullptr</span>;	<span class="comment">//试探节点,用于试探下一个位置的点</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> isFindEnd = <span class="literal">false</span>;<span class="comment">//终点标记</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始寻路</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1. 某个点八个方向依次遍历 计算g代价</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//确定试探点的属性</span></span><br><span class="line">			pTemp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pCurrent-&gt;pos);</span><br><span class="line">			<span class="comment">//八个方向进行试探！</span></span><br><span class="line">			<span class="keyword">switch</span> (i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//直线代价</span></span><br><span class="line">			<span class="keyword">case</span> p_up:<span class="comment">//上</span></span><br><span class="line">				pTemp-&gt;pos.row--;</span><br><span class="line">				pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_down:<span class="comment">//下</span></span><br><span class="line">				pTemp-&gt;pos.row++;</span><br><span class="line">				pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_left:<span class="comment">//左</span></span><br><span class="line">				pTemp-&gt;pos.col--;</span><br><span class="line">				pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_right:<span class="comment">//右</span></span><br><span class="line">				pTemp-&gt;pos.col++;</span><br><span class="line">				pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//斜线代价</span></span><br><span class="line">			<span class="keyword">case</span> p_lup:<span class="comment">//左上</span></span><br><span class="line">				pTemp-&gt;pos.row--;</span><br><span class="line">				pTemp-&gt;pos.col--;</span><br><span class="line">				pTemp-&gt;pos.g += XXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_ldown:<span class="comment">//左下</span></span><br><span class="line">				pTemp-&gt;pos.row++;</span><br><span class="line">				pTemp-&gt;pos.col--;</span><br><span class="line">				pTemp-&gt;pos.g += XXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_rup:<span class="comment">//右上</span></span><br><span class="line">				pTemp-&gt;pos.row--;</span><br><span class="line">				pTemp-&gt;pos.col++;</span><br><span class="line">				pTemp-&gt;pos.g += XXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> p_rdown:<span class="comment">//右下</span></span><br><span class="line">				pTemp-&gt;pos.row++;</span><br><span class="line">				pTemp-&gt;pos.col++;</span><br><span class="line">				pTemp-&gt;pos.g += XXDJ;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断他们能不能走，能走的计算h及f 入树  存储在buff数组</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">CanWalk</span>(map, vis, pTemp-&gt;pos))</span><br><span class="line">			&#123;	<span class="comment">//能走</span></span><br><span class="line">				<span class="comment">//计算代价</span></span><br><span class="line">				pTemp-&gt;pos.<span class="built_in">GetH</span>(Begpos, Endpos);<span class="comment">//计算h代价</span></span><br><span class="line">				pTemp-&gt;pos.<span class="built_in">GetF</span>();<span class="comment">//得到最后的f代价，f=g+h </span></span><br><span class="line">				<span class="comment">//把能走的这个点存入树中</span></span><br><span class="line">				pCurrent-&gt;pChild.<span class="built_in">push_back</span>(pTemp);<span class="comment">//pTemp表示的就是下一个能走的点</span></span><br><span class="line">				pTemp-&gt;pParent = pCurrent;<span class="comment">//父子关系确定</span></span><br><span class="line">				<span class="comment">//存入数组</span></span><br><span class="line">				buff.<span class="built_in">push_back</span>(pTemp);</span><br><span class="line">				<span class="comment">//标记这个点走过</span></span><br><span class="line">				vis[pTemp-&gt;pos.row][pTemp-&gt;pos.col] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//不能走则删除pTemp，继续遍历下一个方向的点</span></span><br><span class="line">				<span class="keyword">delete</span> pTemp;</span><br><span class="line">				pTemp = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		遍历完八个方向后，找到最小代价点，并且移动，然后删除</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">auto</span> itMin =  <span class="built_in">min_element</span>(buff.<span class="built_in">begin</span>(), buff.<span class="built_in">end</span>(), [&amp;](TreeNode* p1, TreeNode* p2)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> p1-&gt;pos.f &lt; p2-&gt;pos.f;</span><br><span class="line">			&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//当前点移动到这个最小代价点</span></span><br><span class="line">		pCurrent = *itMin;</span><br><span class="line">		<span class="comment">//删除最小代价节点</span></span><br><span class="line">		buff.<span class="built_in">erase</span>(itMin);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//有没有到达终点</span></span><br><span class="line">		<span class="keyword">if</span> (pCurrent-&gt;pos == Endpos)</span><br><span class="line">		&#123;</span><br><span class="line">			isFindEnd = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//没有终点，自然一直删除节点，则buff为空</span></span><br><span class="line">		<span class="keyword">if</span> (buff.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isFindEnd)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到终点了!\n&quot;</span>;</span><br><span class="line">		<span class="keyword">while</span> (pCurrent)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pCurrent-&gt;pos.row &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pCurrent-&gt;pos.col &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">			pCurrent = pCurrent-&gt;pParent;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到终点!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终点row，col（7，7）：<br><img src="https://img-blog.csdnimg.cn/2f6b0a76593c489ea4ea769344cd20fa.png" alt="在这里插入图片描述"></p>
<p>终点row，col（6，5）<br><img src="https://img-blog.csdnimg.cn/ea18d5c7ee2e41eb820e65e6fd5e172f.png" alt="在这里插入图片描述"></p>
<hr>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>搜索与寻路</tag>
      </tags>
  </entry>
</search>
