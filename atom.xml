<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HugeYlh</title>
  
  <subtitle>����ֻӦ������,�˼��ѵü�����</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-02T04:39:57.683Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ylh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线性代数</title>
    <link href="http://example.com/2023/03/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>http://example.com/2023/03/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</id>
    <published>2023-03-02T04:37:40.000Z</published>
    <updated>2023-03-02T04:39:57.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p>行列式的定义：n*n个数字排成n行n列，叫做n阶行列式。</p><p>行列式的项数：</p><ol><li>2阶行列式有2项</li><li>3阶行列式有6项</li><li>4阶行列式有24项</li></ol><p>行列式按行展开</p><ul><li>行列式的值D &#x3D; 任意一行（列）元素*自己的<strong>代数余子式</strong>之和</li></ul><hr><p>异乘变零定理</p><ul><li>某行元素与另一行元素的代数余子式乘积之和&#x3D;0</li></ul><hr><p>拉普拉斯定理（k阶子式）</p><ul><li>k&#x3D;2<ul><li>2阶子式：取任意两行两列，交界的元素就是2阶子式</li><li>余子式：两行两列之外（剩余）的元素就是余子式</li><li>代数余子式：（-1）^（行1+行2+列1+列2）*余子式</li></ul></li></ul><p>拉普拉斯展开定理</p><ul><li>n阶行列式中，任意取定k行，由k行元素组成的所有<strong>k阶子式</strong>与<strong>代数余子式</strong>的乘积之和&#x3D;行列式的值（D）</li></ul><hr><p>行列式相乘：（同阶行列式）三阶行列式：</p><ul><li><p>第一行</p><ul><li>第一行元素*第一列元素，元素对应先相乘再相加</li><li>第一行元素*第二列元素，…</li><li>第一行元素*第三列元素，…</li></ul></li><li><p>第二行</p><ul><li>第二行元素*第一列元素，…</li><li>第二行元素*第二列元素，…</li><li>第二行元素*第三列元素，…</li></ul></li><li><p>第三行</p><ul><li>第三行元素*第一列元素，…</li><li>第三行元素*第二列元素，…</li><li>第三行元素*第三列元素，…</li></ul></li></ul><hr><p>行列式计算：</p><ul><li><p>化成上下三角</p></li><li><p>按行展开</p></li><li><p>制造<strong>行和</strong>：如图所示行列式</p></li></ul><p>$$<br>\left|\begin{matrix}<br>    x &amp; a &amp; a \<br>    a &amp; x &amp; a \<br>    a &amp; a &amp; x<br>   \end{matrix} \right|-&gt;<br>   (x+2a)\left|\begin{matrix}<br>    1 &amp; a &amp; a \<br>    1 &amp; x &amp; a \<br>    1 &amp; a &amp; x<br>   \end{matrix} \right| -&gt;<br>   (x+2a) \left|\begin{matrix}<br>    1 &amp; 0 &amp; 0 \<br>    1 &amp; x &amp; 0 \<br>    1 &amp; 0 &amp; x<br>   \end{matrix} \right|(用第一列乘-a加到后两列去，形成下三角求和)<br>$$</p><ul><li>加边法：不能改变原行列式的值</li></ul><p>$$<br>\left|\begin{matrix}<br>    1+a1 &amp; 1 &amp; 1 \<br>    1 &amp; 1+a2 &amp; 1 \<br>    1 &amp; 1 &amp; 1+a3<br>   \end{matrix} \right|-&gt;加边-&gt;</p><p>   \left|\begin{matrix}<br>    1 &amp; 1 &amp; 1 &amp; 1\<br>    0 &amp; 1+a1 &amp; 1 &amp; 1 \<br>    0 &amp; 1 &amp; 1+a2 &amp; 1 \<br>    0 &amp; 1 &amp; 1 &amp; 1+a3<br>   \end{matrix} \right|-&gt;第一行*-1加到下面的行上去-&gt;<br>   三叉型行列式<br>    \left|\begin{matrix}<br>    1 &amp; 1 &amp; 1 &amp; 1\<br>    -1 &amp; a1 &amp; 0 &amp; 0 \<br>    -1 &amp; 0 &amp; a2 &amp; 0 \<br>    -1 &amp; 0 &amp; 0 &amp; a3<br>   \end{matrix} \right|<br>   -&gt;第ai列*\frac{1}{ai}加到第一列上去-&gt;<br>   \left|\begin{matrix}<br>    1+\frac{1}{a1}+\frac{1}{a2}+…+\frac{1}{an} &amp; 1 &amp; 1 &amp; 1\<br>    0 &amp; a1 &amp; 0 &amp; 0 \<br>    0 &amp; 0 &amp; a2 &amp; 0 \<br>    0 &amp; 0 &amp; 0 &amp; a3<br>   \end{matrix} \right|<br>   形成上三角求和<br>$$</p><ul><li>范德蒙德行列式：<a href="https://baike.baidu.com/item/%E8%8C%83%E5%BE%B7%E8%92%99%E8%A1%8C%E5%88%97%E5%BC%8F/6081288?fromtitle=%E8%8C%83%E5%BE%B7%E8%92%99%E5%BE%B7%E8%A1%8C%E5%88%97%E5%BC%8F&fromid=15995336&fr=aladdin"><a href="https://baike.baidu.com/item/%E8%8C%83%E5%BE%B7%E8%92%99%E8%A1%8C%E5%88%97%E5%BC%8F/6081288?fromtitle=%E8%8C%83%E5%BE%B7%E8%92%99%E5%BE%B7%E8%A1%8C%E5%88%97%E5%BC%8F&fromid=15995336&fr=aladdin">范德蒙行列式_百度百科 (baidu.com)</a></a></li><li><strong>反对称行列式</strong><ul><li>主对角线全为零 aii&#x3D;-aii  aii&#x3D;0</li><li>对角线对称位置对应成<strong>相反数</strong> aij&#x3D;-aji</li><li>如果是<strong>奇数阶</strong>，则D&#x3D;0（利用转置性质）</li></ul></li><li><strong>对称行列式</strong><ul><li>主对角线元素没有要求</li><li>对角线对称位置对应成<strong>相等</strong> aij&#x3D;aji</li></ul></li></ul><hr><h2 id="克莱姆法则"><a href="#克莱姆法则" class="headerlink" title="克莱姆法则"></a>克莱姆法则</h2><p><strong>方程的个数等于未知量的个数</strong></p><ul><li><p>n个方程，n个未知量 </p></li><li><p>D !&#x3D;0 ： <strong>Xi&#x3D; Di&#x2F;D</strong>  </p></li><li><p><strong>Di 表示的是把系数行列式中第 i 列的元素用 常数项列 替代</strong></p></li></ul><p>定理与推论：</p><ul><li><p>定理1：系数行列式D不等于0，则方程组有唯一解，解为：x1&#x3D;D1&#x2F;D,x2&#x3D;D2&#x2F;D ….</p><ul><li>推论1：线性方程组<strong>无解或者有多组不同的解</strong>，<strong>系数行列式D&#x3D;0</strong></li></ul></li><li><p>定理2：齐次线性方程组的系数行列式 <strong>D!&#x3D;0</strong>，则齐次线性方程组<strong>只有零解</strong></p><ul><li>齐次线性方程组有非零解的<strong>充要条件</strong> &lt;&#x3D;&#x3D;&gt; D&#x3D;0</li></ul></li></ul><p>简单来说： </p><ol><li>D!&#x3D;0 ，只有零解</li><li>D&#x3D;0，有非零解</li></ol><hr><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><h3 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h3><ul><li><p>同型矩阵才能相加减</p></li><li><p>对应行对应列的元素相加即可</p></li></ul><h3 id="数乘运算"><a href="#数乘运算" class="headerlink" title="数乘运算"></a>数乘运算</h3><ul><li>把矩阵的每一个元素都乘以k</li><li>矩阵的加减法与矩阵的数乘运算统称为<strong>矩阵的线性运算</strong></li></ul><h3 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h3><p>定义： 设A&#x3D;(aij)m<em>s， B&#x3D;(bij)s * n ,则C&#x3D;(cij)m</em>n&#x3D;AB</p><ul><li><p>只有当左边矩阵A的行数等于右边矩阵B的列数才能做乘法运算。</p></li><li><p>相乘后，结果矩阵的行数等于左边矩阵A的行数，列数等于右边矩阵B的列数。</p></li><li><p>矩阵cij的元素等于矩阵A的第i行与矩阵B第j列元素相乘后相加。</p></li><li><p>矩阵乘法与普通乘法运算规则不同</p></li><li><p>若矩阵满足AB&#x3D;BA，则A和B是可交换的，仅当A和B可交换时，才满足交换律，结合律等数学公式</p></li></ul><h3 id="矩阵的幂运算"><a href="#矩阵的幂运算" class="headerlink" title="矩阵的幂运算"></a>矩阵的幂运算</h3><ul><li>将k个Aij连乘即为A的k次幂</li></ul><h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h2><ul><li>将矩阵Aij转换为Aji，即行列互换即为A的转置</li><li>（AB）的转置 &#x3D; B转置*A转置</li><li>A的转置等于A，则A是对称矩阵</li><li>A的转置等于-A，则A是反对称矩阵</li></ul><h2 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h2><ul><li>N阶方阵的所有元素（Aij）n*n 按照原来的位置构成的的行列式，称为方阵A的行列式，记作 |A|或者 detA</li><li>方阵行列式：是一个数；方阵：是一个数表</li><li>方阵行列式的性质</li><li>A的n阶方阵，若|A|!&#x3D;0，则A为非奇异矩阵，当 |A|&#x3D;0，则A为奇异矩阵</li></ul><h2 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h2><ul><li><p>A&#x3D;（aij）n*n 是n阶方阵，则行列式 |A|中的每个元素aij的<strong>代数余子式</strong>Aij所构成的矩阵称为矩阵A的伴随矩阵</p></li><li><p><strong>A*在（i，j）上的位置元素等于 A在 （j，i）上的位置的元素的代数余子式！！！！！！！</strong></p></li><li><p>伴随的一般求法：</p><ul><li>二阶矩阵的伴随： 对角线元素互换，反对角线添负号</li><li>三阶矩阵的伴随：将矩阵<strong>转置后</strong>求<strong>代数余子式</strong></li></ul></li><li><p>A是n阶方阵，A*是A的伴随矩阵，则满足： AA *&#x3D;A *A&#x3D;|A|E</p></li></ul><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><ul><li>对于n阶方阵A，存在一个n阶方阵B，使得AB&#x3D;BA&#x3D;E，则称A是<strong>可逆矩阵</strong>，B是A的<strong>逆矩阵</strong>。记作A-1&#x3D;B</li><li>单位矩阵E是可逆的，它的逆矩阵等于自身，零矩阵不是可逆矩阵</li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>若方阵A可逆，则A的<strong>逆矩阵是唯一</strong>的： 若B，C都是A 的逆矩阵，则AB&#x3D;AC&#x3D;E，B&#x3D;BE&#x3D;B(AC)&#x3D;C(AB)&#x3D;CE，所以 A&#x3D;B</li><li>AB&#x3D;E，则AB均可逆，A-1&#x3D;B，B-1&#x3D;A，判断A是不是B的逆矩阵：判断AB&#x3D;E</li><li><strong>方阵A可逆，则|A|!&#x3D;0，且|A-1|&#x3D;1&#x2F;|A|<strong>，</strong>判断A是否可逆，则仅需判断 |A|！&#x3D;0</strong> ，|A|！&#x3D;0 &lt;&#x3D;&#x3D;&gt; A可逆</li><li>方阵A可逆，则A-1也可逆，则（A-1）-1&#x3D;A</li><li>方阵A可逆，且k！&#x3D;0，则 （kA）-1&#x3D; 1&#x2F;k *（A-1）</li><li>方阵A可逆，则A转置也可逆，（A转置）-1&#x3D;（A-1）转置</li><li>AB是同阶可逆矩阵，AB也可逆，则（AB）-1&#x3D;B-1* A-1</li></ul><h3 id="逆矩阵的求法"><a href="#逆矩阵的求法" class="headerlink" title="逆矩阵的求法"></a>逆矩阵的求法</h3><ul><li>根据伴随矩阵（求低阶方阵逆矩阵） <strong>若A是非奇异矩阵（|A|不等于0，则A是可逆的），则A-1&#x3D;1&#x2F;|A| * A伴随</strong></li></ul><h3 id="逆矩阵的应用"><a href="#逆矩阵的应用" class="headerlink" title="逆矩阵的应用"></a>逆矩阵的应用</h3><ul><li>对于一个线性方程组： A是系数矩阵，B是常系数矩阵，X是未知数矩阵，因此线性方程组用矩阵表示为AX&#x3D;B，<strong>因此求线性方程组的解，可以转换为求相应矩阵的解</strong></li></ul><h2 id="矩阵的初等变换"><a href="#矩阵的初等变换" class="headerlink" title="矩阵的初等变换"></a>矩阵的初等变换</h2><p>性质</p><ol><li>交换矩阵的 第 i 行（列）与第 j 行（列）</li><li>非零常数 k 乘以 矩阵的第 i 行（列）</li><li>矩阵的第 j 行乘以 k倍 加到第 i 行上去</li></ol><p>矩阵的初等行或者列变换统称为 <strong>矩阵的初等变换</strong></p><ul><li>矩阵A经过有限次初等变换变成B，则A与B<strong>等价</strong><ul><li>反身性</li><li>对称性</li><li>传递性</li></ul></li><li>矩阵的左上角为一个<strong>单位矩阵</strong>，其余元素都是零，则该矩阵为<strong>标准型矩阵</strong><ul><li>任何一个非奇异矩阵，经过有限次初等行变换都能变成<strong>单位矩阵 E</strong> </li><li>推论：<strong>矩阵A可逆的充要条件使它与单位矩阵E等价</strong></li></ul></li></ul><p>行变换转换为标准型矩阵的一般步骤:</p><ol><li>行变换 转换为 <strong>行阶梯型矩阵</strong></li><li>行阶梯形矩阵 转换为 <strong>行最简</strong></li><li>行最简 列变换转换为<strong>标准型</strong></li></ol><p><strong>单位矩阵的行数等于行阶梯非零行的行数</strong></p><hr><h3 id="初等矩阵"><a href="#初等矩阵" class="headerlink" title="初等矩阵"></a>初等矩阵</h3><p>三种初等变换：</p><ol><li>交换第 i 行 与第 j 行</li><li>非零常数乘以 第 i 行</li><li>第 j 行乘以k 加到第 i 行上去</li></ol><p>性质：</p><ol><li>初等矩阵都是可逆矩阵，且其逆矩阵也是同类型的初等矩阵</li><li>初等矩阵的转置仍是同类型的初等矩阵</li><li>对一个矩阵A施行一次<strong>初等行变换等于对 A左乘一个m阶单位矩阵</strong>；对矩阵A施行<strong>一次初等列变换相当于对A右乘一个n阶单位矩阵</strong></li></ol><h3 id="初等变换的应用"><a href="#初等变换的应用" class="headerlink" title="初等变换的应用"></a>初等变换的应用</h3><h4 id="求逆矩阵"><a href="#求逆矩阵" class="headerlink" title="求逆矩阵"></a>求逆矩阵</h4><ul><li><strong>对矩阵 A 与 E做相同的初等变换等于对矩阵A 做初等行变换化为单位矩阵E时，E就变成了A的逆矩阵A-1</strong>（单位矩阵E乘以任何矩阵A，都等于矩阵A本身）</li></ul><p>$$<br>(A,E)-&gt;(E,A^{-1})<br>$$</p><p>初等列变换也是同理</p><h4 id="求解矩阵方程"><a href="#求解矩阵方程" class="headerlink" title="求解矩阵方程"></a>求解矩阵方程</h4><p>在矩阵A，B，C均可逆的前提下：</p><ol><li>AX&#x3D;B，则 X&#x3D;A-1B</li><li>XA&#x3D;B，则 X&#x3D;BA-1</li><li>AXB&#x3D;C，则 X&#x3D;A-1CB-1</li></ol><ul><li>对矩阵 A 与 E做相同的初等变换等于对矩阵A 做初等行变换化为单位矩阵E时，E就变成了A的逆矩阵A-1</li></ul><p>$$<br>(A,B)-^{初等行变换}-&gt;(E,A^{-1}B)<br>$$</p><p>初等列变换也是同理</p><hr><h2 id="行最简矩阵与矩阵的秩"><a href="#行最简矩阵与矩阵的秩" class="headerlink" title="行最简矩阵与矩阵的秩"></a>行最简矩阵与矩阵的秩</h2><h3 id="行最简矩阵"><a href="#行最简矩阵" class="headerlink" title="行最简矩阵"></a>行最简矩阵</h3><p>行阶梯形矩阵：</p><ol><li>零行位于所有非零行的下面。</li><li>首非零元前面零的个数一定逐行严格增加</li></ol><p><strong>行最简型矩阵：</strong></p><ol><li>行阶梯形矩阵经过初等行变换使得 <strong>每一行的首非零元全部变为1，且他们所在列的其他元素都是 0</strong>，则成这样的矩阵为 <strong>行最简型矩阵</strong></li></ol><h3 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h3><p>定义：在矩阵A中，<strong>不为零子式的最高阶数称为A的秩</strong>，r（A）&#x3D;min（m，n），则A为满秩矩阵，否则为降秩矩阵</p><p>性质：</p><ul><li><p>任意矩阵A与秩满足： 0&lt;&#x3D;r(A)&lt;&#x3D;min(m,n)</p></li><li><p>矩阵A可逆，则|A|不为零，则与 r（A）&#x3D;n 形成<strong>充分必要条件</strong>，矩阵A为<strong>满秩矩阵</strong></p><ul><li><strong>n阶方阵可逆的充要条件：r(A)&#x3D;n</strong></li></ul></li><li><p><strong>行阶梯形矩阵的秩等于它非零行的行数或者首非零元的个数</strong></p></li></ul><p>求矩阵秩的一般方法：<strong>用初等变换将矩阵转换为阶梯型矩阵</strong></p><p>关于秩的相关结论：</p><ol><li>矩阵A的 n 阶子式全为0，则 r(A)&lt;n</li><li>矩阵A的 n 阶子式全不为0，则 r(A)&gt;&#x3D;n</li><li>若矩阵A与B等价，则 r(A)&#x3D;r(B)</li><li>若矩阵Q，P可逆，则 r(PA)&#x3D;r(AQ)&#x3D;r(PAQ)&#x3D;r(A)</li></ol><h3 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="*分块矩阵"></a>*分块矩阵</h3><hr><h1 id="向量组的线性相关性"><a href="#向量组的线性相关性" class="headerlink" title="向量组的线性相关性"></a>向量组的线性相关性</h1><p>向量的线性运算</p><p><strong>线性方程组的向量形式： a1x1+a2x2+a3x3+ … a4x4&#x3D;B，借助向量可以讨论线性方程组</strong></p><h3 id="向量组的线性关系"><a href="#向量组的线性关系" class="headerlink" title="向量组的线性关系"></a>向量组的线性关系</h3><h4 id="线性组合与线性表示"><a href="#线性组合与线性表示" class="headerlink" title="线性组合与线性表示"></a>线性组合与线性表示</h4><p>定义：设 n维向量组 a1，a2，a3 ，B</p><ol><li><p>若k1，k2，k3为任意一组常数，则称 k1a1+k2a2+k3a3…+k4a4为向量组 a1+a2+a3的一个<strong>线性组合</strong></p></li><li><p>若k1，k2，k3为任意一组常数，使得 B&#x3D;k1a1+k2a2+k3a3+…knan成立，则称B可由向· 量组<strong>线性表示</strong></p></li></ol><p><strong>向量B是否可由a1,a2,a3,an线性表示的方法：判断线性方程组k1a1+k2a2+knan是否有解</strong></p><p>​                                                                                                                  </p><h4 id="线性相关与线性无关"><a href="#线性相关与线性无关" class="headerlink" title="线性相关与线性无关"></a>线性相关与线性无关</h4><ol><li>若存在一组<strong>不全为零</strong>的数 k1,k2,k3,kn 使得 k1a1+k2a2+…+knan &#x3D;0 成立，则称a1,a2,a3是<strong>线性相关</strong>的</li><li>当且仅当 k1,k2,k3,kn <strong>全为零</strong> 使得 k1a1+k2a2+…+knan &#x3D;0 成立，则称a1,a2,a3是<strong>线性无关</strong>的</li></ol><p>简单来说：</p><ol><li><strong>线性相关：有非零解</strong></li><li><strong>线性无关：只有零解</strong></li></ol><p><strong>判断一个向量组的线性关系的方法：</strong></p><ol><li>令 k1a1+k2a2+…+knan &#x3D;0，求出 k1,k2,k3的值</li><li><strong>如果全为零：线性无关；不全为零：线性相关</strong></li></ol><hr><h4 id="线性相关性结论-重要"><a href="#线性相关性结论-重要" class="headerlink" title="线性相关性结论(重要)"></a>线性相关性结论(重要)</h4><ul><li><strong>s个n维 即n*s形式的矩阵：</strong>  线性方程组<strong>线性相关的充要条件是齐次线性方程组有非零解</strong>，<strong>线性无关的充要条件是齐次线性方程组只有零解</strong><ul><li><strong>n个n维 即方阵：向量组线性相关的充要条件是行列式的值为0；线性无关的充要条件是行列式的值不为0.</strong></li><li><strong>向量组所含向量的个数大于维数，向量组一定线性相关</strong></li></ul></li></ul><blockquote><ol><li>方阵形式：直接判断行列式的值是否为零，线性相关D为0，线性无关D不为0</li><li>行数大于列数的矩阵：判断齐次线性方程组的解，线性相关有非零解，线性无关只有零解</li><li>列数大于行数的矩阵：向量个数大于维数，一定线性相关</li></ol></blockquote><ul><li>向量组 a1  a2  am线性<strong>相关</strong>的充分必要条件是：其中至少有一个向量可由其余m -1 个向量线性表示<ul><li>向量组 a1  a2  am线性<strong>无关</strong>的充分必要条件是：其中每一个向量都不能由其余m -1 个向量线性表示</li></ul></li><li>若向量组 a1  a2  am线性无关，而向量组 a1  a2  a3 B线性相关，<strong>则 B可由 a1  a2  a3 线性表示，且表达式唯一</strong></li><li>若部分线性相关，则整个向量组也线性相关<ul><li>若整体线性无关，则任意一个部分也线性无关</li></ul></li><li>如果n维向量组 a1  a2  an线性无关，则在每一个向量上都添加 m 个分量，得到的 <strong>n+m 维接长的向量组也线性无关</strong><ul><li>如果n维向量组 a1  a2  an线性相关，则在每一个向量上都减去 m 个分量，得到的 <strong>n-m 维截断的向量组也线性相关</strong></li></ul></li></ul><h2 id="向量组的秩"><a href="#向量组的秩" class="headerlink" title="向量组的秩"></a>向量组的秩</h2><h3 id="向量组的极大无关组"><a href="#向量组的极大无关组" class="headerlink" title="向量组的极大无关组"></a>向量组的极大无关组</h3><p>定义：设向量组T： a1 ,  a2 , a3 … an 中有一部分向量组 a1  a2   a3   ar （r&lt;n）满足</p><ol><li>a1 a2 a3  ar<strong>线性无关</strong></li><li>在向量组T中除去（1-r）任取一个向量 ai，<strong>满足 a1 a2  a3 ar，ai 线性相关</strong>，则称 a1  a2  a3  ar是向量组T的一个<strong>极大线性无关组</strong>。简称为极大无关组</li></ol><p>根据上节的结论:</p><blockquote><p>若向量组 a1  a2  am线性无关，而向量组 a1  a2  a3 B线性相关，<strong>则 B可由 a1  a2  a3 线性表示，且表达式唯一</strong></p></blockquote><p>可得：<strong>向量组T中任意向量 ai 都可由 a1  a2   a3   ar线性表示</strong></p><p>极大无关组不一定是唯一的，只含零向量的向量组没有极大无关组</p><hr><p>定义2：设有两个向量组1，2，向量组2中的每一个元素都可由向量组1线性表示，则<strong>称向量组2可由向量组1线性表示</strong>，否则称不可线性表示。</p><ul><li>若两个向量组1和2可以<strong>互相</strong>线性表示，则称他们<strong>等价</strong></li></ul><p>定理：</p><ul><li><strong>若向量组1可以由向量组2线性表示，且向量组1的元素个数大于向量组2的元素个数，则向量组1线性相关</strong></li></ul><h3 id="向量组的秩的定义"><a href="#向量组的秩的定义" class="headerlink" title="向量组的秩的定义"></a>向量组的秩的定义</h3><p>定义： 向量组T的极大无关组所包含向量的个数，称为向量组的的秩</p><p>定理：</p><ul><li>向量组 a1 a2  as<strong>线性无关</strong>的充要条件是 r(a1 a2 as)&#x3D;s，即<strong>它的秩等于它所包含的向量的个数</strong></li><li>相互等价的向量组的秩相等</li><li><strong>如果两个向量组的秩相等，且其中一个向量组可由另一个线性表示，则两个向量组等价</strong></li></ul><blockquote><ol><li>秩的个数等于向量的个数，线性无关</li><li>秩的个数小于向量的个数，线性相关</li></ol></blockquote><p>行向量组与列向量组：</p><ul><li>行向量组的秩为<strong>行秩</strong>，列向量组的秩为<strong>列秩</strong></li><li><strong>行秩&#x3D;列秩&#x3D;矩阵的秩</strong></li></ul><p><strong>求向量组极大无关组的方法：先将列向量组构成矩阵A，然后对A实行初等行变换，把A化为行最简型矩阵，由行最简型矩阵列之间的关系，确定原向量组间的线性关系，从而确定极大无关组。</strong></p><h2 id="向量空间"><a href="#向量空间" class="headerlink" title="*向量空间"></a>*向量空间</h2><h1 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h1><p>阶梯型方程组：对线性方程组做初等变换所得到的就是<strong>阶梯型方程组</strong></p><ul><li>系数矩阵：由未知数的系数所构成的矩阵称为线性方程组的<strong>系数矩阵</strong></li><li>线性方程组的系数和常数项所构成的矩阵称为线性方程组的<strong>增广矩阵</strong></li></ul><h3 id="消元法解线性方程组"><a href="#消元法解线性方程组" class="headerlink" title="消元法解线性方程组"></a>消元法解线性方程组</h3><ol><li><p>就是对方程组的增广矩阵做初等行变换，化为<strong>阶梯型矩阵</strong>，从而得到方程组的解</p></li><li><p>对增广矩阵化为<strong>行最简型矩阵</strong>，更容易求解</p></li></ol><blockquote><p>有无解的判定：</p><p>增广矩阵的秩 &#x3D; 系数矩阵的秩 &#x3D; 未知量的个数，则方程组 Ax&#x3D;b 具有<strong>唯一解</strong></p><p>增广矩阵的秩 不等于 系数矩阵的秩，则方程组Ax&#x3D;b<strong>无解</strong>，存在一行，满足系数项全为零，而常数项不为零</p></blockquote><h3 id="非齐次线性方程组解的判定"><a href="#非齐次线性方程组解的判定" class="headerlink" title="非齐次线性方程组解的判定"></a>非齐次线性方程组解的判定</h3><ul><li>线性方程组 Amn * X&#x3D;b <strong>有解</strong>的 充要条件 是 r（A，b）&#x3D; r（A）</li><li>当线性方程组 Amn * X&#x3D;b 有解时：<strong>r 为秩，n为系数项数，即未知量的个数</strong><ul><li>若  r（A，b）&#x3D; r（A）&#x3D;<strong>r &#x3D; n</strong>，方程组有<strong>唯一解</strong></li><li>若  r（A，b）&#x3D; r（A）&#x3D;<strong>r &lt; n</strong>，方 程组有<strong>无穷多解</strong></li></ul></li><li>同理， Amn * X &#x3D;b <strong>无解</strong>的充要条件是 r（A，b）!&#x3D;r（A）</li></ul><h3 id="齐次线性方程组解的判定"><a href="#齐次线性方程组解的判定" class="headerlink" title="齐次线性方程组解的判定"></a>齐次线性方程组解的判定</h3><p>齐次线性方程组一定满足：r（A，b）&#x3D;r（A）</p><ul><li>齐次线性方程组Amn * X&#x3D;0 <strong>只有零解的充要条件是 r（A）&#x3D; n</strong></li><li>齐次线性方程组Amn * X&#x3D;0 <strong>有非零解的充要条件是 r（A）&lt; n</strong>（有非零解即为无穷多解）</li></ul><h3 id="齐次线性方程组的解的结构"><a href="#齐次线性方程组的解的结构" class="headerlink" title="齐次线性方程组的解的结构"></a>齐次线性方程组的解的结构</h3><p>解向量的概念</p><p><strong>若齐次线性方程组有非零解，则它会有无穷多解，这些解组成一个n维向量组，若能求出这个向量组的一个极大无关组，则就能用它来表示它的全部解，这个极大无关组称为齐次线性方程组的基础解系</strong></p><p>齐次线性方程组有非零解，则它一定有基础解系。</p><ul><li><p>定理1：<strong>如果齐次线性方程组Amn * X&#x3D;0 的系数矩阵A的秩 r（A）&#x3D; r &lt; n，则Amn * X&#x3D;0 的基础解系中有 n-r个解向量</strong></p></li><li><p><strong>齐次线性方程组的基础解系求解</strong></p></li><li><p><strong>非齐次线性方程组的基础解系求解</strong></p></li></ul><blockquote><p>求线性方程组通解的一般步骤</p><p>齐次线性方程组：</p></blockquote><blockquote><ol><li>对于增广矩阵化简为 <strong>行最简型矩阵</strong></li><li>判断解的情况并且得到解向量的个数&#x3D;n-r</li><li>通过行最简矩阵得到<strong>自由未知量</strong>，首非零元与自由未知量确定方程，求方程解，得到各个未知量的解，并且得到每一个<strong>基础解系</strong></li><li>通解为 各个基础解系的k倍和</li></ol><p>非齐次线性方程组：</p><ol><li>步骤与上面基本一致，但是通解为：特解 + 导出组（导出组指的是常数项为0）的基础解系</li></ol></blockquote><hr><h1 id="矩阵相似与对角化"><a href="#矩阵相似与对角化" class="headerlink" title="矩阵相似与对角化"></a>矩阵相似与对角化</h1><h2 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h2><p>定义1：<strong>设A&#x3D;（aij）nn为n阶实方阵，如果存在某个非零 r 和某个n维非零列向量 p 满足： Ap&#x3D;rp，则 r 是A 一个特征值，p是A的属于特征值为r 的一个特征向量</strong></p><p>定义2：带参数r的n阶方阵称为A的<strong>特征方阵</strong>；它的行列式称为A的<strong>特征多项式</strong>；|rE-A|&#x3D;0称为A的<strong>特征方程</strong></p><p>求解特征值与特征向量的方法：</p><ul><li><strong>n阶实方阵的特征值就是它的特征方程的n个根</strong></li><li><strong>任意取定一个特征值，其对应特征向量就是相应齐次线性方程组（rE-A）x&#x3D;0 的所有非零解</strong></li></ul><hr><h2 id="特征值与特征向量的若干结论"><a href="#特征值与特征向量的若干结论" class="headerlink" title="特征值与特征向量的若干结论"></a>特征值与特征向量的若干结论</h2><ol><li><p><strong>实方阵的特征值未必是实数，特征向量也未必是实向量</strong></p></li><li><p>上下三角矩阵的特征值就是它的<strong>全体对角元素</strong></p></li><li><p>一个向量p不可能是属于同一个方阵A的不同特征值的特征向量</p></li><li><p>n阶方阵和它的转置具有相同的特征值</p></li><li><p>r1  r2  r3 为A的全体特征值则必有：即<strong>特征值之和等于对角线元素之和（迹）</strong>，<strong>特征值之积等于行列式的值</strong></p></li></ol><p>$$<br>\sum_{i&#x3D;1}^{n}\lambda_{i}&#x3D;\sum_{i&#x3D;1}^{n}a_{ii}&#x3D;tr(A) \qquad \prod_{i&#x3D;1}^{n}\lambda_{i}&#x3D;|A|<br>$$</p><ol start="6"><li><strong>只要 r 是A的特征值，那么 f(r) 一定是 f(A) 的特征值</strong></li></ol><hr><p>###求特征值和特征向量的一般方法</p><p>步骤：</p><ol><li><p>求出特征值，检查特征值之和是否等于行列式对角线元素之和，即<strong>迹</strong>，特征值之积是否等于行列式的值。</p></li><li><p>属于特征值的特征向量全体是 …</p></li></ol><h2 id="相似矩阵与可对角化的条件"><a href="#相似矩阵与可对角化的条件" class="headerlink" title="相似矩阵与可对角化的条件"></a>相似矩阵与可对角化的条件</h2><p>定义1： A与B是n阶方阵，如果存在一个n阶可逆矩阵P，使得 P-1AP&#x3D;B，则称A与B相似，记作A~B</p><p><strong>相似矩阵具有对称性，传递性，反身性</strong></p><p>两矩阵相似的特征：</p><ol><li>相同的特征值</li><li>相同的行列式值</li><li>迹相等，即对角线元素之和相同</li><li>秩相同</li></ol><h3 id="矩阵可对角化"><a href="#矩阵可对角化" class="headerlink" title="矩阵可对角化"></a>矩阵可对角化</h3><p><strong>定理3：n阶方阵相似于n阶对角矩阵的充要条件：A有n个线性无关的特征向量</strong></p><p><strong>推论：如果n阶矩阵A有n个互不相同的特征值 r1 r2  r3  r4 … rn，则A与对角矩阵 相似，并且对角矩阵的对角线元素为 r1 r2  r3  r4 … rn。</strong></p><p>n阶矩阵与对角矩阵相似的充分必要条件是：对于A的每一个n重特征值，齐次线性方程组（rE-A）x&#x3D;0 的基础解系中恰含n个向量</p><h2 id="向量的内积与正交矩阵"><a href="#向量的内积与正交矩阵" class="headerlink" title="向量的内积与正交矩阵"></a>向量的内积与正交矩阵</h2><h3 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h3><p>概念：两个矩阵的对应元素相乘再相加，得到的一个<strong>数值</strong>，是两个矩阵的内积，记作：[A，B]</p><ul><li>施瓦茨不等式</li></ul><p>定义2<strong>：向量的内积开根号 叫做向量的长度，向量的长度用||A||表示</strong>，例如：a&#x3D;(a1,a2,a3) ， ||a||&#x3D;根号下[a,a]，</p><ul><li>若 ||a||&#x3D;1，称a为单位向量</li></ul><h3 id="正交向量组"><a href="#正交向量组" class="headerlink" title="正交向量组"></a>正交向量组</h3><p>定义：若[a,b]&#x3D;0，则向量a，b正交</p><p><strong>由非零向量两两正交组成的向量组称为正交向量组</strong></p><ul><li>正交向量组内每一个ai一定是线性无关的</li></ul><hr><p>施密特正交化：正交化 -&gt; 单位化</p><h1 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h1><p>含n个变量的 二次齐次多项式称为一个n元二次型，简称二次型</p><ul><li>令A为一个实对称矩阵，二次型式用矩阵表示为 f&#x3D;x^T Ax  <ul><li>A称为二次型f的矩阵，对称阵A的秩为二次型f的秩</li><li>二次型与对称阵具有一一对应的关系，<strong>一个二次型f由其对应的实对称矩阵A唯一确定。当给定了二次型f后，便可以确定其对应的实对称矩阵A</strong><ul><li>A的对角线元素为：aii为xi ^2项的<strong>系数</strong></li><li>A的其他元素为： aij &#x3D; aji 为 xij 项的<strong>系数的 1&#x2F;2</strong></li></ul></li></ul></li></ul><h2 id="可逆变换"><a href="#可逆变换" class="headerlink" title="可逆变换"></a>可逆变换</h2><p>若C 是可逆矩阵，x&#x3D;Cy为可逆线性变换；若C是正交矩阵，则x&#x3D;Cy为正交线性变换</p><p><strong>定义： 如果A，B均为n阶方阵，若存在可逆矩阵C，使得 CT A C &#x3D;B，则称A与B合同</strong></p><ul><li>如果A为对称矩阵，AB合同，则B也为对称矩阵</li><li>A与B合同，则R（A）&#x3D;R（B）</li><li>合同具有传递性</li></ul><h2 id="二次型的标准型"><a href="#二次型的标准型" class="headerlink" title="二次型的标准型"></a>二次型的标准型</h2><p><strong>定义：只含平方项的 二次型称为二次型的标准型</strong></p><p>正交变换法化二次型为标准型的方法：</p><ol><li>写出二次型的矩阵A，求其特征值 </li><li>求出特征值对应的特征向量，并且将他们正交单位化</li><li>将正交单位化后的特征向量依次作为列向量构成正交矩阵P。</li><li>做正交变换 x&#x3D;Py，得二次型的标准型</li></ol><blockquote><p>正交单位化的时候：</p><ol><li>如果对应不同的特征值，所以他们正交，直接单位化即可</li><li>如果对应相同的特征值，所以要首先正交化，然后再单位化</li></ol></blockquote><h3 id="配方法化二次型为标准型"><a href="#配方法化二次型为标准型" class="headerlink" title="配方法化二次型为标准型"></a>配方法化二次型为标准型</h3><h3 id="初等变换化二次型为标准型"><a href="#初等变换化二次型为标准型" class="headerlink" title="初等变换化二次型为标准型"></a>初等变换化二次型为标准型</h3><h2 id="正定二次型"><a href="#正定二次型" class="headerlink" title="正定二次型"></a>正定二次型</h2><p>判别方法：f&#x3D;xT A x正定的充要条件是 矩阵A的特征值都是正数</p><p><strong>实对阵矩阵A正定的充要条件是 A的各阶顺序子式都大于0</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>A星寻路算法详解</title>
    <link href="http://example.com/2023/03/01/A%E6%98%9F%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/03/01/A%E6%98%9F%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-03-01T12:16:57.000Z</published>
    <updated>2023-03-01T12:17:42.950Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>@[toc]</p><h2 id="三种寻路算法"><a href="#三种寻路算法" class="headerlink" title="三种寻路算法"></a>三种寻路算法</h2><ul><li><a href="https://blog.csdn.net/jj6666djdbbd/article/details/126205770">深度寻路算法：不一定能找到最佳路径，但是寻路快速，只能走直线。</a></li><li><a href="https://blog.csdn.net/jj6666djdbbd/article/details/126265199">广度寻路算法：一定能找到最短路径，但是开销大，时间慢，只能走直线。</a></li><li><strong>A星寻路算法</strong>（常用）：一定能找到最短路径，可以走直线和斜线，而且开销较小，常用于大型地图的寻路</li></ul><h1 id="A星寻路算法"><a href="#A星寻路算法" class="headerlink" title="A星寻路算法"></a>A星寻路算法</h1><h2 id="A星寻路算法思想"><a href="#A星寻路算法思想" class="headerlink" title="A星寻路算法思想"></a>A星寻路算法思想</h2><blockquote><p>引入： 狼吃羊模型。</p><p>狼捕猎羊：如果抓到了就加100分；如果狼不动，每分钟减2分；如果狼抓捕时会跑，跑步每分钟减5分；</p><p>​ 狼会饿 ，饿的时候每分钟减10分。 有一个积分的概念在这里面。结果会发现<strong>狼会站在原地不动</strong>。</p><p>​因为狼直到，抓住羊很困难，跑步时会扣分，饿时会扣分，不动时也会扣分。但是人工智能狼计算出了站着不动时扣分的代价最低，而干其他事代价都高，因此狼会自动选择代价最低的方式，一动不动</p><p>​之后又加了设定：原地不动每分钟也扣分，而且是线性扣分。结果你会发现<strong>狼从一开始就会自杀</strong>。</p><p>同理，<strong>自杀是代价最小的选择</strong>（即分数最高，如果你干其他的事，则可能会负分，所以狼会选择自杀）。</p></blockquote><p>A星寻路算法也引入了这一概念，即通过<strong>计算和量化行走的各个方向的代价</strong>，来<strong>选择最优路径</strong></p><ul><li><em><strong>公式： f &#x3D; g + h</strong></em></li><li>f： 设定其为<strong>最终评估代价</strong></li><li>g：当前点走到下一点的<strong>付出的代价</strong></li><li>h：当前点到终点的<strong>预期代价</strong></li><li>通过比较各条路线的最终代价，选择<strong>最小代价</strong>，即为合适的路径，也为<strong>最短路径</strong>。</li></ul><h2 id="A星寻路准备"><a href="#A星寻路准备" class="headerlink" title="A星寻路准备"></a>A星寻路准备</h2><p>地图行列数，方向枚举，地图，辅助地图的设计等在此不描述，具体请看之前我写的前两种寻路算法的博客。<br><a href="https://blog.csdn.net/jj6666djdbbd/article/details/126265199?spm=1001.2014.3001.5502">广度寻路算法</a><br><a href="https://blog.csdn.net/jj6666djdbbd/article/details/126205770?spm=1001.2014.3001.5502">深度寻路算法</a></p><ul><li><strong>记录坐标点的类型</strong>，GetH和GetF函数即为计算各种代价的函数，稍后会介绍。一个重载用来比较当前点是否到达终点</li></ul><blockquote><p>h表示当前点到终点的预期代价，因此我们每次移动一步，都需要求出 h，而h的计算我们可以直接通过数格子来获得，即水平，竖直个有几个格子，这便是<strong>预期的代价</strong><br>g表示走到每一点的代价，因此每走一个方向，记录这个方向的代价， 最后选择代价最小的方向即可，g可以通过遍历八个方向来记录<br>f &#x3D;g + h</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mypoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> row;</span><br><span class="line"><span class="type">int</span> col;</span><br><span class="line"><span class="type">int</span> f, g, h;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> (pos.row == row &amp;&amp; pos.col == col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetH</span><span class="params">(<span class="type">const</span> Mypoint&amp; Begpos, <span class="type">const</span> Mypoint&amp; Endpos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">abs</span>(Begpos.col - Endpos.col);<span class="comment">//计算水平差距</span></span><br><span class="line"><span class="type">int</span> y = <span class="built_in">abs</span>(Begpos.row - Endpos.row);<span class="comment">//计算垂直差距</span></span><br><span class="line">h = x + y;<span class="comment">//计算总的差距</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f = g + h;<span class="comment">//计算f</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>存储位置节点的树结构</strong>，含有构造函数用来构建树节点，<strong>vector数组</strong>存储多个节点：因为一个父亲会有多个孩子的情况。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树结构存储节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">Mypoint pos;<span class="comment">//当前点坐标</span></span><br><span class="line">TreeNode* pParent;<span class="comment">//当前点的父节点</span></span><br><span class="line">vector&lt;TreeNode*&gt; pChild;<span class="comment">//存储当前点的所有孩子节点</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pos = pos;</span><br><span class="line">pParent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>判断是否能走的函数</strong>，用于判断地图某个点是否能走，即不为墙，没越界，没走过，则能走。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断某个点能否走</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CanWalk</span><span class="params">(<span class="type">int</span> map[ROW][COL], <span class="type">bool</span> vis[ROW][COL], <span class="type">const</span> Mypoint&amp; pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果越界，不能走</span></span><br><span class="line"><span class="keyword">if</span> (pos.row &lt; <span class="number">0</span> || pos.col &lt; <span class="number">0</span> || pos.row &gt;= ROW || pos.col &gt;= COL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是墙，不能走</span></span><br><span class="line"><span class="keyword">if</span> (map[pos.row][pos.col])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果已经走过，不能走</span></span><br><span class="line"><span class="keyword">if</span> (vis[pos.row][pos.col])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//否则能走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>数据的准备</strong></li></ul><ol><li>起点与终点的坐标</li><li>树根节点，用于保存寻路的<strong>树结构</strong></li><li>buff数组来记录每一个孩子节点，<strong>用来确定下一步该走的点</strong></li><li>vis标记数组，不能重复走</li><li>当前点与试探点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//地图，1表示墙，0表示路径</span></span><br><span class="line"><span class="type">int</span> map[ROW][COL] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//起始点和终点</span></span><br><span class="line">Mypoint Begpos = &#123; <span class="number">1</span>,<span class="number">1</span> &#125;;</span><br><span class="line">Mypoint Endpos = &#123; <span class="number">6</span>,<span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记有没有走过</span></span><br><span class="line"><span class="type">bool</span> vis[ROW][COL] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建树根，即根节点</span></span><br><span class="line">TreeNode* pRoot = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(Begpos);</span><br><span class="line"></span><br><span class="line">vector&lt;TreeNode*&gt; buff;<span class="comment">//存储孩子节点的数组</span></span><br><span class="line"></span><br><span class="line">TreeNode* pCurrent = pRoot;<span class="comment">//记录当前点</span></span><br><span class="line">TreeNode* pTemp = <span class="literal">nullptr</span>;<span class="comment">//试探节点,用于试探下一个位置的点</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isFindEnd = <span class="literal">false</span>;<span class="comment">//终点标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="A星寻路过程（图例）"><a href="#A星寻路过程（图例）" class="headerlink" title="A星寻路过程（图例）"></a>A星寻路过程（图例）</h2><p>假定<strong>直着走的代价为10，斜着走的代价为14</strong></p><ul><li><p>首先计算起点位置周围八个方向<strong>付出代价</strong>（蓝色），此代价为<strong>付出的代价 g</strong>。<br><img src="https://img-blog.csdnimg.cn/15215e45fdd948fda712c731eb17c42f.png" alt="在这里插入图片描述"></p></li><li><p>然后再计算<strong>起点到终点的代价</strong>（如何计算：数格子即可，某个点到终点的格子数，只能行列，不能斜着），此代价为<strong>预期代价h</strong>，可以发现 <strong>最终代价&#x3D;付出+预期</strong>，可以得到一个<strong>最小的代价点</strong>，即<strong>右下角的斜着的点</strong>。</p><p><strong>这个点即是我们下一步要走的点</strong>。<strong>依次类推，在下个点上，再次计算周围代价最小的点，然后再次移动</strong></p></li></ul><hr><p>upd： 2023. 2.22 新增一个图<br><img src="https://img-blog.csdnimg.cn/a88609b83bba49f49c4a55de372be256.png" alt="在这里插入图片描述"></p><hr><ul><li><p>注意：标记起始点和每个移动到的点为<strong>已经走过点</strong>，即下一次不会重复移动到这个点。</p></li><li><p>在移动到的点处（代价最小点），继续遍历八个方向，除了<strong>墙壁</strong>和<strong>已经走过点</strong>，继续计算最终代价，<strong>找到最终代价小的点，移动。</strong><br><img src="https://img-blog.csdnimg.cn/29dbe25e620e46679e0b2e965afed765.png" alt="在这里插入图片描述"></p></li><li><p>注意：如果你移动到了一个死胡同，则必须回退，<strong>如何回退</strong>?<br>我们事先准备了<strong>一个容器vector</strong>名字叫做 buff ，来<strong>存储我们每次遍历的方向的节点</strong>，即我们把每一个方向都创建一个节点，然后<strong>节点入树</strong>，<strong>节点再入容器</strong>，当我们走到死胡同时，<strong>通过找到容器内的最小元素</strong>（即是代价最小点，但是这个点是死胡同），<strong>然后把他删除</strong>，则 &#x3D;&#x3D;<strong>再次找一个代价最小点</strong>，<strong>然后移动到它那里去</strong>&#x3D;&#x3D; 。<br><strong>如果地图没有终点，则可以想到，容器会一直删除，然后为空，此时则退出，没有终点。</strong></p></li></ul><hr><h2 id="A星寻路代码（完整）"><a href="#A星寻路代码（完整）" class="headerlink" title="A星寻路代码（完整）"></a>A星寻路代码（完整）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ROW = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> COL = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ZXDJ = <span class="number">10</span>;<span class="comment">//直线代价</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> XXDJ = <span class="number">14</span>;<span class="comment">//斜线代价</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Dir</span> &#123; p_up, p_down, p_left, p_right, p_lup, p_ldown, p_rup, p_rdown &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mypoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> row;</span><br><span class="line"><span class="type">int</span> col;</span><br><span class="line"><span class="type">int</span> f, g, h;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> (pos.row == row &amp;&amp; pos.col == col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetH</span><span class="params">(<span class="type">const</span> Mypoint&amp; Begpos, <span class="type">const</span> Mypoint&amp; Endpos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">abs</span>(Begpos.col - Endpos.col);<span class="comment">//计算水平差距</span></span><br><span class="line"><span class="type">int</span> y = <span class="built_in">abs</span>(Begpos.row - Endpos.row);<span class="comment">//计算垂直差距</span></span><br><span class="line">h = x + y;<span class="comment">//计算总的差距</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f = g + h;<span class="comment">//计算f</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构存储节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">Mypoint pos;<span class="comment">//当前点坐标</span></span><br><span class="line">TreeNode* pParent;<span class="comment">//当前点的父节点</span></span><br><span class="line">vector&lt;TreeNode*&gt; pChild;<span class="comment">//存储当前点的所有孩子节点</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">const</span> Mypoint&amp; pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pos = pos;</span><br><span class="line">pParent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断某个点能否走</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CanWalk</span><span class="params">(<span class="type">int</span> map[ROW][COL], <span class="type">bool</span> vis[ROW][COL], <span class="type">const</span> Mypoint&amp; pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果越界，不能走</span></span><br><span class="line"><span class="keyword">if</span> (pos.row &lt; <span class="number">0</span> || pos.col &lt; <span class="number">0</span> || pos.row &gt;= ROW || pos.col &gt;= COL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是墙，不能走</span></span><br><span class="line"><span class="keyword">if</span> (map[pos.row][pos.col])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果已经走过，不能走</span></span><br><span class="line"><span class="keyword">if</span> (vis[pos.row][pos.col])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//否则能走</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//地图，1表示墙，0表示路径</span></span><br><span class="line"><span class="type">int</span> map[ROW][COL] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//起始点和终点</span></span><br><span class="line">Mypoint Begpos = &#123; <span class="number">1</span>,<span class="number">1</span> &#125;;</span><br><span class="line">Mypoint Endpos = &#123; <span class="number">6</span>,<span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记有没有走过</span></span><br><span class="line"><span class="type">bool</span> vis[ROW][COL] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建树根，即根节点</span></span><br><span class="line">TreeNode* pRoot = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(Begpos);</span><br><span class="line"></span><br><span class="line">vector&lt;TreeNode*&gt; buff;<span class="comment">//存储孩子节点的数组</span></span><br><span class="line"></span><br><span class="line">TreeNode* pCurrent = pRoot;<span class="comment">//记录当前点</span></span><br><span class="line">TreeNode* pTemp = <span class="literal">nullptr</span>;<span class="comment">//试探节点,用于试探下一个位置的点</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isFindEnd = <span class="literal">false</span>;<span class="comment">//终点标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始寻路</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1. 某个点八个方向依次遍历 计算g代价</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//确定试探点的属性</span></span><br><span class="line">pTemp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pCurrent-&gt;pos);</span><br><span class="line"><span class="comment">//八个方向进行试探！</span></span><br><span class="line"><span class="keyword">switch</span> (i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//直线代价</span></span><br><span class="line"><span class="keyword">case</span> p_up:<span class="comment">//上</span></span><br><span class="line">pTemp-&gt;pos.row--;</span><br><span class="line">pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> p_down:<span class="comment">//下</span></span><br><span class="line">pTemp-&gt;pos.row++;</span><br><span class="line">pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> p_left:<span class="comment">//左</span></span><br><span class="line">pTemp-&gt;pos.col--;</span><br><span class="line">pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> p_right:<span class="comment">//右</span></span><br><span class="line">pTemp-&gt;pos.col++;</span><br><span class="line">pTemp-&gt;pos.g += ZXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//斜线代价</span></span><br><span class="line"><span class="keyword">case</span> p_lup:<span class="comment">//左上</span></span><br><span class="line">pTemp-&gt;pos.row--;</span><br><span class="line">pTemp-&gt;pos.col--;</span><br><span class="line">pTemp-&gt;pos.g += XXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> p_ldown:<span class="comment">//左下</span></span><br><span class="line">pTemp-&gt;pos.row++;</span><br><span class="line">pTemp-&gt;pos.col--;</span><br><span class="line">pTemp-&gt;pos.g += XXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> p_rup:<span class="comment">//右上</span></span><br><span class="line">pTemp-&gt;pos.row--;</span><br><span class="line">pTemp-&gt;pos.col++;</span><br><span class="line">pTemp-&gt;pos.g += XXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> p_rdown:<span class="comment">//右下</span></span><br><span class="line">pTemp-&gt;pos.row++;</span><br><span class="line">pTemp-&gt;pos.col++;</span><br><span class="line">pTemp-&gt;pos.g += XXDJ;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断他们能不能走，能走的计算h及f 入树  存储在buff数组</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CanWalk</span>(map, vis, pTemp-&gt;pos))</span><br><span class="line">&#123;<span class="comment">//能走</span></span><br><span class="line"><span class="comment">//计算代价</span></span><br><span class="line">pTemp-&gt;pos.<span class="built_in">GetH</span>(Begpos, Endpos);<span class="comment">//计算h代价</span></span><br><span class="line">pTemp-&gt;pos.<span class="built_in">GetF</span>();<span class="comment">//得到最后的f代价，f=g+h </span></span><br><span class="line"><span class="comment">//把能走的这个点存入树中</span></span><br><span class="line">pCurrent-&gt;pChild.<span class="built_in">push_back</span>(pTemp);<span class="comment">//pTemp表示的就是下一个能走的点</span></span><br><span class="line">pTemp-&gt;pParent = pCurrent;<span class="comment">//父子关系确定</span></span><br><span class="line"><span class="comment">//存入数组</span></span><br><span class="line">buff.<span class="built_in">push_back</span>(pTemp);</span><br><span class="line"><span class="comment">//标记这个点走过</span></span><br><span class="line">vis[pTemp-&gt;pos.row][pTemp-&gt;pos.col] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//不能走则删除pTemp，继续遍历下一个方向的点</span></span><br><span class="line"><span class="keyword">delete</span> pTemp;</span><br><span class="line">pTemp = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遍历完八个方向后，找到最小代价点，并且移动，然后删除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">auto</span> itMin =  <span class="built_in">min_element</span>(buff.<span class="built_in">begin</span>(), buff.<span class="built_in">end</span>(), [&amp;](TreeNode* p1, TreeNode* p2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p1-&gt;pos.f &lt; p2-&gt;pos.f;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前点移动到这个最小代价点</span></span><br><span class="line">pCurrent = *itMin;</span><br><span class="line"><span class="comment">//删除最小代价节点</span></span><br><span class="line">buff.<span class="built_in">erase</span>(itMin);</span><br><span class="line"></span><br><span class="line"><span class="comment">//有没有到达终点</span></span><br><span class="line"><span class="keyword">if</span> (pCurrent-&gt;pos == Endpos)</span><br><span class="line">&#123;</span><br><span class="line">isFindEnd = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有终点，自然一直删除节点，则buff为空</span></span><br><span class="line"><span class="keyword">if</span> (buff.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFindEnd)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到终点了!\n&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (pCurrent)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; pCurrent-&gt;pos.row &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pCurrent-&gt;pos.col &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">pCurrent = pCurrent-&gt;pParent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到终点!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终点row，col（7，7）：<br><img src="https://img-blog.csdnimg.cn/2f6b0a76593c489ea4ea769344cd20fa.png" alt="在这里插入图片描述"></p><p>终点row，col（6，5）<br><img src="https://img-blog.csdnimg.cn/ea18d5c7ee2e41eb820e65e6fd5e172f.png" alt="在这里插入图片描述"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="搜索与寻路" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%AF%BB%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>第一篇文章</title>
    <link href="http://example.com/2023/03/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>http://example.com/2023/03/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</id>
    <published>2023-03-01T06:35:55.000Z</published>
    <updated>2023-03-01T09:18:24.996Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="我的个人博客"><a href="#我的个人博客" class="headerlink" title="我的个人博客"></a>我的个人博客</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/03/01/hello-world/"/>
    <id>http://example.com/2023/03/01/hello-world/</id>
    <published>2023-03-01T06:30:47.716Z</published>
    <updated>2023-03-01T06:28:31.135Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
